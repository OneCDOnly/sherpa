#!/usr/bin/env bash
#* <?dont_edit?>
#
#* <?filename?>
#
#* <?copyright?>
#
#* Description:
#*   This is the management script for the sherpa mini-package-manager.
#*   It's automatically downloaded via the `sherpa-loader.sh` script in the `sherpa` QPKG no-more than once-per-hour.
#
#* <?project?>
#
#* <?tested?>
#
#* <?license?>
#
# Project variable and function naming style-guide:
#			  functions: 'CamelCase'
#  background functions: '_CamelCaseWithLeadingAndTrailingUnderscores_'
#  utility interceptors: (same as original)
#			  variables: 'lowercase_with_inline_underscores'
# flag "object" methods: 'Capitalised.CamelCase.With.Inline.Periods.And.Colon.Before:Method'
# list "object" methods: 'Capitalised-CamelCase-With-Inline-Hyphens-And-Colon-Before:Method'
#   "object" properties: '_lowercase_with_leading_and_inline_and_trailing_underscores_' (these should be managed ONLY by the object's methods)
#			  constants: 'UPPERCASE_WITH_INLINE_UNDERSCORES' (also set as readonly)
#				indents: 1 x tab
#
# Notes:
#   If on-screen line-spacing is required, this should only be done by the next function to print output.
#   Display functions should never finish by putting an empty line on-screen for spacing.

set -o nounset -o pipefail
shopt -s extglob
readonly ARGS_RAW=$*
readonly SCRIPT_STARTSECONDS=$(/bin/date +%s)

Init()
	{

	OS.IsOk || return
	User.IsOk || return
	Consts:Load
	Vars:Load
	UpdateColourisation
	CMDs:Load
	CMDs.IsOk || return
	Traps:Set
	Keystrokes:Hide
	Cursor:Hide
	Env:Load || return
	LockFile:Claim || return
	Paths:Create || return
	PrepareArgs
	ParseManagementArgs || return
	ParseHelpArgs || return
	ArchivePriorSessLogs
	Debug.Log:Init
	ParseShowArgs || return
	ParseListArgs || return
	ParseActionArgs || return
	Title:Show
	ArgSuggestions:Show
	QPKGs.Conflicts:Check || return
	QPKGs.Warnings:Check
	Debug.Log:Env
	Tasks:Check
	Env:Check
	QPKGs:AssignToActions

	return 0

	}

Results:Show()
	{

	Func:Init

	display_last_action_datetime=false

	if [[ $generate_show_report = true ]]; then
		if [[ $useropt_show_log_last = true ]]; then
			LockFile:Release
			Log.Last:View
		elif [[ $useropt_show_log_tail = true ]]; then
			LockFile:Release
			Log.Tail:View
		elif [[ $useropt_show_backups = true ]]; then
			Report.Backups:Show
		elif [[ $useropt_show_versions = true ]]; then
			Report.Versions:Show
		elif [[ $useropt_show_dependencies = true ]]; then
			Report.Dependencies:Show
		elif [[ $useropt_show_packages = true ]]; then
			Report.Packages:Show
		elif [[ $useropt_show_repos = true ]]; then
			Report.Repos:Show
		elif [[ $useropt_show_status = true ]]; then
			Report.Statuses:Show
			show_package_actions_ok=false
			show_package_actions_skipped=false
			show_package_actions_failed=false
		fi
	fi

	if [[ $generate_list_report = true ]]; then
		if [[ ${packages_loaded:=false} = true ]]; then
			if QPKGs.AClist.GRdependent.IsSet; then
				QPKGs.GRdependent:Show
			elif QPKGs.AClist.GRindependent.IsSet; then
				QPKGs.GRindependent:Show
			elif QPKGs.AClist.ISactive.IsSet; then
				QPKGs.ISactive:Show
			elif QPKGs.AClist.ISNTactive.IsSet; then
				QPKGs.ISNTactive:Show
			elif QPKGs.AClist.ISbackedup.IsSet; then
				QPKGs.ISbackedup:Show
			elif QPKGs.AClist.ISNTbackedup.IsSet; then
				QPKGs.ISNTbackedup:Show
			elif QPKGs.AClist.ISenabled.IsSet; then
				QPKGs.ISenabled:Show
			elif QPKGs.AClist.ISNTenabled.IsSet; then
				QPKGs.ISNTenabled:Show
			elif QPKGs.AClist.ISinstallable.IsSet; then
				QPKGs.ISinstallable:Show
			elif QPKGs.AClist.ISNTinstallable.IsSet; then
				QPKGs.ISNTinstallable:Show
			elif QPKGs.AClist.ISinstalled.IsSet; then
				QPKGs.ISinstalled:Show
			elif QPKGs.AClist.ISNTinstalled.IsSet; then
				QPKGs.ISNTinstalled:Show
			elif QPKGs.AClist.ISmissing.IsSet; then
				QPKGs.ISmissing:Show
			elif QPKGs.AClist.ISNTmissing.IsSet; then
				QPKGs.ISNTmissing:Show
			elif QPKGs.AClist.ISupgradable.IsSet; then
				QPKGs.ISupgradable:Show
			elif QPKGs.AClist.ISNTupgradable.IsSet; then
				QPKGs.ISNTupgradable:Show
			fi
		fi
	fi

	if [[ $useropt_paste_log_last = true ]]; then
		Log.Last:Paste
	elif [[ $useropt_paste_log_tail = true ]]; then
		Log.Tail:Paste
	fi

	if [[ $useropt_help_basic = true ]]; then
		Help.Basic:Show
		Help.Basic.Examples:Show
	fi

	if [[ $generate_help_report = true ]]; then
		if [[ $useropt_help_tips = true ]]; then
			Help.Tips:Show
		elif [[ $useropt_help_abbreviations = true ]]; then
			Help.Abbreviations:Show
		elif [[ $useropt_help_actions = true ]]; then
			Help.Actions:Show
		elif [[ $useropt_help_actions_all = true ]]; then
			Help.ActionsAll:Show
		elif [[ $useropt_help_lists = true ]]; then
			Help.Lists:Show
		elif [[ $useropt_help_options = true ]]; then
			Help.Options:Show
		elif [[ $useropt_help_packages = true ]]; then
			Help.Packages:Show
		elif [[ $useropt_help_show = true ]]; then
			Help.Show:Show
		elif [[ $useropt_help_problems = true ]]; then
			Help.Problems:Show
		elif [[ $useropt_help_upgrades = true ]]; then
			Help.Upgrades:Show
		elif [[ $useropt_help_groups = true ]]; then
			Help.Groups:Show
		fi
	fi

	if [[ $useropt_show_results = true ]]; then
		display_last_action_datetime=true
		show_package_actions_failed=true
		show_package_actions_ok=true
		show_package_actions_skipped=true
	fi

	if [[ $generate_action_report = true || $generate_show_report = true ]]; then
		[[ $show_package_actions_ok = true ]] && Report.Results:Show ok
		[[ $show_package_actions_skipped = true ]] && Report.Results:Show skipped
		[[ $show_package_actions_failed = true ]] && Report.Results:Show failed
		[[ $show_zero_qpkgs = true ]] && ShowZeroQpkgs
		Display
	fi

	[[ $show_backuploc = true ]] && Help.BackupLocation:Show
	[[ $show_suggest_raise_issue = true ]] && Help.Issue:Show

	DebugInfoMinSepr
	DebugScript finished "$(/bin/date)"
	DebugScript 'elapsed time' "$(FormatSecsToHoursMinutesSecs "$(($(/bin/date +%s)-SCRIPT_STARTSECONDS))")"
	DebugInfoMajSepr

	Func:Exit

	[[ $archive_debug_afterward = true ]] && ArchiveActiveSessLog
	ResetActiveSessLog

	}

Debug.Log:Init()
	{

	DebugInfoMajSepr
	DebugScript started "$(/bin/date -d @"$SCRIPT_STARTSECONDS" | tr -s ' ')"
	DebugScript PID "$$"
	DebugInfoMinSepr
	DebugInfo 'Markers: (**) detected, (II) information, (WW) warning, (EE) error, (LL) log file, (--) processing,'
	DebugInfo '(==) done, (>>) f entry, (<<) f exit, (vv) variable name & value, ($1) positional argument value'
	DebugInfoMinSepr
	DebugVar THIS_PACKAGE_VER
	DebugVar THIS_SCRIPT_VER
	DebugVar LOADER_SCRIPT_VER

	}

Consts:Load()
	{

	# QPKG actions.
	readonly QPKG_DISABLE_TIMEOUT_SECONDS=10
	readonly QPKG_ENABLE_TIMEOUT_SECONDS=10
	readonly QPKG_RESTART_TIMEOUT_SECONDS=1800		# 30 minutes
	readonly QPKG_START_TIMEOUT_SECONDS=1500		# 25 minutes
	readonly QPKG_STATUS_CHECK_TIMEOUT_SECONDS=15
	readonly QPKG_STOP_TIMEOUT_SECONDS=300			# 5 minutes

	# Report formatting.
	readonly ACTION_RESULT_INDENT=6
	readonly COLUMN_SPACING=2
	readonly FILE_BYTES_COL_WIDTH=16
	readonly FILE_CHANGE_DATE_COL_WIDTH=60
	readonly HELP_DESC_INDENT=3
	readonly HELP_SYNTAX_INDENT=6

	readonly PACKAGE_ABBS_COL_WIDTH=84
	readonly PACKAGE_APP_VER_COL_WIDTH=16
	readonly PACKAGE_ARCH_COL_WIDTH=15
	readonly PACKAGE_AUTHOR_COL_WIDTH=40
	readonly PACKAGE_DEPENDENCIES_COL_WIDTH=29
	readonly PACKAGE_DESCRIPTION_COL_WIDTH=10
	readonly PACKAGE_ENABLED_COL_WIDTH=12
	readonly PACKAGE_INSTALL_DATE_COL_WIDTH=18
	readonly PACKAGE_INSTALLED_COL_WIDTH=14
	readonly PACKAGE_MAX_OS_COL_WIDTH=11
	readonly PACKAGE_MIN_OS_COL_WIDTH=11
	readonly PACKAGE_MIN_RAM_COL_WIDTH=16
	readonly PACKAGE_NAME_COL_WIDTH=21
		readonly FILE_NAME_COL_WIDTH=$((PACKAGE_NAME_COL_WIDTH+14))
	readonly PACKAGE_PATH_COL_WIDTH=48
	readonly PACKAGE_REPO_COL_WIDTH=40
	readonly PACKAGE_STATUS_COL_WIDTH=23
	readonly PACKAGE_VER_COL_WIDTH=17

	# For reports and onscreen display.
	readonly CHARS_DROPEND='└─ '
	readonly CHARS_ELLIPSIS='...'
	readonly CHARS_NOTE='* '
	readonly CHARS_REGULAR_PROMPT='$ '
		readonly CHARS_SUDO_PROMPT="${CHARS_REGULAR_PROMPT}sudo "
	readonly CHARS_RESULTS='= '
	readonly CHAR_SPACER=' '
		readonly CHARS_ALERT="${CHAR_SPACER}! "
		readonly CHARS_ATTENTION="${CHAR_SPACER}* "
		readonly CHARS_BLANK="${CHAR_SPACER}  "
		readonly CHARS_NORMAL="${CHAR_SPACER}- "
	readonly CHARS_BULLET='• '
	readonly CHARS_SUPER_PROMPT='# '

	readonly DEBUG_LOG_DATAWIDTH=101
	readonly DEBUG_LOG_FIRST_COL_WIDTH=9
	readonly DEBUG_LOG_SECOND_COL_WIDTH=22
	readonly DEBUG_LOG_THIRD_COL_WIDTH=$((DEBUG_LOG_DATAWIDTH-DEBUG_LOG_FIRST_COL_WIDTH-DEBUG_LOG_SECOND_COL_WIDTH-4))

	if OS.IsSupportSudo; then
		if [[ $(GetSudoUID) = undefined ]]; then
			readonly HELP_SYNTAX_PREFIX=$CHARS_SUPER_PROMPT
			readonly HELP_SYNTAX_SUDO_PREFIX=$CHARS_SUPER_PROMPT
		else
			readonly HELP_SYNTAX_PREFIX=$CHARS_REGULAR_PROMPT
			readonly HELP_SYNTAX_SUDO_PREFIX=$CHARS_SUDO_PROMPT
		fi
	else
		readonly HELP_SYNTAX_PREFIX=$CHARS_SUPER_PROMPT
		readonly HELP_SYNTAX_SUDO_PREFIX=$CHARS_SUPER_PROMPT
	fi

	readonly FILE_CHANGE_THRESHOLD_MINUTES=60
	readonly LOG_TAIL_LINES=5000

	}

Vars:Load()
	{

	# Default flags and values.
	action_msg_pipe_fd=none
	archive_debug_afterward=false
	backup_stdin_fd=none
	branch_default=stable
	colourful_default=true
	fork_pid=''
	generate_action_report=false
	generate_help_report=false
	generate_list_report=false
	generate_show_report=false
	get_qpkg_active_status=false
	get_qpkg_states=false
	ipks_downgrade=false
	ipks_install=false
	ipks_upgrade=false
	pips_install=false
	proc_counts_path=''
	qpkg_timeouts_increased=false
	run_package_actions=false
	show_backuploc=false
	show_package_actions_failed=false
	show_package_actions_ok=false
	show_package_actions_skipped=false
	show_suggest_raise_issue=false
	show_title=true
	show_zero_qpkgs=false
	switch_colour=false
	switch_branch=false
	switch_terse=false
	terse_default=true
	title_shown=false
	user_branch_value=''
	user_colourful_value=''
	user_terse_value=''

	# User-selectable options.
	useropt_branch=$(LoadSetting Git_Branch "$branch_default")
	useropt_check=false
	useropt_colourful=$(LoadSetting Colourful "$colourful_default")
	useropt_debug=false
	useropt_help_abbreviations=false
	useropt_help_actions=false
	useropt_help_actions_all=false
	useropt_help_basic=false
	useropt_help_groups=false
	useropt_help_lists=false
	useropt_help_options=false
	useropt_help_packages=false
	useropt_help_problems=false
	useropt_help_show=false
	useropt_help_tips=false
	useropt_help_upgrades=false
	useropt_paste_log_last=false
	useropt_paste_log_tail=false
	useropt_show_backups=false
	useropt_show_dependencies=false
	useropt_show_log_last=false
	useropt_show_log_tail=false
	useropt_show_packages=false
	useropt_show_repos=false
	useropt_show_results=false
	useropt_show_status=false
	useropt_show_versions=false
	useropt_terse=$(LoadSetting Terse "$terse_default")
	useropt_verbose=false

	}

CMDs:Load()
	{

	# Cherry-pick Entware binaries.
	readonly GNU_FIND_CMD=/opt/bin/find
	readonly GNU_GREP_CMD=/opt/bin/grep
	readonly GNU_LESS_CMD=/opt/bin/less
	readonly GNU_SED_CMD=/opt/bin/sed
	readonly GNU_SLEEP_CMD=/opt/bin/sleep
	readonly GNU_SORT_CMD=/opt/bin/sort
	readonly GNU_STTY_CMD=/opt/bin/stty
	readonly GNU_TIMEOUT_CMD=/opt/bin/timeout
	readonly OPKG_CMD=/opt/bin/opkg
	readonly PERL_CMD=/opt/bin/perl
	readonly PYTHON_CMD=/opt/bin/python
	readonly PYTHON3_CMD=/opt/bin/python3
		readonly PIP_CMD="$PYTHON3_CMD -m pip"

	# Cherry-pick QTS binaries.
	readonly AWK_CMD=/bin/awk
	readonly BASENAME_CMD=/usr/bin/basename
	readonly CAT_CMD=/bin/cat
	CURL_CMD=/sbin/curl			# Set as readonly later when secure download ability has been checked.
	# Don't assign a const for `/bin/date` as it's already been called before arriving here.
	readonly DF_CMD=/bin/df
	readonly DIRNAME_CMD=/usr/bin/dirname
	readonly DU_CMD=/usr/bin/du
	readonly GREP_CMD=/bin/grep
	readonly HEAD_CMD=/usr/bin/head
	readonly LESS_CMD=/bin/less
	readonly MD5SUM_CMD=/bin/md5sum
	readonly MKNOD_CMD=/bin/mknod
	readonly MKTEMP_CMD=/bin/mktemp
	readonly MORE_CMD=/bin/more
	readonly PS_CMD=/bin/ps
	readonly READLINK_CMD=/usr/bin/readlink
	readonly SCREEN_CMD=/usr/sbin/screen
	readonly SED_CMD=/bin/sed
	readonly SH_CMD=/bin/sh
	readonly SLEEP_CMD=/bin/sleep
	readonly SORT_CMD=/usr/bin/sort
	readonly TAIL_CMD=/usr/bin/tail
	readonly TAR_CMD=/bin/tar
	readonly TEE_CMD=/usr/bin/tee
	readonly TOUCH_CMD=/bin/touch
	readonly UNAME_CMD=/bin/uname
	readonly UNIQ_CMD=/bin/uniq
	readonly UNZIP_CMD=/usr/bin/unzip
	readonly UPTIME_CMD=/usr/bin/uptime
	readonly WC_CMD=/usr/bin/wc

	}

CMDs.IsOk()
	{

	# Confirm required binaries are present.

	IsSysFileExist $AWK_CMD || return
	IsSysFileExist $BASENAME_CMD || return
	IsSysFileExist $CAT_CMD || return
	# Don't perform a check for `/bin/date` as it's already been called before arriving here.
	IsSysFileExist $CURL_CMD || return
	IsSysFileExist $DF_CMD || return
	IsSysFileExist $DIRNAME_CMD || return
	IsSysFileExist $DU_CMD || return
	IsSysFileExist $GREP_CMD || return
	IsSysFileExist $HEAD_CMD || return
	# Don't perform a check for `/bin/less` because it's not always there.
	IsSysFileExist $MD5SUM_CMD || return
	IsSysFileExist $MKNOD_CMD || return
	IsSysFileExist $MKTEMP_CMD || return
	# Don't check for `/bin/more` because it's a very low-priority utility (non-essential).
	IsSysFileExist $PS_CMD || return
	IsSysFileExist $READLINK_CMD || return
	IsSysFileExist $SCREEN_CMD || return
	IsSysFileExist $SED_CMD || return
	IsSysFileExist $SH_CMD || return
	IsSysFileExist $TAIL_CMD || return
	IsSysFileExist $TAR_CMD || return
	IsSysFileExist $TEE_CMD || return
	IsSysFileExist $TOUCH_CMD || return
	IsSysFileExist $UNAME_CMD || return
	IsSysFileExist $UNIQ_CMD || return
	IsSysFileExist $UNZIP_CMD || return
	IsSysFileExist $UPTIME_CMD || return
	IsSysFileExist $WC_CMD || return

	if [[ ! -e $GNU_SLEEP_CMD ]]; then
		IsSysFileExist $SLEEP_CMD || return
	fi

	[[ ! -e $SORT_CMD ]] && ln -s /bin/busybox "$SORT_CMD"		# KLUDGE: `/usr/bin/sort` randomly disappears from QTS.

	# Test if this QTS `sleep` can handle decimal seconds. Early QTS BusyBox versions cannot.
	readonly DECIMAL_SLEEP_SECONDS_SUPPORTED=$($SLEEP_CMD .01 &>/dev/null && printf true || printf false)

	LocateSQLiteBinary

	return 0

	}

LocateSQLiteBinary()
	{

	# Prefer Entware-installed `sqlite3`.

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled Entware; then
		SQLITE_CMD=/opt/bin/sqlite3
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	# If that can't be found, then try several other locations.

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled HybridBackup; then			# `Hybrid Backup Sync`
		SQLITE_CMD=$(QPKG.GetInstallationPath HybridBackup)/CloudConnector3/bin/sqlite3
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled CacheMount; then			# `HybridMount`
		SQLITE_CMD=$(QPKG.GetInstallationPath CacheMount)/bin/sqlite3
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled container-station; then		# `Container Station`
		SQLITE_CMD=$(QPKG.GetInstallationPath container-station)/usr/bin/sqlite3
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled qmiixagent; then			# `Qmiix Agent`
		SQLITE_CMD=$(QPKG.GetInstallationPath qmiixagent)/bin/sqlite3
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled img2pdf; then				# `Image2PDF`
		SQLITE_CMD="LD_LIBRARY_PATH=$(QPKG.GetInstallationPath img2pdf)/lib $(QPKG.GetInstallationPath img2pdf)/bin/sqlite3"
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled Qsirch; then				# `Qsirch`
		SQLITE_CMD="LD_LIBRARY_PATH=$(QPKG.GetInstallationPath Qsirch)/lib $(QPKG.GetInstallationPath Qsirch)/bin/sqlite3"
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	if [[ -z ${SQLITE_CMD:-} ]] && QPKG.IsInstalled OCR_Converter; then			# `OCR Converter`
		SQLITE_CMD="LD_LIBRARY_PATH=$(QPKG.GetInstallationPath OCR_Converter)/lib $(QPKG.GetInstallationPath OCR_Converter)/bin/sqlite3"
		[[ ! -e $SQLITE_CMD ]] && SQLITE_CMD=''
	fi

	[[ -z ${SQLITE_CMD:-} ]] && SQLITE_CMD=/opt/bin/sqlite3						# last-resort, hope Entware will be installed this session.

	readonly SQLITE_CMD

	}

Env:Load()
	{

	ShowAsProc env

	readonly CERT_DB_PATHFILE=/etc/config/nas_sign_qpkg.db
	readonly CPU_CORES=$(GetCPUCores)
		readonly CONCURRENCY=$CPU_CORES				# Maximum concurrent package actions to run. Should probably make this account for CPU speed too.
	readonly ENTWARE_VER=$(GetEntwareType)
	readonly KERNEL_PAGE_SIZE=$(GetKernelPageSize)
	readonly NAS_ARCH=$(GetArch)
	readonly NAS_FIRMWARE_BUILD=$(GetFirmwareBuild)
	readonly NAS_FIRMWARE_DATE=$(GetFirmwareDate)
	readonly NAS_FIRMWARE_VER=$(GetFirmwareVer)
	readonly NAS_PLATFORM=$(GetPlatform)
	readonly NAS_QPKG_ARCH=$(GetQpkgArch)
	readonly NAS_RAM_KB=$(GetInstalledRAM)
	readonly NAS_UPSTATE=$(GetUpState)

	OS.IsSupportSecureDownload || CURL_CMD+=' --insecure'
	readonly CURL_CMD

	args=()						# command-line argument array.
	args_incomplete=()
	useropt_branch=$(/sbin/getcfg sherpa Git_Branch -d stable -f /etc/config/qpkg.conf)
		readonly OBJECTS_ARCHIVE_URL='<?cdn_sherpa_base_url?>'/$useropt_branch/objects.tar.gz
		readonly PACKAGES_ARCHIVE_URL='<?cdn_sherpa_base_url?>'/$useropt_branch/packages.tar.gz
	readonly QPKG_BU_PATH=$(GetDefVol)/.qpkg_config_backup
	readonly THIS_PACKAGE_PATH=$(QPKG.GetInstallationPath)
		if [[ -z $THIS_PACKAGE_PATH || $THIS_PACKAGE_PATH = undefined || ! -d $THIS_PACKAGE_PATH ]]; then
			ShowAsError "$(ShowAsTitleName) installation path not found. Please reinstall the $(ShowAsTitleName) QPKG"

			return 1
		fi

		readonly CACHE_PATH=$THIS_PACKAGE_PATH/cache
			readonly ACTION_TIMES_PATH=$CACHE_PATH/action.times
			readonly DISPLAY_INHIBIT_PATHFILE=$CACHE_PATH/display.inhibit
			readonly IPK_CACHE_PATH=$CACHE_PATH/IPKs
			readonly IPK_DL_PATH=$CACHE_PATH/IPKs.downloads
			readonly IPK_DOWNGRADE_DL_PATH=$CACHE_PATH/IPKs.downgrade
			readonly PIP_CACHE_PATH=$CACHE_PATH/PIPs
			readonly OBJECTS_ARCHIVE_PATHFILE=$CACHE_PATH/objects.tar.gz
			readonly OBJECTS_PATHFILE=$CACHE_PATH/objects
			readonly PACKAGES_ARCHIVE_PATHFILE=$CACHE_PATH/packages.tar.gz
			readonly PACKAGES_PATHFILE=$CACHE_PATH/packages
			readonly PREV_IPK_LIST=$CACHE_PATH/ipk.list.save
			readonly PREV_PIP_LIST=$CACHE_PATH/pip.list.save
			readonly QPKG_DL_PATH=$CACHE_PATH/QPKGs.downloads
		readonly LOGS_PATH=$THIS_PACKAGE_PATH/logs
			readonly RAMDISKS_FREESPACE_PATHFILE=$LOGS_PATH/ramdisks.freespace
			readonly SCREEN_SESSIONS_PATHFILE=$LOGS_PATH/screen.sessions
			readonly SESS_ACTION_RESULTS_PATHFILE=$LOGS_PATH/session.action.results.log
			readonly SESS_ARCHIVE_PATHFILE=$LOGS_PATH/session.archive.log
			readonly SESS_LAST_PATHFILE=$LOGS_PATH/session.last.log
			readonly SESS_TAIL_PATHFILE=$LOGS_PATH/session.tail.log
		sess_active_pathfile=$THIS_PACKAGE_PATH/session.$$.active.log

	# Ephemeral
	readonly ACTION_FORKS_COUNT=/var/run/sherpa/actions/forks
	readonly ACTION_LOGS_PATH=/var/log/sherpa/actions/logs
	readonly QPKG_STATES_PATH=/var/run/sherpa/packages/states
		readonly ACTION_ABORT_PATHFILE=$QPKG_STATES_PATH/abort.action
		readonly ACTION_MSG_PIPE=$QPKG_STATES_PATH/action.messages.pipe
	readonly REPORTS_PATH=/var/log/sherpa/reports
			readonly REPORT_OUTPUT_PATHFILE=$REPORTS_PATH/report.ansi
	readonly RUN_LOGS_PATH=/var/run/sherpa/run.logs

	readonly THIS_PACKAGE_VER=$(QPKG.Local.GetVer)
	readonly THIS_SCRIPT_VER='<?build_date?>'-$useropt_branch

	# Entware
	readonly EXTERNAL_PACKAGES_ARCHIVE_PATHFILE=/opt/var/opkg-lists/entware
	readonly EXTERNAL_PACKAGES_PATHFILE=$CACHE_PATH/Packages

	# KLUDGE: `/dev/fd` isn't always created by QTS.
	ln -fns /proc/self/fd /dev/fd

	# KLUDGE: just in-case `python` has disappeared again ... ¯\_(ツ)_/¯
	[[ -e $PYTHON3_CMD && ! -L $PYTHON_CMD ]] && ln -s "$PYTHON3_CMD" "$PYTHON_CMD"

	rm -f "$REPORT_OUTPUT_PATHFILE" "$RAMDISKS_FREESPACE_PATHFILE" "$DISPLAY_INHIBIT_PATHFILE"

	if [[ -e $GNU_STTY_CMD && -t 0 ]]; then
		local terminal_dimensions=$($GNU_STTY_CMD size)
		readonly SESS_ROWS=${terminal_dimensions% *}
		readonly SESS_COLS=${terminal_dimensions#* }
	else
		readonly SESS_ROWS=40
		readonly SESS_COLS=156
	fi

	}

Lists:Load()
	{

	[[ ${lists_loaded:=false} = false ]] || return 0

	# These are used internally by sherpa.
	# ordered
	PACKAGE_TIERS=(independent auxiliary dependent)

	# sorted
	QPKG_IS_STATES=(active backedup downloaded enabled installable installed missing signed upgradable)
	QPKG_ISNT_STATES=(active backedup downloaded enabled installable installed missing signed upgradable)
	QPKG_IS_GROUPS=(all canbackup canclean canrestarttoupdate dependent hasdependents independent)
	QPKG_ISNT_GROUPS=(canclean)
	QPKG_STATES_TRANSIENT=(restarting slow starting stopping unknown)
	QPKG_SERVICE_RESULTS=(failed ok)

	# ordered
	QPKG_ACTIONS=(status list rebuild reassign download backup deactivate disable uninstall upgrade reinstall install enableau disableau sign restore clean enable activate reactivate)
	IPK_ACTIONS=(downgrade download uninstall upgrade install)
	PIP_ACTIONS=(uninstall upgrade install)

	# These actions may be specified by the user.
	# sorted
	USER_QPKG_ACTIONS=(activate backup clean deactivate disable disableau enable enableau install list reactivate reassign rebuild reinstall restore sign status uninstall upgrade)

	# KLUDGE: for some reason, setting `readonly` while populating arrays causes their scope to become local, so need to set as `readonly` afterward to ensure global scope. GNU bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)
	readonly PACKAGE_TIERS

	readonly QPKG_IS_STATES
	readonly QPKG_ISNT_STATES
	readonly QPKG_IS_GROUPS
	readonly QPKG_ISNT_GROUPS
	readonly QPKG_STATES_TRANSIENT
	readonly QPKG_SERVICE_RESULTS

	readonly IPK_STATES

	readonly QPKG_ACTIONS
	readonly IPK_ACTIONS
	readonly PIP_ACTIONS

	readonly USER_QPKG_ACTIONS

	local action=''

	for action in "${QPKG_ACTIONS[@]}" check debug downgrade update; do
		readonly "$(Uppercase "$action")"_LOG_FILE=$action.log
	done

	lists_loaded=true

	}

Paths:Create()
	{

	ClearPath "$CACHE_PATH" "$IPK_CACHE_PATH"
	ClearPath "$CACHE_PATH" "$IPK_DL_PATH"
	ClearPath "$CACHE_PATH" "$PIP_CACHE_PATH"

	MakePath "$ACTION_TIMES_PATH" 'action times' || return
	MakePath "$CACHE_PATH" cache || return
	MakePath "$IPK_CACHE_PATH" 'IPK cache' || return
	MakePath "$IPK_DL_PATH" 'IPK download' || return
	MakePath "$IPK_DOWNGRADE_DL_PATH" 'IPK downgrade' || return
	MakePath "$LOGS_PATH" logs || return
	MakePath "$PIP_CACHE_PATH" 'PIP cache' || return
	MakePath "$REPORTS_PATH" reports || return
	MakePath "$QPKG_BU_PATH" 'QPKG backup' || return
	MakePath "$QPKG_DL_PATH" 'QPKG download' || return

	}

Debug.Log:Env()
	{

	[[ $run_package_actions = true ]] || return 0
	[[ $useropt_debug = true ]] || return 0

	Func:Init

	ShowAsProc 'log env'

	DebugInfoMinSepr
	DebugHardware ok model "$(get_display_name)"
	DebugHardware ok CPU "$(GetCPUInfo)"
	DebugHardware ok 'CPU cores' "$CPU_CORES"
	DebugHardware ok 'CPU architecture' "$NAS_ARCH"
	DebugHardware ok RAM "$(FormatAsThous "$NAS_RAM_KB")kiB"
	DebugFirmware ok OS "$(GetQnapOS)"

	if OS.IsSupported; then
		DebugFirmware ok version "$NAS_FIRMWARE_VER.$NAS_FIRMWARE_BUILD"
	else
		DebugFirmware warning version "$NAS_FIRMWARE_VER"
	fi

	if OS.IsCompatibleWithSigned; then
		DebugFirmware ok 'build date' "$NAS_FIRMWARE_DATE"
	else
		DebugFirmware warning 'build date' "$NAS_FIRMWARE_DATE"
	fi

	DebugFirmware ok 'kernel version' "$(GetKernelVersion)"

	if OS.IsStdKernelPageSize; then
		DebugFirmware ok 'kernel page size' "$KERNEL_PAGE_SIZE"
	else
		DebugFirmware warning 'kernel page size' "$KERNEL_PAGE_SIZE"
	fi

	DebugFirmware ok platform "$NAS_PLATFORM"

	case $NAS_UPSTATE in
		starting-up|shutting-down)
			DebugFirmware warning 'OS state' "$NAS_UPSTATE"
			;;
		*)
			DebugFirmware ok 'OS state' "$NAS_UPSTATE"
	esac

	DebugFirmware ok 'OS uptime' "$(GetUptime)"

	if OS.IsLoadAverageElevated; then
		DebugFirmware warning 'system load' "$(GetSysLoadAverages)"
	else
		DebugFirmware ok 'system load' "$(GetSysLoadAverages)"
	fi

	if OS.IsSupportSudo; then
		DebugUserspace ok '$SUDO_UID' "$(GetSudoUID)"
	else
		DebugUserspace ok '$SUDO_UID' 'N/A'
	fi

	DebugUserspace ok '$EUID' "$EUID"
	DebugUserspace ok 'time in shell' "$(GetTimeInShell)"
	DebugUserspace ok '$BASH_VERSION' "$BASH_VERSION"
	DebugUserspace ok 'default volume' "$(GetDefVol)"
	DebugUserspace ok '/opt' "$($READLINK_CMD /opt 2>/dev/null || printf 'not present')"

	local public_share=$(/sbin/getcfg SHARE_DEF defPublic -d Qpublic -f /etc/config/def_share.info)

	if [[ -L /share/$public_share ]]; then
		DebugUserspace ok "'$public_share' share" "/share/$public_share"
	else
		DebugUserspace warning "'$public_share' share" 'not present'
	fi

	if [[ ${#PATH} -le $DEBUG_LOG_THIRD_COL_WIDTH ]]; then
		DebugUserspace ok '$PATH' "$PATH"
	else
		DebugUserspace ok '$PATH (LHS-only)' "${PATH:0:$((DEBUG_LOG_THIRD_COL_WIDTH-${#CHARS_ELLIPSIS}))}${CHARS_ELLIPSIS}"
	fi

	DebugBinPathVerAndMinVer python "$(GetPythonVer)" "${MIN_PYTHON_VER:-undefined}"
	DebugBinPathVerAndMinVer python3 "$(GetPython3Ver)" "${MIN_PYTHON_VER:-undefined}"
	DebugBinPathVerAndMinVer perl "$(GetPerlVer)" "${MIN_PERL_VER:-undefined}"
	DebugScript 'git branch' "$useropt_branch"
	DebugScript 'logs path' "$LOGS_PATH"
	DebugScript 'action concurrency' "$CONCURRENCY"

	if OS.IsSupportSignedPackages; then
		if OS.IsAllowUnsignedPackages; then
			DebugQpkg detect 'allow unsigned' yes
		else
			DebugQpkg detect 'allow unsigned' no
		fi
	else
		DebugQpkg detect 'allow unsigned' 'N/A'
	fi

	DebugQpkg detect architecture "$NAS_QPKG_ARCH"
	DebugQpkg detect "$(ShowAsPackageName Entware) type" "$ENTWARE_VER"
	DebugQpkg detect "$(ShowAsPackageName Entware) install date" "$(QPKG.GetInstallDate Entware)"

	if QPKG.IsInstalled SortMyQPKGs; then
		DebugQpkg detect "$(ShowAsPackageName SortMyQPKGs)" installed
	else
		DebugQpkg warning "$(ShowAsPackageName SortMyQPKGs)" 'not installed'
	fi

	if OS.IsSupportQpkgTimeout; then
		if QPKG.IsInstalled IncreaseTimeouts; then
			if QPKGs.IsTimeoutsIncreased; then
				DebugQpkg detect "$(ShowAsPackageName IncreaseTimeouts)" active
			else
				DebugQpkg warning "$(ShowAsPackageName IncreaseTimeouts)" inactive
			fi
		else
			DebugQpkg warning "$(ShowAsPackageName IncreaseTimeouts)" 'not installed'
		fi
	else
		DebugQpkg detect "$(ShowAsPackageName IncreaseTimeouts)" 'N/A'
	fi

	DebugInfoMinSepr
	RunAndLog "$DF_CMD -h | $GREP_CMD '^Filesystem\|^none\|^tmpfs\|ram'" "$RAMDISKS_FREESPACE_PATHFILE"
	DebugInfoMinSepr
	RunAndLog "$SCREEN_CMD -ls" "$SCREEN_SESSIONS_PATHFILE" '' 1
	DebugInfoMinSepr

	Func:Exit

	}

Tasks:Check()
	{

	# Establish whether there's something to-do.

	if [[ $arg_problem = true || $useropt_help_basic = true ]]; then
		generate_action_report=false
		generate_help_report=false
		generate_list_report=false
		generate_show_report=false
		get_qpkg_active_status=false
		get_qpkg_states=false
		run_package_actions=false
	fi

	[[ $get_qpkg_states = true ]] || return 0

	Func:Init

	local action=''
	local build_states=false
	local group=''
	local state=''

	if [[ $useropt_check = true || $useropt_show_status = true ]]; then
		build_states=true
	elif [[ $useropt_show_dependencies = true || $useropt_show_packages = true || $useropt_show_repos = true ]]; then
		build_states=true
	elif [[ $useropt_help_actions = true || $useropt_help_actions_all = true || $useropt_help_groups = true || $useropt_help_lists = true || $useropt_help_options = true || $useropt_help_packages = true || $useropt_help_problems = true || $useropt_help_tips = true || $useropt_help_upgrades = true || $useropt_show_results = true ]]; then
		: # don't do anything
	else
		Packages:Load

		for action in "${USER_QPKG_ACTIONS[@]}"; do
			if QPKGs-AC${action}-to.IsAny; then
				build_states=true
				break
			fi

			for group in "${QPKG_IS_GROUPS[@]}"; do
				if QPKGs.AC${action}.GR${group}.IsSet; then
					build_states=true
					break 2
				fi
			done

			for group in "${QPKG_ISNT_GROUPS[@]}"; do
				if QPKGs.AC${action}.GRNT${group}.IsSet; then
					build_states=true
					break 2
				fi
			done

			for state in "${QPKG_IS_STATES[@]}"; do
				if QPKGs.AC${action}.IS${state}.IsSet; then
					build_states=true
					break 2
				fi
			done

			for state in "${QPKG_ISNT_STATES[@]}"; do
				if QPKGs.AC${action}.ISNT${state}.IsSet; then
					build_states=true
					break 2
				fi
			done
		done
	fi

	if [[ $build_states = true ]]; then
		QPKGs.States:Build
	else
		get_qpkg_states=false
		run_package_actions=false
	fi

	Func:Exit

	}

Env:Check()
	{

	# This function handles most of the high-level logic for package actions.
	# If a package isn't being processed by the correct action, odds-are it's due to a logic error in this function.

	[[ $run_package_actions = true ]] || return 0

	Func:Init

	ShowAsProc 'check env'

	local installed_ver=''
	local target_packages=''

	if QPKG.IsInstalled Entware; then
		if [[ $ENTWARE_VER != none ]]; then
			UpdateEntwarePackageList &			# Let's try launching this early.
		else
			DebugAsWarn "$(ShowAsPackageName Entware) appears to be installed but is inactive. Please consider starting the $(ShowAsPackageName Entware) QPKG."
		fi

		# Decide if specific IPKs and PIPs should be installed/upgraded.

		if [[ $useropt_check = true ]] || QPKGs-ACupgrade-to.Exist Entware; then
			ipks_install=true
			ipks_upgrade=true
			pips_install=true

			if [[ -e $PYTHON3_CMD ]]; then
				installed_ver=$(GetPython3Ver "$PYTHON3_CMD")

				if [[ ${installed_ver//./} -lt $MIN_PYTHON_VER ]]; then
					ShowAsNote "the $(TextBrightOrange Python) environment will be auto-upgraded"
					IPKs-ACuninstall-to:Add 'python*'
				fi
			fi

			if [[ -e $PERL_CMD ]]; then
				installed_ver=$(GetPerlVer "$PERL_CMD")

				if [[ ${installed_ver//./} -lt $MIN_PERL_VER ]]; then
					ShowAsNote "the $(TextBrightOrange Perl) environment will be auto-upgraded"
					IPKs-ACuninstall-to:Add 'perl*'
				fi
			fi
		fi

		# Decide if specific IPKs should be uninstalled/downgraded.

		if OS.IsNonStdKernelPageSize; then
			case $NAS_QPKG_ARCH in
				a41)
					target_packages='ar binutils libbfd libctf libopcodes objdump'

					# Assume first package version is same as remaining package versions.
					installed_version=$($OPKG_CMD list-installed | $GREP_CMD "^${target_packages%% *} *" | cut -d' ' -f3 | cut -d'-' -f1)

					if [[ ${installed_version//.} -gt 238 ]]; then
						ipks_downgrade=true
						ShowAsNote "IPKs will be downgraded to suit $KERNEL_PAGE_SIZE kernel page size"
						IPKs-ACdowngrade-to:Add "$target_packages"
					else
						IPKs-ACdowngrade-sk:Add "$target_packages"
					fi
			esac
		fi
	fi

	QPKGs.IsCanBackup:Build
	QPKGs.IsCanRestartToUpdate:Build
	QPKGs.IsCanClean:Build
	AllocPackGroupsToAcs
	AllocPackStatesToAcs

	if QPKGs-ISupgradable.Exist sherpa; then
		ShowAsNote "the $(TextBrightOrange sherpa) QPKG will be auto-upgraded"
		QPKGs-ACupgrade-to:Add sherpa
	fi

	wait 2>/dev/null			# Ensure Entware package updater completes before continuing.

	Func:Exit

	}

QPKGs:AssignToActions()
	{

	[[ $run_package_actions = true ]] || return 0

	Func:Init

	ShowAsProc 'QPKG assignment'

	local action=''
	local package=''
	local prospect=''

	# KLUDGE: ensure old installs of Entware are reinstalled.

	if QPKG.IsInstalled Entware; then
		local entware_install_date=$(QPKG.GetInstallDate Entware)

		if [[ $entware_install_date = undefined || ${entware_install_date//[!0-9]/} -le 20240224 ]]; then
			ShowAsNote "the $(TextBrightOrange Entware) QPKG will be auto-reinstalled (Entware packages were updated late February 2024)"
			QPKGs-ACreinstall-to:Add Entware
		fi
	fi

	# Meta-action pre-processing. Perform check for backup file here, to determine if QPKG should be downloaded and installed.

	if QPKGs-ACrebuild-to.IsAny; then
		for package in $(QPKGs-ACrebuild-to:Array); do
			if QPKGs-ISNTinstalled.Exist "$package" && QPKG.IsBackupExist "$package"; then
				QPKGs-ACinstall-to:Add "$package"
				QPKGs-ACrestore-to:Add "$package"
			fi
		done
	fi

	# Ensure independent packages are also installed when processing these specific actions.

	for action in reinstall install; do
		for package in $(QPKGs-AC${action}-to:Array); do
			for prospect in $(QPKG.GetDependencies "$package"); do
				QPKGs-ISNTinstalled.Exist "$prospect" && QPKGs-ACinstall-to:Add "$prospect"
			done
		done
	done

	# Install independents for installed dependents.

	for package in $(QPKGs-ISinstalled:Array); do
		if [[ $useropt_check = true ]] || QPKGs-ACactivate-to.Exist "$package"; then
			for prospect in $(QPKG.GetDependencies "$package"); do
				QPKGs-ISNTinstalled.Exist "$prospect" && QPKGs-ACinstall-to:Add "$prospect"
			done
		fi
	done

	# If an independent has been selected for `reinstall`/`reactivate`/`upgrade`, need to `deactivate` its dependents first, and `activate` them again later.

	for package in $(QPKGs-ACreinstall-to:Array) $(QPKGs-ACreactivate-to:Array) $(QPKGs-ACupgrade-to:Array); do
		if QPKGs-GRindependent.Exist "$package" && QPKGs-ISinstalled.Exist "$package"; then
			for prospect in $(QPKG.GetDependents "$package"); do
				if QPKGs-ISenabled.Exist "$prospect"; then
					QPKGs-ACdeactivate-to:Add "$prospect"
					! QPKGs-ACuninstall-to.Exist "$prospect" && ! QPKGs-ACinstall-to.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
				fi
			done
		fi
	done

	# If an independent has been selected for `deactivate`/`uninstall`, need to `deactivate` its dependents first.

	for package in $(QPKGs-ACdeactivate-to:Array) $(QPKGs-ACuninstall-to:Array); do
		if QPKGs-GRindependent.Exist "$package" && QPKGs-ISinstalled.Exist "$package"; then
			for prospect in $(QPKG.GetDependents "$package"); do
				QPKGs-ISinstalled.Exist "$prospect" && QPKGs-ACdeactivate-to:Add "$prospect"
			done
		fi
	done

	# If an independent has been selected for `uninstall`, then `install`, need to `deactivate` its dependents first, and `activate` them again later.

	for package in $(QPKGs-ACuninstall-to:Array); do
		if QPKGs-GRindependent.Exist "$package" && QPKGs-ISinstalled.Exist "$package"; then
			if QPKGs-ACinstall-to.Exist "$package"; then
				for prospect in $(QPKG.GetDependents "$package"); do
					if QPKGs-ISenabled.Exist "$prospect"; then
						QPKGs-ACdeactivate-to:Add "$prospect"
						! QPKGs-ACuninstall-to.Exist "$prospect" && ! QPKGs-ACinstall-to.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
					fi
				done
			fi
		fi
	done

	# Entware is a special-case: perform complete removal and fresh install to clear all installed IPKs.

	if QPKGs-ACreinstall-to.Exist Entware; then
		QPKGs-ACreinstall-to:Remove Entware
		QPKGs-ACuninstall-to:Add Entware
		QPKGs-ACinstall-to:Add Entware
	fi

	# If dependents have been selected for `reinstall`/`install`/`activate`/`reactivate`, need to `activate` their independent packages first.

	for action in reinstall install activate reactivate; do
		for package in $(QPKGs-AC${action}-to:Array); do
			for prospect in $(QPKG.GetDependencies "$package"); do
				QPKGs-ISinstalled.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
			done
		done
	done

	# Check for packages that must be enabled first, because `activate`/`reactivate` was requested.
	# I've disabled this. Make user `enable` target packages first. Let's see how this goes...

# 	for action in activate reactivate; do
# 		for package in $(QPKGs-AC${action}-to:Array); do
# 			QPKGs-ISinstalled.Exist "$package" && QPKGs-ISNTenabled.Exist "$package" && QPKGs-ACenable-to:Add "$package"
# 		done
# 	done

	# No-need to `deactivate`/`reactivate`/`disable` packages that are to be uninstalled.

	if QPKGs.ACuninstall.GRall.IsSet; then
		QPKGs-ACdeactivate-to:Init
		QPKGs-ACreactivate-to:Init
		QPKGs-ACdisable-to:Init
	else
		QPKGs-ACdeactivate-to:Remove "$(QPKGs-ACuninstall-to:Array)"
		QPKGs-ACreactivate-to:Remove "$(QPKGs-ACuninstall-to:Array)"
		QPKGs-ACdisable-to:Remove "$(QPKGs-ACuninstall-to:Array)"
	fi

	# No-need to `activate` packages that are to be reactivated.
	QPKGs-ACactivate-to:Remove "$(QPKGs-ACreactivate-to:Array)"

	# Build a list of original storage paths for packages to be uninstalled, then installed again later this session (a "complex reinstall").
	# This will ensure user-migrated packages end-up in the correct locations.
	QPKGs_were_installed_name=()
	QPKGs_were_installed_path=()

	if QPKGs-ACuninstall-to.IsAny; then
		for package in $(QPKGs-ACuninstall-to:Array); do
			if QPKGs-ISinstalled.Exist "$package" && QPKGs-ACinstall-to.Exist "$package"; then
				QPKGs_were_installed_name+=("$package")
				QPKGs_were_installed_path+=("$($DIRNAME_CMD "$(QPKG.GetInstallationPath "$package")")")
			fi
		done
	fi

	for package in sherpa Entware; do
		QPKGs-ACupgrade-to.Exist "$package" && QPKGs-ACreactivate-to:Add "$package"
	done

	# Build list of required installation QPKGs.

	QPKGs-ACdownload-to:Add "$(QPKGs-ACreinstall-to:Array) $(QPKGs-ACinstall-to:Array)"

	for package in $(QPKGs-ACupgrade-to:Array); do
		QPKGs-ISupgradable.Exist "$package" && QPKGs-ACdownload-to:Add "$package"		# Only download files for upgradable QPKGs
	done

	# Check all items.

	if [[ $useropt_check = true ]] && OS.IsSupportSignedPackages; then
		QPKGs-ACsign-to:Add "$(QPKGs-ISinstalled:Array)"

		for package in $(QPKGs-GRdependent:Array); do
			QPKGs-ISenabled.Exist "$package" && QPKGs-ACreactivate-to:Add "$package"
		done
	fi

	if QPKGs-ACsign-to.IsAny || QPKGs-ACinstall-to.IsAny; then
		QPKG.Signing:Load
	fi

	Func:Exit

	}

# QPKG action processing shall be conducted in this order:
#
#	1. status all
#	2. rebuild all				(meta-action: `download`, `install` & `restore` QPKG, but only if package has an existing backup file)
#	3. reassign all
#	4. download all
#	5. backup all
#
#	6. stop/deactivate dependents
#	7. disable dependents
#   8. uninstall dependents
#
#	9. stop/deactivate independents
#  10. disable independents
#  11. uninstall independents
#
#  12. upgrade independents
#  13. reinstall independents
#  14. install independents
#  15. enable-auto-update independents
#  16. disable-auto-update independents
#  17. "sign" independents
#  18. restore independents
#  19. clean independents
#  20. enable independents
#  21. restart/reactivate independents
#  22. start/activate independents
#
#  23. upgrade dependents
#  24. reinstall dependents
#  25. install dependents
#  26. enable-auto-update dependents
#  27. disable-auto-update dependents
#  28. "sign" dependents
#  29. restore dependents
#  30. clean dependents
#  31. enable dependents
#  32. restart/reactivate dependents
#  33. start/activate dependents

Actions:Proc()
	{

	# Run all actions on selected packages in all tiers.

	[[ $run_package_actions = true ]] || return

	Func:Init

	ShowAsProc 'package actions'

	local tier=''
	local action=''
	local state=''
	local -i tier_index=0

	rm -f "$SESS_ACTION_RESULTS_PATHFILE"

	# -> package preparation phase begins here <-

	Action:Proc status all QPKG status statused

	if [[ $useropt_show_status = false ]]; then
		ShowAsProc 'assign QPKGs by status'				# Update action lists based-on QPKG `status`.

		for action in "${USER_QPKG_ACTIONS[@]}"; do
			for state in "${QPKG_IS_STATES[@]}"; do
				QPKGs.AC${action}.IS${state}.IsSet && QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
			done

			for state in "${QPKG_ISNT_STATES[@]}"; do
				QPKGs.AC${action}.ISNT${state}.IsSet && QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
			done
		done
	fi

	Action:Proc rebuild all QPKG meta-rebuild meta-rebuilt
	Action:Proc reassign all QPKG reassign reassigned
	Action:Proc download all QPKG download downloaded
	Action:Proc backup all QPKG backup backed-up

	# -> package removal phase begins here <-

	for ((tier_index=${#PACKAGE_TIERS[@]}-1; tier_index>=0; tier_index--)); do	# Process tiers in-reverse
		tier=${PACKAGE_TIERS[$tier_index]}

		case $tier in
			?(in)dependent)
				Action:Proc deactivate $tier QPKG deactivate deactivated
				Action:Proc disable $tier QPKG disable disabled
				Action:Proc uninstall $tier QPKG uninstall uninstalled
				;;
			auxiliary)
				if QPKGs-ISenabled.Exist Entware; then
					ModPathToEntware
					PIPs:uninstall
					IPKs:uninstall
				fi
		esac
	done

	# -> package installation phase begins here <-

	for tier in "${PACKAGE_TIERS[@]}"; do
		case $tier in
			?(in)dependent)
				Action:Proc upgrade $tier QPKG upgrade upgraded
				Action:Proc reinstall $tier QPKG reinstall reinstalled
				Action:Proc install $tier QPKG install installed
				Action:Proc enableau $tier QPKG 'enable auto-update' 'enabled auto-update'
				Action:Proc disableau $tier QPKG 'disable auto-update' 'disabled auto-update'
				Action:Proc sign $tier QPKG '"sign"' '"signed"'
				Action:Proc restore $tier QPKG restore restored
				Action:Proc clean $tier QPKG clean cleaned
				Action:Proc enable $tier QPKG enable enabled
				Action:Proc reactivate $tier QPKG reactivate reactivated
				Action:Proc activate $tier QPKG activate activated
				;;
			auxiliary)
				for action in status install reinstall upgrade activate; do
					if (QPKGs-ACinstall-ok.Exist Entware) || QPKGs-AC${action}-to.IsAny && QPKGs-ISenabled.Exist Entware; then
						ipks_downgrade=true
						ipks_install=true
						ipks_upgrade=true
						pips_install=true
						break
					fi
				done

				if QPKGs-ISenabled.Exist Entware; then
					ModPathToEntware
					IPKs:upgrade
					IPKs:install
					IPKs:downgrade
					PIPs:upgrade
					PIPs:install
				fi
		esac
	done

	if [[ $useropt_debug = true ]]; then
		QPKGs.Actions:List
		IPKs.Actions:List
		PIPs.Actions:List
	fi

	if [[ $title_shown = true ]]; then
		if Error.IsNt; then
			ShowAsDone 'actions complete'
		else
			ShowAsFail 'actions complete with errors'
		fi
	fi

	Func:Exit

	}

Action:Proc()
	{

	# Run a single action on an entire tier of packages, asynchronously where possible.

	# Input:
	#   $1 = $TARGET_ACTION					e.g. `activate`, `reactivate` ...
	#   $2 = $TIER							e.g. `independent`, `dependent`, `auxiliary`, `all`
	#   $3 = $PACKAGE_TYPE					e.g. `QPKG`, `IPK`, `PIP`
	#   $4 = $ACTION_PRESENT_MSG			e.g. `activating` ...
	#   $5 = $ACTION_PAST_MSG				e.g. `activated` ...

	Func:Init

	local -r ACTION_PAST=${5:?${FUNCNAME[0]}'()': undefined action past}
	local -r ACTION_PRESENT_MSG=${4:?${FUNCNAME[0]}'()': undefined action present}
	local group=''
	local msg1_key=''
	local msg1_value=''
	local msg2_key=''
	local msg2_value=''
	local original_colourful=$useropt_colourful
	local package=''
	local -i package_index=0
	local -r PACKAGE_TYPE=${3:?${FUNCNAME[0]}'()': undefined package type}
	local state=''
	local -r TARGET_ACTION=${1:?${FUNCNAME[0]}'()': undefined action}
	local -a target_packages=()
	local -r TIER=${2:?${FUNCNAME[0]}'()': undefined tier}
	total_count=0

	DebugVar TARGET_ACTION
	DebugVar TIER
	DebugVar PACKAGE_TYPE

	case $PACKAGE_TYPE in
		QPKG)
			TARGET_OBJECT_NAME=AC${TARGET_ACTION}-to

			if [[ $TIER = all ]]; then  # Process all tiers.
				target_packages=($(${PACKAGE_TYPE}s-$TARGET_OBJECT_NAME:Array))
			else						# Process a single tier only.
				for package in $(${PACKAGE_TYPE}s-$TARGET_OBJECT_NAME:Array); do
					${PACKAGE_TYPE}s-GR${TIER}.Exist "$package" && target_packages+=("$package")
				done
			fi

			total_count=${#target_packages[@]}
			DebugVar total_count

			if [[ $total_count -eq 0 ]]; then
				DebugInfo 'nothing to process'

				Func:Exit; return
			fi

			if [[ $total_count -eq 1 ]]; then
				fork_progress_prefix="$ACTION_PRESENT_MSG $(TextBrightOrange "${target_packages[0]}")"
			else
				fork_progress_prefix="$ACTION_PRESENT_MSG $([[ $TIER != all ]] && echo "$TIER ")$(Uppercase "$PACKAGE_TYPE")$(Pluralise "$total_count")"
			fi

			AdjustMaxForks "$TARGET_ACTION"
			InitForkCounts
			OpenActionMsgPipe

			re=\\bEntware\\b		# bash 3.2 regex with word boundaries: https://stackoverflow.com/a/9793094

			if [[ $TARGET_ACTION = uninstall && ${target_packages[*]} =~ $re ]]; then
				Keystrokes:Show		# Enable this before removing Entware & GNU `stty`.
			fi

			_LaunchOneActionWithManyForks_ "_${PACKAGE_TYPE}:${TARGET_ACTION}_" "${target_packages[@]}" &
			fork_pid=$!

			# Read message pipe and process QPKGs and actions as-per requests contained within.
			while [[ ${#target_packages[@]} -gt 0 ]]; do
				ReadFromActionMsgPipe msg1_key msg1_value msg2_key msg2_value

				case $msg1_key in
					env)			# Change the state of the sherpa environment.
						eval "$msg1_value"	# Run this as executable.
						;;
					change)			# Change the state of a single QPKG in the parent shell.
						while true; do
							for state in "${QPKG_IS_STATES[@]}" "${QPKG_STATES_TRANSIENT[@]}"; do
								case $msg1_value in
									"IS${state}")
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Add "$msg2_value"
										break 2
								esac
							done

							for state in "${QPKG_ISNT_STATES[@]}" "${QPKG_STATES_TRANSIENT[@]}"; do
								case $msg1_value in
									"ISNT${state}")
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Add "$msg2_value"
										break 2
								esac
							done

							for group in "${QPKG_IS_GROUPS[@]}"; do
								case $msg1_value in
									"GR${group}")
										[[ $(type -t QPKGs-GRNT${group}:Init) = function ]] && QPKGs-GRNT${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-GR${group}:Init) = function ]] && QPKGs-GR${group}:Add "$msg2_value"
										break 2
								esac
							done

							for group in "${QPKG_ISNT_GROUPS[@]}"; do
								case $msg1_value in
									"GRNT${group}")
										[[ $(type -t QPKGs-GR${group}:Init) = function ]] && QPKGs-GR${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-GRNT${group}:Init) = function ]] && QPKGs-GRNT${group}:Add "$msg2_value"
										break 2
								esac
							done

							DebugAsWarn "unidentified change request in message queue: '$msg1_value'"
							break
						done
						;;
					status)			# Update the status of a single action fork in the parent shell.
						case $msg1_value in
							ok)		# Completed OK (wonderful!).
								[[ $TARGET_ACTION != status ]] && ((ok_count++))		# Don't need to count the result of `status` checks.
								;;
							so)		# Action was skipped, but this is normal (no-big-deal).
								((skip_ok_count++))
								;;
							sk)		# Action was skipped (and there's a good reason for it).
								((skip_count++))
								;;
							se)		# Action was skipped due to error prior to action being attempted (might be a big-deal).
								((skip_error_count++))
								;;
							sa)		# Action was skipped and must immediately abort (don't attempt this action again).
								((skip_abort_count++))
								$TOUCH_CMD "$ACTION_ABORT_PATHFILE"
								break
								;;
							er)		# Action failed (uh-oh).
								((fail_count++))
						esac

						case $msg1_value in
							ok|so|sk|se|sa|er)
								[[ $(type -t QPKGs-AC${TARGET_ACTION}-to:Init) = function ]] && QPKGs-AC${TARGET_ACTION}-to:Remove "$msg2_value"
								[[ $(type -t QPKGs-AC${TARGET_ACTION}-${msg1_value}:Init) = function ]] && QPKGs-AC${TARGET_ACTION}-${msg1_value}:Add "$msg2_value"

								# Also add to 'done' list.
								[[ $(type -t QPKGs-AC${TARGET_ACTION}-dn:Init) = function ]] && QPKGs-AC${TARGET_ACTION}-dn:Add "$msg2_value"
								;;
							ex)		# Action is about to exit.
								for package_index in "${!target_packages[@]}"; do
									if [[ ${target_packages[package_index]} = "$msg2_value" ]]; then
										unset 'target_packages[package_index]'
										break
									fi
								done
								;;
							*)
								DebugAsWarn "unidentified status in message queue: '$msg1_value'"
						esac
						;;
					*)
						DebugAsWarn "unidentified key in message queue: '$msg1_key'"
				esac
			done

			[[ $fail_count -gt 0 ]] && show_package_actions_failed=true
			[[ $ok_count -gt 0 ]] && show_package_actions_ok=true
			[[ $skip_count -gt 0 || $skip_ok_count -gt 0 || $skip_error_count -gt 0 || $skip_abort_count -gt 0 ]] && show_package_actions_skipped=true

			[[ ${#target_packages[@]} -gt 0 ]] && KillActiveFork		# Only needed if an action fork didn't exit properly.
			wait 2>/dev/null
			CloseActionMsgPipe

			[[ ${useropt_terse:=true} = false && $useropt_verbose = false ]] && echo
			;;
		IPK|PIP)
			if [[ $ipks_downgrade = true || $ipks_install = true || $ipks_upgrade = true || $pips_install = true ]]; then
				InitForkCounts
				${PACKAGE_TYPE}s:${TARGET_ACTION}	# Only process these packages in groups, not individually.
			fi
	esac

	EraseForkCountPaths

	Func:Exit

	Error.IsNt

	}

OpenActionMsgPipe()
	{

	# Create a message pipe, so action forks can send data back to parent.

	[[ -p $ACTION_MSG_PIPE ]] && rm -f "$ACTION_MSG_PIPE"
	[[ ! -p $ACTION_MSG_PIPE ]] && mknod "$ACTION_MSG_PIPE" p

	# Create a file descriptor to store original stdin FD.
	backup_stdin_fd=$(FindNextFD)
	DebugVar backup_stdin_fd

	# Backup original stdin file descriptor so it can be restored later.
	eval "exec $backup_stdin_fd>&0"

	# Create another file descriptor to use in message pipe.
	action_msg_pipe_fd=$(FindNextFD)
	DebugVar action_msg_pipe_fd

	# Open a 2-way channel to message pipe.
	[[ $action_msg_pipe_fd != none ]] && eval "exec $action_msg_pipe_fd<>$ACTION_MSG_PIPE"

	}

CloseActionMsgPipe()
	{

	# Restore original file descriptors, and remove message pipe.

	# Restore stdin FD.
	[[ $backup_stdin_fd != none ]] && eval "exec 0>&$backup_stdin_fd"

	# Release backup of stdin FD.
	[[ $backup_stdin_fd != none ]] && eval "exec $backup_stdin_fd>&-"

	# Release message pipe FD.
	[[ $action_msg_pipe_fd != none ]] && eval "exec $action_msg_pipe_fd>&-"

	# Delete message pipe.
	[[ -p $ACTION_MSG_PIPE ]] && rm -f "$ACTION_MSG_PIPE"

	}

AdjustMaxForks()
	{

	# Input:
	#   $1 = action

	# Output:
	#   $max_forks (global)

	max_forks=$CONCURRENCY
	local reason=''

	if [[ $useropt_verbose = true ]]; then 					# No-point running actions async in verbose mode: stdout will be a confusing mess.
		max_forks=1
		reason='verbose mode is active'
	elif [[ $useropt_debug = true ]]; then 					# Same goes for debug mode: logs will be a mess.
		max_forks=1
		reason='debug mode is active'
	else
		case ${1:-} in
			clean)											# Precautionary: don't make too-many calls to PyPI at the same time.
				max_forks=$(((max_forks+1)/2))
				reason="'$1'"
				;;
			@(in|re)stall|upgrade)							# Don't execute these actions async: installer for each package eventually aborts (QPKGs can only be managed one-at-a-time, else packages overwrite each other, and package source files end-up in the wrong install paths).
				max_forks=1
				reason="'$1'"
				;;
			backup|deactivate|download|uninstall)			# Low-resource actions, so allow multiple forks, even on ARMv5.
				max_forks=4
				reason="'$1'"
				;;
			@(dis|en)able?(au)|rebuild|sign|status)			# Really-low-resource actions.
				max_forks=8
				reason="'$1'"
		esac

		[[ -n $reason ]] && reason+=' action was requested'
	fi

	[[ -n $reason ]] && DebugInfo "limiting \$max_forks to $max_forks because $reason"
	DebugVar max_forks

	}

PrepareArgs()
	{

	# Process user arguments ready for parsing

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Input:
	#   $ARGS_RAW (global)

	# Output:
	#   $args[] (global)

	local a=$(Lowercase "${ARGS_RAW//,/ }")
	args=(${a/--/})
	arg_problem=false

	DebugArray args "${args[*]:-}"

	[[ -z $ARGS_RAW ]] && useropt_help_basic=true

	}

ParseManagementArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	Func:Init

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				check)
					generate_show_report=true
					get_qpkg_states=true
					requires_group=false
					run_package_actions=true
					user_action=$arg
					useropt_check=true
					;;
				colo?(u)r?(ful)|follow|paste|terse)
					requires_group=true
					user_action=$arg
					;;
				debug)
					requires_group=false
					user_action=$arg
					EnableDebugToArchiveAndFile
					;;
				reset)
					DeleteSetting Colourful
					DeleteSetting Git_Branch
					DeleteSetting Terse

					Reset					# <-- Processing will terminate in this function (no-return).
					;;
				verbose)
					requires_group=false
					user_action=$arg
					Verbose:Enable
					EnableDebugToArchiveAndFile
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				colo?(u)r?(ful))
					case $group in
						true|false)
							action=''
							awaiting_group=false
							switch_colour=true
							user_colourful_value=$group
							UpdateColourful
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				follow)
					case $group in
						?(un)stable)
							action=''
							awaiting_group=false
							run_package_actions=false
							switch_branch=true
							user_branch_value=$group
							UpdateBranch
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				paste)
					case $group in
						last)
							action=''
							awaiting_group=false
							run_package_actions=false
							useropt_paste_log_last=true
							;;
						tail)
							action=''
							awaiting_group=false
							run_package_actions=false
							useropt_paste_log_tail=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				terse)
					case $group in
						true|false)
							action=''
							awaiting_group=false
							switch_terse=true
							user_terse_value=$group
							UpdateTerse
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"

	Func:Exit

	}

ParseHelpArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   $args[] (global)
	#   $args_incomplete[] (global)
	#   various global flags

	Func:Init

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				help)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			abs|actions|all|all-actions|groups|lists|options|packages|problems|show|tips|upgrades)
				[[ -z $action ]] && action=help
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				help)
					case $group in
						abs)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_abbreviations=true
							;;
						actions)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_actions=true
							;;
						all|all-actions)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_actions_all=true
							;;
						groups)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_groups=true
							;;
						lists)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_lists=true
							;;
						options)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_options=true
							;;
						packages)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_packages=true
							;;
						problems)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_problems=true
							;;
						show)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_show=true
							;;
						tips)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_tips=true
							;;
						upgrades)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_upgrades=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	for arg in "${args_incomplete[@]:-}"; do
		case $arg in
			help)							# If `help` is specified without a valid group, then show basic help.
				run_package_actions=false
				useropt_help_basic=true

				# Remove this arg from incomplete array.
				local a=''
				local tmp=()

				for a in "${args_incomplete[@]}"; do
					[[ $a != "$arg" ]] && tmp+=($a)
				done

				if [[ ${#tmp[@]:-} -eq 0 ]]; then
					args_incomplete=()
				else
					args_incomplete=("${tmp[@]}")
				fi

				unset tmp
		esac
	done

	DebugArray args_incomplete "${args_incomplete[*]:-}"

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"

	Func:Exit

	}

ParseShowArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   $args[] (global)
	#   $args_incomplete[] (global)
	#   various global flags

	Func:Init

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				show)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			abs|backups|dependent|last|packages|repositories|results|status|tail)
				[[ -z $action ]] && action=show
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				show)
					case $group in
						abs)
							action=''
							awaiting_group=false
							generate_help_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_help_abbreviations=true
							;;
						backups)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_backups=true
							;;
						dependent)
							Packages:Load
							action=''
							awaiting_group=false
							generate_show_report=true
							run_package_actions=false
							useropt_show_dependencies=true
							;;
						last)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_log_last=true
							;;
						packages)
							Packages:Load
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_packages=true
							;;
						repositories)
							Packages:Load
							action=''
							awaiting_group=false
							generate_show_report=true
							run_package_actions=false
							useropt_show_repos=true
							;;
						results)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_results=true
							;;
						status)
							Objects:Load
							QPKGs.ACstatus.GRall:Set
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=true
							run_package_actions=true
							useropt_show_status=true
							;;
						tail)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_log_tail=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"

	Func:Exit

	}

ParseListArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   $args[] (global)
	#   $args_incomplete[] (global)
	#   various global flags

	Func:Init

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				list)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			abs)
				[[ -z $action ]] && action=list
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				list)
					case $group in
						abs)
							action=''
							awaiting_group=false
							generate_help_report=true
							get_qpkg_states=true
							run_package_actions=false
							useropt_help_abbreviations=true
							;;
						?(NT)active)
							Objects:Load
							QPKGs.AClist.IS${group}:Set
							QPKGs.ACstatus.ISinstalled:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_active_status=true
							get_qpkg_states=true
							run_package_actions=true
							show_title=false
							;;
						?(NT)backedup|?(NT)enabled|?(NT)installable|?(NT)installed|?(NT)missing|?(NT)upgradable)
							Objects:Load
							QPKGs.AClist.IS${group}:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_states=true
							run_package_actions=false
							show_title=false
							;;
						?(in)dependent)
							Objects:Load
							QPKGs.AClist.GR${group}:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_states=true
							run_package_actions=false
							show_title=false
							;;
						versions)
							action=''
							awaiting_group=false
							generate_list_report=true
							show_title=false
							useropt_show_versions=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"

	Func:Exit

	}

ParseActionArgs()
	{

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   $args[] (global)
	#   $args_incomplete[] (global)
	#   various global flags

	Func:Init

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	[[ -n ${args[*]:-} ]] && Packages:Load

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				?(de|re)activate|backup|clean|@(dis|en)able?(au)|install|reassign|rebuild|@(re|un)install|restore|sign|upgrade)
					requires_group=true
					user_action=$arg
					;;
				status)
					generate_show_report=true
					get_qpkg_states=true
					requires_group=true
					user_action=$arg
					useropt_show_status=true
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg"); DebugVar group

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				?(de|re)activate|backup|clean|@(dis|en)able|@(re|un)install|restore|sign|upgrade)
					case $group in
						?(NT)active)
							Objects:Load
							QPKGs.AC${action}.IS${group}:Set
							QPKGs.ACstatus.ISinstalled:Set
							awaiting_group=false
							generate_action_report=true
							get_qpkg_active_status=true
							get_qpkg_states=true
							run_package_actions=true
					esac
			esac

			case $group in
				all|canbackup|?(NT)canclean|canrestarttoupdate|?(in)dependent|hasdependents)
					Objects:Load
					QPKGs.AC${action}.GR${group}:Set
					awaiting_group=false
					generate_action_report=true
					get_qpkg_active_status=false
					get_qpkg_states=true
					run_package_actions=true
					;;
				?(NT)backedup|?(NT)enabled|?(NT)installable|?(NT)installed|?(NT)missing|?(NT)upgradable)
					Objects:Load
					QPKGs.AC${action}.IS${group}:Set
					awaiting_group=false
					generate_action_report=true
					get_qpkg_states=true
					run_package_actions=true
					;;
				*)
					Objects:Load
					QPKGs-AC${action}-to:Add "$group"
					awaiting_group=false
					generate_action_report=true
					get_qpkg_states=true
					run_package_actions=true
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	for arg in "${args_incomplete[@]:-}"; do
		action=$(MatchVerb "$arg")

		case $action in
			status)
				Objects:Load
				QPKGs.ACstatus.ISinstalled:Set								# If status is specified without a group, then group is `installed`.
				generate_show_report=true
				get_qpkg_states=true
				run_package_actions=true

				# Remove this arg from incomplete array.
				local a=''
				local tmp=()

				for a in "${args_incomplete[@]}"; do
					[[ $a != "$arg" ]] && tmp+=($a)
				done

				if [[ ${#tmp[@]:-} -eq 0 ]]; then
					args_incomplete=()
				else
					args_incomplete=("${tmp[@]}")
				fi

				unset tmp
		esac
	done

	DebugArray args_incomplete "${args_incomplete[*]:-}"

	args=(${args_remaining[@]:-}); DebugArray args "${args[*]:-}"

	Func:Exit

	}

MatchVerb()
	{

	# Identify variant action from $1 and output nice action.

	local a=${1:-}

	case $a in
		activate|start)
			printf activate
			;;
		add|install)
			printf install
			;;
		backup|clean|colo?(u)r?(ful)|@(dis|en)able|follow|help|list|paste|reassign|rebuild|reinstall|reset|restore|sign|terse)
			echo -n "$a"
			;;
		c|check)
			printf check
			;;
		deactivate|stop)
			printf deactivate
			;;
		d?(e)bug)
			printf debug
			;;
		disable-auto-update)
			printf disableau
			;;
		enable-auto-update)
			printf enableau
			;;
		reactivate|restart)
			printf reactivate
			;;
		remove|rm|uninstall)
			printf uninstall
			;;
		s|status?(es))
			printf status
			;;
		show|view)
			printf show
			;;
		update|upgrade)
			printf upgrade
			;;
		v|verbose)
			printf verbose
	esac

	}

MatchNoun()
	{

	# Identify variant group from $1 and output nice group.

	local a=${1:-}

	case $a in
		a|abs|abbreviations)
			printf abs
			;;
		action?(s))
			printf actions
			;;
		action?(s)-all|all-action?(s))
			printf all-actions
			;;
		active|no@(n|t)-inactive|no@(n|t)-stopped|started)
			printf active
			;;
		all|entire|everything)
			printf all
			;;
		b|backups)
			printf backups
			;;
		backedup|canbackup|enabled|installable|installed|missing|results|show|?(un)stable)
			echo -n "$a"
			;;
		d|deps|dependencies|dependent?(s))
			printf dependent
			;;
		disable|false|no|off|unset)
			printf false
			;;
		disabled|no@(n|t)-enabled)
			printf NTenabled
			;;
		enable|on|set|true|yes)
			printf true
			;;
		group?(s))
			printf groups
			;;
		inactive|no@(n|t)-active|no@(n|t)-started|stopped)
			printf NTactive
			;;
		indep?(endent)?(s))
			printf independent
			;;
		l|last)
			printf last
			;;
		list?(s))
			printf lists
			;;
		log|tail)
			printf tail
			;;
		me|problem?(s))
			printf problems
			;;
		new|updat?(e)able|upgrad@(a|e)ble)
			printf upgradable
			;;
		no@(n|t)-back?(ed)up)
			printf NTbackedup
			;;
		no@(n|t)-installable)
			printf NTinstallable
			;;
		no@(n|t)-installed)
			printf NTinstalled
			;;
		no@(n|t)-missing)
			printf NTmissing
			;;
		no@(n|t)-upgradable)
			printf NTupgradable
			;;
		o|option?(s))
			printf options
			;;
		p|package?(s)|qpkg?(s))
			printf packages
			;;
		r|repos|repositories)
			printf repositories
			;;
		s|status?(es))
			printf status
			;;
		tip?(s))
			printf tips
			;;
		upgrade?(s)|upgrading)
			printf upgrades
			;;
		version?(s))
			printf versions
			;;
		*)
			QPKG.MatchAbbrv "$a"
	esac

	}

ArgSuggestions:Show()
	{

	# Input:
	#   $args[] (global)
	#   $args_incomplete[] (global)

	# Output:
	#   various global flags

	Func:Init

	local arg=''
	local -a args_remaining=()

	if [[ ${#args_incomplete[@]:-} -gt 0 ]]; then
		run_package_actions=false

		for arg in "${args_incomplete[@]}"; do
			case $arg in
				?(de|re)activate|backup|clean|@(dis|en)able|@(dis|en)able-auto-update|reassign|@(re|un)install|?(re)start|restore|rm|sign|stop|upgrade)
					DisplayAsProjSynExam "please provide valid $(ShowAsPackages) or a $(ShowAsPackageGroup) after '$arg' like" "$arg installed"
					arg_problem=true
					useropt_help_basic=false
					;;
				colo?(u)r?(ful)|terse)
					DisplayAsProjSynExam "please provide a valid boolean after '$arg' like" "$arg true"
					DisplayAsProjSynIndentExam '' "$arg false"
					DisplayAsProjSynIndentExam '' "$arg on"
					DisplayAsProjSynIndentExam '' "$arg off"
					DisplayAsProjSynIndentExam '' "$arg yes"
					DisplayAsProjSynIndentExam '' "$arg no"
					DisplayAsProjSynIndentExam '' "$arg enable"
					DisplayAsProjSynIndentExam '' "$arg disable"
					arg_problem=true
					useropt_help_basic=false
					;;
				follow)
					DisplayAsProjSynExam "please provide a valid $(ShowAsTitleName) git branch to '$arg' like" "$arg stable"
					DisplayAsProjSynIndentExam '' "$arg unstable"
					arg_problem=true
					useropt_help_basic=false
					;;
				install|rebuild)
					DisplayAsProjSynExam "please provide valid $(ShowAsPackages) or a $(ShowAsPackageGroup) after '$arg' like" "$arg all"
					arg_problem=true
					useropt_help_basic=false
					;;
				list)
					DisplayAsProjSynExam "please provide a valid source to '$arg' like" "$arg installable"
					DisplayAsProjSynIndentExam '' "$arg new"
					arg_problem=true
					useropt_help_basic=false
					;;
				paste)
					DisplayAsProjSynExam "please provide a valid source to '$arg' online like" "$arg log"
					DisplayAsProjSynIndentExam '' "$arg last"
					arg_problem=true
					useropt_help_basic=false
					;;
				show)
					DisplayAsProjSynExam "please provide a valid source after '$arg' like" "$arg abs"
					DisplayAsProjSynIndentExam '' "$arg log"
					DisplayAsProjSynIndentExam '' "$arg packages"
					DisplayAsProjSynIndentExam '' "$arg results"
					arg_problem=true
					useropt_help_basic=false
					;;
				*)
					arg_problem=true
					args_remaining+=("$arg")
			esac
		done

		if [[ ${#args_remaining[@]:-} -gt 0 ]]; then
			[[ $arg_problem = true ]] && echo
			ShowAsError "incomplete argument$(Pluralise "${#args_remaining[@]}") \"${args_remaining[*]}\". Please check the arguments again"
			arg_problem=true
			args_remaining=()
		fi
	fi

	if [[ ${#args[@]:-} -gt 0 ]]; then
		run_package_actions=false

		for arg in "${args[@]}"; do
			case $arg in
				active|@(dis|en)abled|started)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "deactivate $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				all)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before 'all' like" 'activate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-activate|activate-all)
					DisplayAsProjSynExam 'to activate all QPKGs, use' 'activate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-backup|backup-all)
					DisplayAsProjSynExam 'to backup all installed QPKG configurations, use' 'backup all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-deactivate|deactivate-all)
					DisplayAsProjSynExam 'to deactivate all QPKGs, use' 'deactivate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-reactivate|reactivate-all)
					DisplayAsProjSynExam 'to reactivate all QPKGs, use' 'reactivate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-restore|restore-all)
					DisplayAsProjSynExam 'to restore all installed QPKG configurations, use' 'restore all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-stop|stop-all)
					DisplayAsProjSynExam 'to stop all QPKGs, use' 'stop all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-uninstall|all-remove|uninstall-all|remove-all)
					DisplayAsProjSynExam 'to uninstall all QPKGs, use' 'uninstall all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-upgrade|upgrade-all)
					DisplayAsProjSynExam 'to upgrade all QPKGs, use' 'upgrade all'
					arg_problem=true
					useropt_help_basic=false
					;;
				@(dis|en)able|false|off|no|on|true|yes)
					DisplayAsProjSynExam "please provide a valid setting before '$arg' like" "colour $arg"
					DisplayAsProjSynIndentExam '' "terse $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				download)
					ShowAsError "'$arg' is not a manual action"
					arg_problem=true
					useropt_help_basic=false
					;;
				@(in|not-)active|?(in)dependent?(s)|stopped)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "activate $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				?(un)stable)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "follow $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				*)
					arg_problem=true
					args_remaining+=("$arg")
			esac
		done

		if [[ ${#args_remaining[@]:-} -gt 0 ]]; then
			[[ $arg_problem = true ]] && echo
			ShowAsError "unknown argument$(Pluralise "${#args_remaining[@]}") \"${args_remaining[*]}\". Please check the arguments again"
			arg_problem=true
			useropt_help_basic=false
		fi
	fi

	[[ $arg_problem = true ]] && echo

	DebugArray args_incomplete "${args_incomplete[*]:-}"
	DebugArray args_remaining "${args_remaining[*]:-}"

	Func:Exit

	}

AllocPackGroupsToAcs()
	{

	Func:Init

	ShowAsProc 'match QPKG groups to actions'

	local action=''
	local group=''

	for action in "${USER_QPKG_ACTIONS[@]}"; do
		# Process group-based user-actions.

		# Positive groups.

		for group in "${QPKG_IS_GROUPS[@]}"; do
			if QPKGs.AC${action}.GR${group}.IsSet; then
				QPKGs-AC${action}-to:Add "$(QPKGs-GR${group}:Array)"

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', group: 'GR${group}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any 'GR$group' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done

		# Negative groups.

		for group in "${QPKG_ISNT_GROUPS[@]}"; do
			if QPKGs.AC${action}.GRNT${group}.IsSet; then
				QPKGs-AC${action}-to:Add "$(QPKGs-GRNT${group}:Array)"

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', group: 'GRNT${group}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any 'GRNT$group' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done
	done

	Func:Exit

	}

AllocPackStatesToAcs()
	{

	Func:Init

	ShowAsProc 'match QPKG states to actions'

	local action=''
	local check_later=false
	local state=''

	for action in "${USER_QPKG_ACTIONS[@]}"; do
		# Process state-based user-actions.

		# Positive states.

		for state in "${QPKG_IS_STATES[@]}"; do
			check_later=false

			if QPKGs.AC${action}.IS${state}.IsSet; then
				if [[ $state = active ]]; then
					check_later=true
				else
					QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
				fi

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', state: 'IS${state}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				elif [[ $check_later = true ]]; then
					DebugAsDone "action: '$action', state: 'IS${state}': will add filtered-QPKGs later after 'status' has been determined"
				else
					ShowAsWarn "unable to find any '$state' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done

		# Negative states.

		for state in "${QPKG_ISNT_STATES[@]}"; do
			check_later=false

			if QPKGs.AC${action}.ISNT${state}.IsSet; then
				if [[ $state = active ]]; then
					check_later=true
				else
					QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
				fi

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', state: 'ISNT${state}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				elif [[ $check_later = true ]]; then
					DebugAsDone "action: '$action', state: 'ISNT${state}': will add filtered-QPKGs later after 'status' has been determined"
				else
					ShowAsWarn "unable to find any 'not $state' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done
	done

	Func:Exit

	}

ResetArchivedLogs()
	{

	if [[ -n $LOGS_PATH && -d $LOGS_PATH ]]; then
		ClearPath "$THIS_PACKAGE_PATH" "$LOGS_PATH"
		echo 'log reset' > "$sess_active_pathfile"
		ShowAsDone 'logs cleared'
	fi

	return 0

	}

ResetCachePath()
	{

	if [[ -n $CACHE_PATH && -d $CACHE_PATH ]]; then
		ClearPath "$THIS_PACKAGE_PATH" "$CACHE_PATH"
		ShowAsDone 'package cache cleared'
	fi

	return 0

	}

ResetReportsPath()
	{

	if [[ -n $REPORTS_PATH && -d $REPORTS_PATH ]]; then
		ClearPath /var/log/sherpa "$REPORTS_PATH"
		ShowAsDone 'reports cleared'
	fi

	return 0

	}

Quiz()
	{

	# Input:
	#   $1 = prompt

	# Output:
	#   $? = 0 if "y", 1 if anything else

	local prompt=${1:?${FUNCNAME[0]}'()': undefined prompt}
	local response=''

	ShowAsQuiz "$prompt"
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD igncr	# Ignore CR to prevent an onscreen linefeed (which disrupts same-line rewrite used later, and looks bad).
	read -rn1 response
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD -igncr	# Re-allow CR.
	DebugVar response

	ShowAsQuizDone "$prompt: $response"

	case ${response:0:1} in
		y|Y)
			return 0
			;;
		*)
			return 1
	esac

	}

PatchEntwareService()
	{

	local -r TAB=$'\t'
	local -r PREFIX='# the following line was inserted by sherpa: https://git.io/sherpa'
	local -r PACKAGE_INIT_PATHFILE=$(QPKG.GetServicePathFile Entware)
	local find=''
	local insert=''

	if $GREP_CMD -q 'opt.orig' "$PACKAGE_INIT_PATHFILE"; then
		DebugInfo 'patch: do the "/opt shuffle" - already done'
	else
		# Ensure existing files are moved out of the way before creating /opt symlink.
		find='# sym-link $QPKG_DIR to /opt'
		insert='opt_path="/opt"; opt_backup_path="/opt.orig"; [[ -d "$opt_path" \&\& ! -L "$opt_path" \&\& ! -e "$opt_backup_path" ]] \&\& mv "$opt_path" "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${TAB}${PREFIX}\n${TAB}${insert}\n|" "$PACKAGE_INIT_PATHFILE"

		# ... then restored after creating /opt symlink.
		find='/bin/ln -sf $QPKG_DIR /opt'
		insert='[[ -L "$opt_path" \&\& -d "$opt_backup_path" ]] \&\& cp "$opt_backup_path"/* --target-directory "$opt_path" \&\& rm -r "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${TAB}${PREFIX}\n${TAB}${insert}\n|" "$PACKAGE_INIT_PATHFILE"

		DebugAsDone 'patch: do the "opt shuffle"'
	fi

	return 0

	}

UpdateEntwarePackageList()
	{

	if IsNtSysFileExist $OPKG_CMD; then
		DisplayAsProjSynExam 'try reactivating Entware' 'reactivate ew'

		return 1
	fi

	[[ ${ENTWARE_PACKAGE_LIST_UPTODATE:-false} = false ]] || return

	local -i z=0

	# If Entware package list was recently updated, don't update again.

	if ! IsThisFileRecent "$EXTERNAL_PACKAGES_ARCHIVE_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES" || [[ ! -f $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE || $useropt_check = true ]]; then
		DebugAsProc "updating $(ShowAsPackageName Entware) package list"

		RunAndLog "$OPKG_CMD update" "$LOGS_PATH/Entware.$UPDATE_LOG_FILE" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			DebugAsDone "updated $(ShowAsPackageName Entware) package list"
			CloseIpkArchive
		else
			DebugAsWarn "Unable to update $(ShowAsPackageName Entware) package list $(ShowAsExitcode "$z")"
			# no-big-deal
		fi
	else
		DebugInfo "$(ShowAsPackageName Entware) package list was updated less-than $FILE_CHANGE_THRESHOLD_MINUTES minutes ago: skipping update"
	fi

	[[ -f $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE && ! -f $EXTERNAL_PACKAGES_PATHFILE ]] && OpenIpkArchive
	readonly ENTWARE_PACKAGE_LIST_UPTODATE=true

	return 0

	}

IsThisFileRecent()
	{

	# Input:
	#   $1 = pathfilename: file to examine change time of.
	#   $2 = integer (optional): threshold in minutes - default is `1440` = 1 day.

	# Output:
	#   $? = true/false

	# Examine `change` time as this is updated even if file content isn't modified.

	# https://stackoverflow.com/a/55622661
	[[ -e ${1:-} && $((($(/bin/date +%s)-$(/usr/bin/stat "$1" -c %Z))/60)) -le ${2:-1440} ]]

	}

SaveIpkAndPipList()
	{

	$PIP_CMD freeze | cut -d'=' -f1 > "$PREV_PIP_LIST"
	[[ -e $PREV_PIP_LIST ]] && DebugAsDone "saved current PIP module list to $(ShowAsFileName "$PREV_PIP_LIST")"

	$OPKG_CMD list-installed > "$PREV_IPK_LIST"
	[[ -e $PREV_IPK_LIST ]] && DebugAsDone "saved current $(ShowAsPackageName Entware) IPK list to $(ShowAsFileName "$PREV_IPK_LIST")"

	} 2>/dev/null

LoadIpkList()
	{

	local name=''
	local separator=''
	local version=''

	if [[ -e $PREV_IPK_LIST ]]; then
		DebugInfo "IPKs are being loaded from $(ShowAsFileName "$PREV_IPK_LIST")"

		while read -r name separator version; do
			name=$(Lowercase "$name")

			IPKs-ACinstall-to:Add "$name"
		done < "$PREV_IPK_LIST"
	fi

	}

LoadPipList()
	{

	local name=''
	local re=''

	if [[ -e $PREV_PIP_LIST ]]; then
		DebugInfo "PIPs are being loaded from $(ShowAsFileName "$PREV_PIP_LIST")"

		while read -r name; do
			name=$(Lowercase "$name")
			re=\\b$name\\b

			[[ ${EXCLUSION_PIPS[*]} =~ $re ]] || PIPs-ACinstall-to:Add "$name"
		done < "$PREV_PIP_LIST"
	fi

	}

CalcIpkDepsToInstall()
	{

	# From a specified list of IPK names, find all dependent IPKs, exclude those already installed, then generate a list to download.

	IsSysFileExist $GNU_GREP_CMD || return

	Func:Init

	local complete=false
	local -a dep_acc=()
	local element=''
	local -i iterations=0
	local -r ITERATION_LIMIT=20
	local -i pre_exclude_count=0
	local pre_exclude_list=''
	local req_list=''
	local -i requested_count=0
	local -a this_list=()

	# Remove duplicate entries.
	req_list=$(DeDupeWords "$(IPKs-ACinstall-to:List)")
	dep_acc=($req_list)
	this_list=($req_list)
	requested_count=$($WC_CMD -w <<< "$req_list")

	if [[ $requested_count -eq 0 ]]; then
		DebugAsWarn 'no IPKs requested'

		Func:Exit 1; return
	fi

	DebugInfo "$requested_count IPK$(Pluralise "$requested_count") requested" "'$req_list' "

	while [[ $iterations -lt $ITERATION_LIMIT ]]; do
		ShowAsIterativeProgress 'resolve IPK dependencies' "$iterations" iteration "${#dep_acc[@]}" 'unique package'

		((iterations++))
		local ipk_titles=$(printf '^Package: %s$\|' "${this_list[@]}")
		ipk_titles=${ipk_titles%??}		# Remove last 2 characters.

		this_list=($($GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator '^Package:\|^Depends:' "$EXTERNAL_PACKAGES_PATHFILE" | $GNU_GREP_CMD -vG '^Section:\|^Version:' | $GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator "$ipk_titles" | $GNU_GREP_CMD -vG "$ipk_titles" | $GNU_GREP_CMD -vG '^Package: ' | $SED_CMD 's|^Depends: ||;s|, |\n|g' | $SORT_CMD | $UNIQ_CMD))

		# Update progress twice per loop.
		ShowAsIterativeProgress 'resolve IPK dependencies' "$iterations" iteration "${#dep_acc[@]}" 'unique package'

		if [[ ${#this_list[@]} -eq 0 ]]; then
			complete=true
			break
		else
			dep_acc+=(${this_list[*]})
			dep_acc=($(DeDupeWords "${dep_acc[*]}"))
		fi
	done

	sleep .5

	[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo

	if [[ $complete = true ]]; then
		DebugAsDone "dependency calculation complete in $iterations iteration$(Pluralise "$iterations")"
	else
		DebugAsError "dependency calculation incomplete in $iterations iteration$(Pluralise "$iterations"), consider raising \$ITERATION_LIMIT [$ITERATION_LIMIT]"
		show_suggest_raise_issue=true
	fi

	# Exclude already installed IPKs.
	pre_exclude_list=${dep_acc[*]}
	pre_exclude_count=$($WC_CMD -w <<< "$pre_exclude_list")

	if [[ $pre_exclude_count -gt 0 ]]; then
		ShowAsProc 'exclude IPKs already installed'

		DebugInfo "$pre_exclude_count IPK$(Pluralise "$pre_exclude_count") required (including dependencies)" "'$pre_exclude_list' "

		for element in $pre_exclude_list; do
			# KLUDGE: silently exclude these packages from being installed:
			#   KLUDGE: `ca-certs` appears to be a bogus meta-package.
			#   KLUDGE: `python3-gdbm` is not available, but can be requested as per https://forum.qnap.com/viewtopic.php?p=806031#p806031 (don't know why).

			if [[ $element != 'ca-certs' && $element != 'python3-gdbm' ]]; then
				# KLUDGE: `libjpeg` appears to have been replaced by `libjpeg-turbo`, but many packages still have `libjpeg` as a dependency, so replace it with `libjpeg-turbo`.

				if [[ $element != 'libjpeg' ]]; then
					if ! $OPKG_CMD status "$element" | $GREP_CMD -q "Status:.*installed"; then
						IPKs-ACdownload-to:Add "$element"
					fi
				elif ! $OPKG_CMD status 'libjpeg-turbo' | $GREP_CMD -q "Status:.*installed"; then
					IPKs-ACdownload-to:Add 'libjpeg-turbo'
				fi
			fi
		done
	else
		DebugAsDone 'no IPKs to exclude'
	fi

	Func:Exit

	}

CalcIpkDownloadSize()
	{

	# Calculate size of required IPKs.

	Func:Init

	local -a size_array=()
	local -i size_count=0
	size_count=$(IPKs-ACdownload-to:Count)

	if [[ $size_count -gt 0 ]]; then
		ShowAsProc "calculate size of IPK$(Pluralise "$size_count") to download"

		DebugAsDone "$size_count IPK$(Pluralise "$size_count") to download: '$(IPKs-ACdownload-to:List)'"
		size_array=($($GNU_GREP_CMD -w '^Package:\|^Size:' "$EXTERNAL_PACKAGES_PATHFILE" | $GNU_GREP_CMD --after-context 1 --no-group-separator ": $($SED_CMD 's/ /$ /g;s/\$ /\$\\\|: /g' <<< "$(IPKs-ACdownload-to:List)")" | $GREP_CMD '^Size:' | $SED_CMD 's|^Size: ||'))

		# shellcheck disable=2283
		IPKs-ACdownload-to:Size = "$(IFS=+; echo "$((${size_array[*]:-}))")"		# nifty sizing shortcut found here https://stackoverflow.com/a/13635566/6182835
		DebugAsDone "$(FormatAsThous "$(IPKs-ACdownload-to:Size)") bytes ($(FormatAsIsoBytes "$(IPKs-ACdownload-to:Size)")) to download"
	else
		DebugAsDone 'no IPKs to size'
	fi

	Func:Exit

	}

IPKs:upgrade()
	{

	# Upgrade all installed IPKs.

	[[ $ipks_upgrade = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	Error.IsNt || return

	Func:Init

	local desc=''
	local log_pathfile=$LOGS_PATH/ipks.$UPGRADE_LOG_FILE
	local -i total_count=0
	local -i z=0

	IPKs-ACupgrade-to:Init
	IPKs-ACdownload-to:Init

	IPKs-ACupgrade-to:Add "$($OPKG_CMD list-upgradable | cut -f1 -d' ')"

	# Don't upgrade IPKs that must remain downgraded.
	IPKs-ACupgrade-to:Remove "$(IPKs-ACdowngrade-to:Array)"
	IPKs-ACupgrade-to:Remove "$(IPKs-ACdowngrade-sk:Array)"

	IPKs-ACdownload-to:Add "$(IPKs-ACupgrade-to:Array)"

	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		desc="$total_count auxiliary IPK module$(Pluralise "$total_count")"

		ShowAsProc "upgrade $desc"

		_DirSizeMonitor_ "$IPK_DL_PATH" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD upgrade --force-overwrite $(IPKs-ACdownload-to:List) --cache $IPK_CACHE_PATH --tmp-dir $IPK_DL_PATH" "$log_pathfile" log:failure-only
		z=$?

		KillActiveFork

		if [[ $z -eq 0 ]]; then
			NoteIpkAcAsOk "$(IPKs-ACupgrade-to:Array)" upgrade
			DebugAsDone "upgraded $desc"
			SaveActionResultToLog IPK "$desc" upgrade ok "$z"
		else
			NoteIpkAcAsEr "$(IPKs-ACupgrade-to:Array)" upgrade
			SaveActionResultToLog IPK "$desc" upgrade failed "$z"
		fi

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	Func:Exit $z

	}

IPKs:install()
	{

	# Install IPKs required to support QPKGs.

	[[ $ipks_install = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	Error.IsNt || return

	Func:Init

	local desc=''
	local -i i=0
	local log_pathfile=$LOGS_PATH/ipks.$INSTALL_LOG_FILE
	local previous=''
	local -i total_count=0
	local -i z=0

	IPKs-ACinstall-to:Init
	IPKs-ACdownload-to:Init

	if QPKGs-ACinstall-ok.Exist Entware || ([[ $useropt_check = true ]] && QPKG.IsInstalled Entware); then
		IPKs-ACinstall-to:Add "$ESSENTIAL_IPKS"

		if [[ -e $PREV_IPK_LIST && $useropt_check = false ]]; then		# Don't load previous IPK list during 'check'.
			LoadIpkList
			mv -f "$PREV_IPK_LIST" "$PREV_IPK_LIST.installing"
		fi
	fi

	if QPKGs.ACinstall.GRall.IsSet; then
		for i in "${!QPKG_NAME[@]}"; do
			[[ $previous = "${QPKG_NAME[$i]}" ]] && continue || previous=${QPKG_NAME[$i]}

			QPKG.IsArchOK "${QPKG_NAME[$i]}" || continue
			QPKG.IsMinOSVerOk "${QPKG_NAME[$i]}" || continue
			QPKG.IsMinRAMOk "${QPKG_NAME[$i]}" || continue

			IPKs-ACinstall-to:Add "$(QPKG.GetIPKs "${QPKG_NAME[$i]}" "$i")"
		done
	else
		for i in "${!QPKG_NAME[@]}"; do
			[[ $previous = "${QPKG_NAME[$i]}" ]] && continue || previous=${QPKG_NAME[$i]}

			if QPKGs-ACinstall-to.Exist "${QPKG_NAME[$i]}" || QPKGs-ISinstalled.Exist "${QPKG_NAME[$i]}" || QPKGs-ACreinstall-to.Exist "${QPKG_NAME[$i]}" || (QPKGs-ACactivate-to.Exist "${QPKG_NAME[$i]}" && (QPKGs-ACinstall-to.Exist "${QPKG_NAME[$i]}" || QPKGs-ISinstalled.Exist "${QPKG_NAME[$i]}" || QPKGs-ACreinstall-to.Exist "${QPKG_NAME[$i]}")); then
				QPKG.IsArchOK "${QPKG_NAME[$i]}" || continue
				QPKG.IsMinOSVerOk "${QPKG_NAME[$i]}" || continue
				QPKG.IsMinRAMOk "${QPKG_NAME[$i]}" || continue

				IPKs-ACinstall-to:Add "$(QPKG.GetIPKs "${QPKG_NAME[$i]}" "$i")"
			fi
		done
	fi

	CalcIpkDepsToInstall
	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		desc="$total_count auxiliary IPK module$(Pluralise "$total_count")"

		ShowAsProc "install $desc"

		_DirSizeMonitor_ "$IPK_DL_PATH" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD install --force-overwrite $(IPKs-ACdownload-to:List) --cache $IPK_CACHE_PATH --tmp-dir $IPK_DL_PATH" "$log_pathfile" log:failure-only
		z=$?

		KillActiveFork

		if [[ $z -eq 0 ]]; then
			NoteIpkAcAsOk "$(IPKs-ACdownload-to:Array)" install
			DebugAsDone "installed $desc"
			SaveActionResultToLog IPK "$desc" install ok "$z"
			Keystrokes:Hide
			UpdateColourisation

			rm -f "$PREV_IPK_LIST.installing"
		else
			NoteIpkAcAsEr "$(IPKs-ACdownload-to:Array)" install
			SaveActionResultToLog IPK "$desc" install failed "$z"

			if [[ -e $PREV_IPK_LIST.installing ]]; then
				mv -f "$PREV_IPK_LIST.installing" "$PREV_IPK_LIST"
			fi
		fi

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	Func:Exit $z

	}

IPKs:downgrade()
	{

	# Downgrade specific installed IPKs.

	[[ $ipks_downgrade = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	Error.IsNt || return

	Func:Init

	local desc=''
	local -i fail_count=0
	local log_pathfile=''
	local name=''
	local -i ok_count=0
	local package_type=''
	local remote_url=''
	local -i total_count=0
	local url_prefix=''
	local url_suffix=''
	local -i z=0

	IPKs-ACdownload-to:Init
	total_count=$(IPKs-ACdowngrade-to:Count)

	if [[ $total_count -gt 0 ]]; then
		package_type='auxiliary IPK module'
		desc="$total_count ${package_type}$(Pluralise "$total_count")"
		log_pathfile=$LOGS_PATH/ipks.$DOWNLOAD_LOG_FILE

		ShowAsProc "download $desc"

		if OS.IsNonStdKernelPageSize; then
			url_prefix=http://bin.entware.net
			url_suffix=_2.38-1

			case $NAS_QPKG_ARCH in
				a41)
					url_prefix+='/armv7sf-k3.2'
					url_suffix+='_armv7-3.2'
			esac

			url_prefix+=/archive/
			url_suffix+=.ipk

			for name in $(IPKs-ACdowngrade-to:Array); do
				ShowAsPercentProgress "download $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 0 "$total_count"
				((ok_count++))

				remote_url=${url_prefix}${name}${url_suffix}
				local_pathfile=$IPK_DOWNGRADE_DL_PATH/$($BASENAME_CMD "$remote_url")
				RunAndLog "$CURL_CMD --location --output $local_pathfile $remote_url" "$log_pathfile" log:failure-only
			done

			ShowAsPercentProgress "download $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 "$fail_count" "$total_count"
		fi

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo

		total_count=1
		ok_count=0
		fail_count=0
		package_type='auxiliary IPK group'
		desc="$total_count ${package_type}$(Pluralise "$total_count")"
		log_pathfile=$LOGS_PATH/ipks.$DOWNGRADE_LOG_FILE

		ShowAsProc "downgrade $desc"

		ShowAsPercentProgress "downgrade $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 "$fail_count" "$total_count"
		RunAndLog "$OPKG_CMD install --force-downgrade --cache $IPK_CACHE_PATH --tmp-dir $IPK_DOWNGRADE_DL_PATH $IPK_DOWNGRADE_DL_PATH/*.ipk" "$log_pathfile" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			((ok_count++))
			NoteIpkAcAsOk "$(IPKs-ACdowngrade-to:Array)" downgrade
			DebugAsDone "downgraded $desc"
			SaveActionResultToLog IPK "$desc" downgrade ok "$z"
		else
			((fail_count++))
			NoteIpkAcAsEr "$(IPKs-ACdowngrade-to:Array)" downgrade
			SaveActionResultToLog IPK "$desc" downgrade failed "$z"
		fi

		ShowAsPercentProgress "downgrade $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 "$fail_count" "$total_count"

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	Func:Exit $z

	}

IPKs:uninstall()
	{

	:	# Placeholder function

	}

PIPs:upgrade()
	{

	:	# Placeholder function

	}

PIPs:install()
	{

	[[ $pips_install = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	$OPKG_CMD status python3-pip | $GREP_CMD -q "Status:.*installed" || return
	Error.IsNt || return

	Func:Init

	local desc=''
	local exec_cmd=''
	local -i fail_count=0
	local log_pathfile=$LOGS_PATH/pypi.$INSTALL_LOG_FILE
	local -i ok_count=0
	local package_type='auxiliary PyPI group'
	local -i total_count=0
	local -i z=0

	if [[ $useropt_check = true ]] || IPKs-ACinstall-ok.Exist python3-pip; then
		PIPs-ACinstall-to:Add "$ESSENTIAL_PIPS"

		if [[ -e $PREV_PIP_LIST && $useropt_check = false ]]; then		# Don't load previous PIP list during 'check'.
			LoadPipList
			mv -f "$PREV_PIP_LIST" "$PREV_PIP_LIST.installing"
		fi

		((total_count++))

		exec_cmd="$PIP_CMD install --upgrade --no-input $(PIPs-ACinstall-to:List) --cache-dir $PIP_CACHE_PATH 2> >($GREP_CMD -v \"Running pip as the 'root' user\") >&2"
		desc='auxiliary PyPI modules'

		ShowAsPercentProgress "install $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 0 "$total_count"
		RunAndLog "$exec_cmd" "$log_pathfile" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			((ok_count++))
			DebugAsDone "installed $desc"
			SaveActionResultToLog PIP "$desc" install ok "$z"

			rm -f "$PREV_PIP_LIST.installing"
		else
			((fail_count++))
			SaveActionResultToLog PIP "$desc" install failed "$z"

			if [[ -e $PREV_PIP_LIST.installing ]]; then
				mv -f "$PREV_PIP_LIST.installing" "$PREV_PIP_LIST"
			fi
		fi

		ShowAsPercentProgress "install $total_count ${package_type}$(Pluralise "$total_count")" '' "$ok_count" 0 "$fail_count" "$total_count"

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	Func:Exit $z

	}

PIPs:uninstall()
	{

	:	# Placeholder function

	}

OpenIpkArchive()
	{

	# Unpack the package list file used by `opkg`.

	# Output:
	#   $? = 0 if successful or 1 if failed

	if [[ ! -e $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE ]]; then
		ShowAsError 'unable to locate the IPK list file'

		return 1
	fi

	RunAndLog "/usr/local/sbin/7z e -o$($DIRNAME_CMD "$EXTERNAL_PACKAGES_PATHFILE") $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE" "$CACHE_PATH/ipk.archive.extract" log:failure-only

	if [[ ! -e $EXTERNAL_PACKAGES_PATHFILE ]]; then
		ShowAsError 'unable to open the IPK list file'

		return 1
	fi

	return 0

	}

CloseIpkArchive()
	{

	rm -f "$EXTERNAL_PACKAGES_PATHFILE"

	}

_LaunchOneActionWithManyForks_()
	{

	# Execute actions concurrently, but only as many as $max_forks will allow given the circumstances.

	# * This function runs as a background process *

	# inputs: (local)
	#   $1 = the target function action to be applied to each QPKG in $target_packages()
	#   $2 = an array of QPKG names to process with $1

	# inputs: (global)
	#   $fork_count = number of currently running forks.
	#   $max_forks = maximum number of permitted concurrent forks given the current environment.

	local a=${1:-function null}
	local b=''

	shift   											# `shift` all arguments one position to the left.
	local -a c=("$@")

	for b in "${c[@]}"; do
		while [[ $fork_count -ge $max_forks && ! -e $ACTION_ABORT_PATHFILE ]]; do  	# Don't fork until an empty spot becomes available.
			sleep .2
			UpdateForkProgress
		done

		[[ -e $ACTION_ABORT_PATHFILE ]] && exit

		IncForkProgressIndex
		MarkThisActionForkAsStarted 					# Must create runfile here, as it takes too-long to happen in background function.
		$a "$b" &
		DebugAsDone "forked $a() for '$b'"
		UpdateForkProgress
	done

	# All action forks have launched, just need to wait for them to exit.

	while [[ $fork_count -gt 0 ]]; do
		sleep .2
		UpdateForkProgress								# Update display while running forks complete.
	done

	# All forks have exited.

	}

_DirSizeMonitor_()
	{

	# * This function runs autonomously *

	# Input:
	#   $1 = directory to monitor the size of.
	#   $2 = total target bytes (100%) for specified path.

	# Output:
	#   stdout = "percentage downloaded (downloaded bytes/total expected bytes)".

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined path} ]] || exit
	[[ -d $1 && ${2:-0} -gt 0 ]] || exit
	IsSysFileExist $GNU_FIND_CMD || exit

	local -i current_bytes=-1
	local -i last_bytes=0
	local perc_msg=''
	local progress_msg=''
	local stall_msg=''
	local -i stall_seconds=0
	local -i stall_seconds_threshold=4
	local -i total_bytes=${2:-0}

	InitProgress

	while [[ $current_bytes -lt $total_bytes ]]; do
		current_bytes=$($GNU_FIND_CMD "$1" -type f -name '*.ipk' -exec $DU_CMD --bytes --total --apparent-size {} + 2>/dev/null | $GREP_CMD total$ | cut -f1)
		[[ -z $current_bytes ]] && current_bytes=0

		if [[ $current_bytes -ne $last_bytes ]]; then
			stall_seconds=0
			last_bytes=$current_bytes
		else
			((stall_seconds++))
		fi

		perc_msg="$((200*(current_bytes)/(total_bytes)%2+100*(current_bytes)/(total_bytes)))%"
		[[ $current_bytes -lt $total_bytes && $perc_msg = '100%' ]] && perc_msg='99%'	# ensure we don't hit 100% until the last byte is downloaded
		progress_msg="$perc_msg ($(TextBrightWhite "$(FormatAsIsoBytes "$current_bytes")")/$(TextBrightWhite "$(FormatAsIsoBytes "$total_bytes")"))"

		if [[ $stall_seconds -ge $stall_seconds_threshold ]]; then
			# Append a message showing stalled time.
			stall_msg=' stalled for '

			if [[ $stall_seconds -lt 60 ]]; then
				stall_msg+="$stall_seconds seconds"
			else
				stall_msg+=$(FormatSecsToHoursMinutesSecs "$stall_seconds")
			fi

			# Add a suggestion to cancel if download has stalled for too-long.

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg+=': cancel with CTRL+C and try again later'
			fi

			# Colourise as-required.

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg=$(TextBrightRed "$stall_msg")
			elif [[ $stall_seconds -ge 45 ]]; then
				stall_msg=$(TextBrightOrange "$stall_msg")
			elif [[ $stall_seconds -ge 20 ]]; then
				stall_msg=$(TextBrightYellow "$stall_msg")
			fi

			progress_msg+=$stall_msg
		fi

		[[ ! -e $DISPLAY_INHIBIT_PATHFILE ]] || return
		WriteMsgInPlace "$progress_msg"
		sleep 1
	done

	[[ -n $progress_msg ]] && WriteMsgInPlace 'done!'

	}

WriteMsgInPlace()
	{

	# Input:
	#   $1 = message to display.

	# Output:
	#   stdout = "$1" with all whitespace squeezed.
	#   $prev_clean_msg = the message provided in $1, but with all whitespace squeezed, and ANSI codes removed.

	local -i a=0		# Blanking length
	local b=$(tr -s ' ' <<< "${1:-}")
	local c=$(StripANSICodes "$b")

	if [[ $c != "$prev_clean_msg" ]]; then
		if [[ ${#c} -lt ${#prev_clean_msg} ]]; then
			a=$((${#c}-${#prev_clean_msg}))
			# Backspace to start of previous msg, print new msg, add additional spaces, then backspace to end of new msg.
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$b"; printf "%${a}s"; printf "%${a}s" | tr ' ' '\b'
		else
			# Backspace to start of previous msg, print new msg.
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$b"
		fi

		prev_clean_msg=$c
	fi

	}

KillActiveFork()
	{

	if [[ -n ${fork_pid:-} && ${fork_pid:-0} -gt 0 && -d /proc/$fork_pid ]]; then
		sleep .2
		set +m		# disable job control
		kill -9 "$fork_pid"
		set -m		# re-enable job control
		wait
	fi

	} &>/dev/null

Reset()
	{

	ResetCachePath
	ResetReportsPath
	ResetArchivedLogs
	ArchiveActiveSessLog
	ResetActiveSessLog
	exit 0

	}

UpdateColourful()
	{

	# Input:
	# 	$1 = silent (optional): don't announce setting save.

	local a=''

	if [[ $switch_colour = true && -n $user_colourful_value ]]; then
		# Validate before saving.

		for a in true false; do
			[[ $a != "$user_colourful_value" ]] && continue

			useropt_colourful=$user_colourful_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Colourful "$useropt_colourful"
			else
				SaveSetting Colourful "$useropt_colourful" announce
			fi

			switch_colour=false

			return
		done

		ShowAsAbort "user setting '$user_colourful_value' is not 'true' or 'false'"
		run_package_actions=false

		return 1
	fi

	}

UpdateBranch()
	{

	# Input:
	# 	$1 = silent (optional): don't announce setting save.

	local a=''

	if [[ $switch_branch = true && -n $user_branch_value ]]; then
		# Validate before saving.

		for a in unstable stable; do
			[[ $a != "$user_branch_value" ]] && continue

			useropt_branch=$user_branch_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Git_Branch "$useropt_branch"
			else
				SaveSetting Git_Branch "$useropt_branch" announce

				Reset					# <-- Processing will terminate in this function (no-return).
			fi

			switch_branch=false

			return
		done

		ShowAsAbort "user setting '$user_branch_value' is not 'unstable' or 'stable'"
		run_package_actions=false

		return 1
	fi

	}

UpdateTerse()
	{

	# Input:
	# 	$1 = silent (optional): don't announce setting save.

	local a=''

	if [[ $switch_terse = true && -n $user_terse_value ]]; then
		# Validate before saving.

		for a in true false; do
			[[ $a != "$user_terse_value" ]] && continue

			useropt_terse=$user_terse_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Terse "$useropt_terse"
			else
				SaveSetting Terse "$useropt_terse" announce
			fi

			switch_terse=false

			return
		done

		ShowAsAbort "user setting '$user_terse_value' is not 'true' or 'false'"
		run_package_actions=false

		return 1
	fi

	}

SaveSetting()
	{

	# Save setting named as $1 with a value of $2 to persistent storage: /etc/config/qpkg.conf

	# Input:
	#   $1 = name
	# 	$2 = value
	# 	$3 = 'announce' (optional): display on-screen when setting has been saved.

	local a=${1:?${FUNCNAME[0]}'()': undefined name}
	local b=$(Lowercase "${2:?${FUNCNAME[0]}'()': undefined value}")

	case $b in
		true|false)
			b=$(Uppercase "$b")		# Convert these to uppercase to match QNAP-convention.
	esac

	/sbin/setcfg sherpa "$a" "$b" -f /etc/config/qpkg.conf

	[[ ${3:-} = announce ]] && ShowAsDone "user setting '$a = $b' has been saved"

	}

LoadSetting()
	{

	# Load setting named as $1 (with a default value of $2) from persistent storage: /etc/config/qpkg.conf

	# Input:
	#   $1 = name
	# 	$2 = default value

	local a=${1:?${FUNCNAME[0]}'()': undefined name}
	local b=$(Lowercase "${2:?${FUNCNAME[0]}'()': undefined default value}")

	Lowercase "$(/sbin/getcfg sherpa "$a" -d "$b" -f /etc/config/qpkg.conf)"

	}

DeleteSetting()
	{

	# Remove a setting named as $1 from persistent storage: /etc/config/qpkg.conf

	# Input:
	#   $1 = name

	local a=${1:?${FUNCNAME[0]}'()': undefined name}

	/sbin/setcfg -e sherpa "$a" -f /etc/config/qpkg.conf

	}

User.IsOk()
	{

	if ! User.IsSU; then
		if OS.IsSupportSudo; then
			ShowAsError 'this utility must be run with superuser privileges. Try again as:'
			echo "${CHARS_SUDO_PROMPT}sherpa $ARGS_RAW" >&2
		else
			ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
		fi

		return 1
	fi

	return 0

	}

User.IsSU()
	{

	[[ $EUID -eq 0 ]]

	}

DebugBinPathVerAndMinVer()
	{

	# Input:
	#	$1 = binary filename
	#	$2 = current version found
	#	$3 = minimum version required

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined filename} ]] || return

	local a=$(GetThisBinPath "$1")

	if [[ -n $a ]]; then
		DebugUserspace ok "'$1' path" "$a"
	else
		DebugUserspace warning "'$1' path" 'not present'
	fi

	if [[ -n ${2:-} && ${2:-undefined} != undefined ]]; then
		[[ -n ${3:-} && ${3:-undefined} != undefined ]] || return

		if [[ ${2//./} -ge ${3//./} ]]; then
			DebugUserspace ok "'$1' version" "$2"
		else
			DebugUserspace warning "'$1' version" "$2"
		fi
	else
		DebugUserspace warning "'$1' version" 'undefined'
	fi

	return 0

	}

IsSysFileExist()
	{

	# Input:
	#   $1 = pathfile to check

	# Output:
	#   $? = 0 (exists) or 1 (not exists)

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined pathfile} ]] || exit

	local a=${1%% *}		# Extract first word-group.

	if ! [[ -f $a || -L $a ]]; then
		ShowAsAbort "a required NAS system file is missing $(ShowAsFileName "$a")"

		return 1
	fi

	return 0

	}

IsNtSysFileExist()
	{

	# Input:
	#   $1 = pathfile to check

	# Output:
	#   $? = 0 (not exists) or 1 (exists)

	! IsSysFileExist "${1:?${FUNCNAME[0]}'()': undefined pathfile}"

	}

LenANSIDiff()
	{

	# Input:
	#   $1 = (optional) text to find length of

	local original=${1:-}
	local stripped=$(StripANSICodes "$original")

	echo -n "$((${#original}-${#stripped}))"

	return 0

	}

CalcMaxStatusReportCols()
	{

# 	local col1_width=$((${#CHARS_BULLET}+PACKAGE_NAME_COL_WIDTH))
# 	local col2_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_STATUS_COL_WIDTH))
	local col3_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_VER_COL_WIDTH))
# 	local col4_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_PATH_COL_WIDTH))

	# Add width to include " (new)" string to QPKG version title.

	if QPKGs-ISupgradable.IsAny; then
		package_ver_final_col_width=$((PACKAGE_VER_COL_WIDTH+6))
		((col3_width+6))
	else
		package_ver_final_col_width=$PACKAGE_VER_COL_WIDTH
	fi

# 	if [[ $((col1_width+col2_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=1
# 	elif [[ $((col1_width+col2_width+col3_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=2
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=3
# 	else
# 		report_max_cols=4
# 	fi

	return 0

	}

#CalcMaxDepsReportCols()
# 	{
#
# 	local col1_width=$((${#CHARS_BULLET}+PACKAGE_NAME_COL_WIDTH))
# 	local col2_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_DEPENDENCIES_COL_WIDTH))
# 	local col3_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_INSTALLED_COL_WIDTH))
# 	local col4_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_ENABLED_COL_WIDTH))
# 	local col5_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_MIN_RAM_COL_WIDTH))
# 	local col6_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_MIN_OS_COL_WIDTH))
# 	local col7_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_MAX_OS_COL_WIDTH))
# 	local col8_width=$((${#CHAR_SPACER}+${#CHARS_BULLET}+PACKAGE_ARCH_COL_WIDTH))
#
# 	if [[ $((col1_width+col2_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=1
# 	elif [[ $((col1_width+col2_width+col3_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=2
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=3
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width+col5_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=4
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width+col5_width+col6_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=5
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width+col5_width+col6_width+col7_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=6
# 	elif [[ $((col1_width+col2_width+col3_width+col4_width+col5_width+col6_width+col7_width+col8_width)) -ge $SESS_COLS ]]; then
# 		report_max_cols=7
# 	else
# 		report_max_cols=8
# 	fi
#
# 	return 0
#
# 	}

DisplayAsProjSynExam()
	{

	# Display as project syntax example.

	# Input:
	#	$1 = description
	#	$2 = example syntax

	printf "\n${CHARS_BULLET}%s" "$(Capitalise "${1:-}")"
	[[ ${1: -1} != '!' ]] && printf ':'

	printf "\n%${HELP_SYNTAX_INDENT}s${HELP_SYNTAX_SUDO_PREFIX}%s\n" '' "sherpa ${2:-}"

	}

DisplayAsProjSynIndentExam()
	{

	# Display as project syntax indented example.

	# Input:
	#	$1 = description
	#	$2 = example syntax

	if [[ -n $1	]]; then
		printf "\n%${HELP_DESC_INDENT}s%s" '' "$(Capitalise "${1:-}")"
		[[ ${1: -1} != '!' ]] && printf ':'
		printf '\n'
	fi

	printf "%${HELP_SYNTAX_INDENT}s${HELP_SYNTAX_SUDO_PREFIX}%s\n" '' "sherpa ${2:-}"

	}

DisplayAsSynExam()
	{

	# Display as syntax example.

	# Input:
	#	$1 = description
	#	$2 = example syntax

	printf "\n${CHARS_BULLET}%s:\n%${HELP_SYNTAX_INDENT}s${HELP_SYNTAX_PREFIX}%s\n" "$(Capitalise "${1:-}")" '' "${2:-}"

	}

DisplayAsPacksReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}QPKG name:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: application version

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}App version:"
		printf "%-$((PACKAGE_APP_VER_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 3: package description

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}Description:"
		printf "%-$((PACKAGE_DESCRIPTION_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsPacksReportItemLine()
	{

	# Input:
	#	$1 = package name

	local app_ver_msg=$CHARS_BLANK
# 	local author=$(QPKG.GetAuthor "$name")
# 	local author_msg=$CHARS_BLANK
	local description_msg=$CHARS_BLANK
	local mode=''
	local name=${1:?${FUNCNAME[0]}'()': undefined package name}
		local description=$(QPKG.GetDesc "$name")
		local notes=$(QPKG.GetNote "$name")
	local name_msg=$CHARS_NORMAL

	if QPKG.IsMissing "$name"; then
		mode=highlighted
	elif QPKG.IsNtInstalled "$name"; then
		mode=muted
	else
		mode=normal
	fi

	app_ver_msg+=$(QPKG.App.GetVer "$name")
# 	author_msg+=$author
	description_msg+="$(Capitalise "$description")."
	name_msg+=$name
	local notes_msg="${notes}."

	case $mode in
		muted)
			app_ver_msg=$(TextDarkGrey "$app_ver_msg")
# 			author_msg=$(TextDarkGrey "$author_msg")
			description_msg=$(TextDarkGrey "$description_msg")
			name_msg=$(TextDarkGrey "$name_msg")
			;;
		highlighted)
# 			[[ $author = missing ]] && author_msg=$(TextBrightRedBlink "${CHARS_ALERT}${author}")
			name_msg=$(TextBrightRed "$name_msg")
	esac

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$name_msg")))s" "$name_msg"
	fi

	# column 2: application version

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_APP_VER_COL_WIDTH+$(LenANSIDiff "$app_ver_msg")))s" "$app_ver_msg"
	fi

	# column 3: package description

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_DESCRIPTION_COL_WIDTH+$(LenANSIDiff "$description_msg")))s" "$description_msg"

		if [[ -n $notes ]]; then
			printf "\n%$((${#CHARS_BLANK}+PACKAGE_NAME_COL_WIDTH+PACKAGE_APP_VER_COL_WIDTH+(COLUMN_SPACING*2)))s$(TextBrightOrange "${CHARS_DROPEND}${CHARS_NOTE}")%s" '' "$notes_msg"
		fi
	fi

	printf '\n'

	}

DisplayAsStatusReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}QPKG name:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: package statuses

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}QPKG statuses:"
		printf "%-$((PACKAGE_STATUS_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 3: package version (variable-width)

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}QPKG version"
		QPKGs-ISupgradable.IsAny && a+=" ($(TextBrightOrange new))"
		a+=':'
		printf "%-$((${package_ver_final_col_width:=0}+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 4: application version

	if [[ $report_max_cols -ge 4 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}App version:"
		printf "%-$((PACKAGE_APP_VER_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 5: package installation path

	if [[ $report_max_cols -ge 5 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}QPKG installation path:"
		printf "%-$((PACKAGE_PATH_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsStatusReportItemLine()
	{

	# Input:
	#	$1 = package name

	local app_ver_msg=$CHARS_BLANK
	local mode=''
	local name=${1:?${FUNCNAME[0]}'()': undefined package name}
	local name_msg=$CHARS_BLANK
	local path_msg=$CHARS_BLANK
	local status=''
	local status_msg=''
	local upgrade_ver=''
	local ver_msg=$CHARS_BLANK

	if QPKG.IsMissing "$name"; then
		mode=highlighted
	elif QPKG.IsNtInstalled "$name"; then
		mode=muted
	else
		mode=normal
	fi

	case $mode in
		normal)
			# Limit statuses to two words only.

			# First word.

			if QPKGs-ISenabled.Exist "$name"; then
				status+=" $(TextBrightGreen enabled)"
			else
				status+=" $(TextBrightRed disabled)"
			fi

			# Second word.

			if QPKGs-ISactive.Exist "$name"; then
				status+=" $(TextBrightGreen active)"
			elif QPKGs-ISslow.Exist "$name"; then
				status+=" $(TextBrightOrange slow)"
			elif QPKGs-ISstarting.Exist "$name"; then
				status+=" $(TextBrightOrange starting)"
			elif QPKGs-ISstopping.Exist "$name"; then
				status+=" $(TextBrightOrange stopping)"
			elif QPKGs-ISrestarting.Exist "$name"; then
				status+=" $(TextBrightOrange restarting)"
			elif QPKGs-ISNTactive.Exist "$name"; then
				status+=" $(TextBrightRed inactive)"
			else
				status+=" $(TextBrightOrange unknown)"
			fi

			# Insert separators.

			if [[ -n $status ]]; then
				status=$(Trim "$status")
				status_msg=${status// /, }
			fi

			status_msg=${CHARS_NORMAL}${status_msg}
			QPKGs-ISupgradable.Exist "$name" && upgrade_ver=$(QPKG.Avail.GetVer "$name")
			ver_msg+=$(QPKG.Local.GetVer "$name")

			if [[ -n $upgrade_ver ]]; then
				ver_msg+=" ($(TextBrightOrange "$upgrade_ver"))"
				name_msg+=$(TextBrightOrange "$name")
			else
				name_msg+=$name
			fi

			app_ver_msg+=$(QPKG.App.GetVer "$name")
			path_msg+=$(QPKG.GetInstallationPath "$name")
			;;
		muted)
			name_msg+=$(TextDarkGrey "$name")

			if ! QPKG.IsArchOK "$name"; then
				status='incompatible arch'
				ver_msg=''
				app_ver_msg=''
			elif ! QPKG.IsMinOSVerOk "$name"; then
				status="incompatible $(GetQnapOS) version"
				ver_msg=''
				app_ver_msg=''
			elif ! QPKG.IsMinRAMOk "$name"; then
				status='insufficient RAM'
				ver_msg=''
				app_ver_msg=''
			else
				status='not installed'
				ver_msg+=$(TextDarkGrey "$(QPKG.Avail.GetVer "$name")")
				app_ver_msg+=$(TextDarkGrey "$(QPKG.App.GetVer "$name")")
			fi

			status_msg=$(TextDarkGrey "${CHARS_NORMAL}${status}")
			path_msg=''
			;;
		highlighted)
			name_msg+=$(TextBrightRed "$name")
			status_msg=$(TextBrightRedBlink "${CHARS_ALERT}missing")
			ver_msg+=$(TextBrightRed "$(QPKG.Local.GetVer "$name")")
			app_ver_msg+=$(TextBrightRed "$(QPKG.App.GetVer "$name")")
			path_msg=$(TextBrightRedBlink "${CHARS_ALERT}$(QPKG.GetInstallationPath "$name")")
	esac

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$name_msg")))s" "$name_msg"
	fi

	# column 2: package statuses

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_STATUS_COL_WIDTH+$(LenANSIDiff "$status_msg")))s" "$status_msg"
	fi

	# column 3: package version (variable-width)

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((${package_ver_final_col_width:=0}+$(LenANSIDiff "$ver_msg")))s" "$ver_msg"
	fi

	# column 4: application version

	if [[ $report_max_cols -ge 4 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_APP_VER_COL_WIDTH+$(LenANSIDiff "$app_ver_msg")))s" "$app_ver_msg"
	fi

	# column 5: package installation path

	if [[ $report_max_cols -ge 5 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_PATH_COL_WIDTH+$(LenANSIDiff "$path_msg")))s" "$path_msg"
	fi

	printf '\n'

	}

DisplayAsReposReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}QPKG name:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: package installation date

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}install date:"
		printf "%-$((PACKAGE_INSTALL_DATE_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 3: package repository

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}repository:"
		printf "%-$((PACKAGE_REPO_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsReposReportItemLine()
	{

	# Input:
	#	$1 = package name

	local assigned_repo_msg=$CHARS_NORMAL
	local install_date_msg=$CHARS_BLANK
	local mode=''
	local name=${1:?${FUNCNAME[0]}'()': undefined package name}
		local install_date=$(QPKG.GetInstallDate "$name")
		local store_id=$(QPKG.GetStoreID "$name")
			local assigned_repo=$(GetRepoURLFromStoreID "$store_id")
	local name_msg=$CHARS_BLANK

	if QPKG.IsMissing "$name"; then
		mode=highlighted
	elif QPKG.IsNtInstalled "$name"; then
		mode=muted
	else
		mode=normal
	fi

	if [[ $store_id = sherpa ]]; then
		assigned_repo=sherpa
		assigned_repo_msg+=$(TextBrightGreen "$assigned_repo")
	else
		assigned_repo_msg+=$assigned_repo
	fi

	case $mode in
		normal)
			name_msg+=$name

			case $install_date in
				sherpa)
					install_date_msg+=$(TextBrightGreen "$install_date")
					;;
				unassigned)
					install_date_msg+=$(TextBrightOrange "$install_date")
					;;
				*)
					install_date_msg+=$install_date
			esac
			;;
		muted)
			name_msg+=$(TextDarkGrey "$name")

			if ! QPKG.IsArchOK "$name"; then
				assigned_repo='incompatible arch'
			elif ! QPKG.IsMinOSVerOk "$name"; then
				assigned_repo="incompatible $(GetQnapOS) version"
			elif ! QPKG.IsMinRAMOk "$name"; then
				assigned_repo='insufficient RAM'
			else
				assigned_repo='not installed'
			fi

			install_date_msg+=$(TextDarkGrey "$assigned_repo")
			assigned_repo=''
			assigned_repo_msg=''
			;;
		highlighted)
			name_msg+=$(TextBrightRed "$name")
			install_date_msg+=$install_date
	esac

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$name_msg")))s" "$name_msg"
	fi

	# column 2: package installation date

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_INSTALL_DATE_COL_WIDTH+$(LenANSIDiff "$install_date_msg")))s" "$install_date_msg"
	fi

	# column 3: package repository

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_REPO_COL_WIDTH+$(LenANSIDiff "$assigned_repo_msg")))s" "$assigned_repo_msg"
	fi

	printf '\n'

	}

DisplayAsAbsReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}QPKG name:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: package abbreviations

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}acceptable QPKG name abbreviations and aliases:"
		printf "%-$((PACKAGE_ABBS_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsAbsReportItemLine()
	{

	# Input:
	#	$1 = package name

	local abs=''
	local abs_msg=$CHARS_NORMAL
	local mode=''
	local name=${1:?${FUNCNAME[0]}'()': undefined package name}
	local name_msg=$CHARS_BLANK

	if QPKG.IsMissing "$name"; then
		mode=highlighted
	elif QPKG.IsNtInstalled "$name"; then
		mode=muted
	else
		mode=normal
	fi

	abs=$(QPKG.GetAbbrvs "$name")

	if [[ -n $abs ]]; then
		abs=$(Trim "$abs"); abs=${abs// /, }	# insert separators
	fi

	case $mode in
		normal)
			abs_msg+=$abs
			name_msg+=$name
			;;
		muted)
			name_msg+=$(TextDarkGrey "$name")

			if ! QPKG.IsArchOK "$name"; then
				abs_msg+='(incompatible arch)'
			elif ! QPKG.IsMinOSVerOk "$name"; then
				abs_msg+="(incompatible $(GetQnapOS) version)"
			elif ! QPKG.IsMinRAMOk "$name"; then
				abs_msg+='(insufficient RAM)'
			else
				abs_msg+=$abs
			fi

			abs_msg=$(TextDarkGrey "$abs_msg")
			;;
		highlighted)
			abs_msg=$(TextBrightRedBlink "${CHARS_ALERT}${abs}")
			name_msg+=$(TextBrightRed "$name")
	esac

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$name_msg")))s" "$name_msg"
	fi

	# column 2: package repository

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_ABBS_COL_WIDTH+$(LenANSIDiff "$abs_msg")))s" "$abs_msg"
	fi

	printf '\n'

	}

DisplayAsDepsReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}QPKG name:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: package dependencies

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}dependencies:"
		printf "%-$((PACKAGE_DEPENDENCIES_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 3: QPKG is installed

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}installed?"
		printf "%-$((PACKAGE_INSTALLED_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 4: QPKG is enabled

	if [[ $report_max_cols -ge 4 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}enabled?"
		printf "%-$((PACKAGE_ENABLED_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 5: minimum NAS RAM required

	if [[ $report_max_cols -ge 5 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}min RAM:"
		printf "%-$((PACKAGE_MIN_RAM_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 6: minimum OS fimware version supported

	if [[ $report_max_cols -ge 6 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}min OS:"
		printf "%-$((PACKAGE_MIN_OS_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 7: maximum OS fimware version supported

	if [[ $report_max_cols -ge 7 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}max OS:"
		printf "%-$((PACKAGE_MAX_OS_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 8: arch is compatible

	if [[ $report_max_cols -ge 8 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}supported arch?"
		printf "%-$((PACKAGE_ARCH_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsDepsReportItemLine()
	{

	# Input:
	#	$1 = package name

	local dep=''
	local mode=''
	local name=${1:?${FUNCNAME[0]}'()': undefined package name}
		local package_deps_raw=$(QPKG.GetDependencies "$name")
		local package_max_os=$(QPKG.GetMaxOSVer "$name")
		local package_min_os=$(QPKG.GetMinOSVer "$name")
		local package_min_ram=$(QPKG.GetMinRAM "$name")
	local name_msg=$CHARS_BLANK
	local package_arch_msg=$CHARS_BLANK
	local package_deps=''
	local package_deps_msg=$CHARS_NORMAL
	local package_enabled_msg=$CHARS_BLANK
	local package_installed_msg=$CHARS_BLANK
	local package_max_os_msg=$CHARS_BLANK
	local package_min_os_msg=$CHARS_BLANK
	local package_min_ram_msg=$CHARS_BLANK

	[[ -z $package_deps_raw ]] && package_deps_raw=none
	[[ -n $package_max_os && $package_max_os != none && ${#package_max_os} -eq 3 ]] && package_max_os=${package_max_os:0:1}.${package_max_os:1:1}.${package_max_os:2:1}
	[[ -n $package_min_os && $package_min_os != none && ${#package_min_os} -eq 3 ]] && package_min_os=${package_min_os:0:1}.${package_min_os:1:1}.${package_min_os:2:1}
	[[ $package_min_ram != none ]] && package_min_ram=$(FormatAsThous "$package_min_ram")kB

	if QPKG.IsMissing "$name"; then
		mode=highlighted
	elif QPKG.IsNtInstalled "$name"; then
		mode=muted
	else
		mode=normal
	fi

	case $mode in
		normal)
			name_msg+=$name

			if [[ $package_deps_raw != none ]]; then
				for dep in $package_deps_raw; do
					[[ -n $package_deps ]] && package_deps+=' '

					if QPKG.IsInstalled "$dep" && QPKG.IsEnabled "$dep"; then
						package_deps+=$(TextBrightGreen "$dep")
					else
						package_deps+=$(TextBrightRed "$dep")
						package_deps_msg=$(TextBrightRed "$CHARS_ALERT")
						name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
					fi
				done
			else
				package_deps+=$(TextBrightGreen "$package_deps_raw")
			fi

			package_deps_msg+=${package_deps// /, }

			if QPKG.IsInstalled "$name"; then
				package_installed_msg+=$(TextBrightGreen true)
			else
				package_installed_msg+=false
			fi

			if QPKG.IsEnabled "$name"; then
				package_enabled_msg+=$(TextBrightGreen true)
			else
				package_enabled_msg=$(TextBrightRed "$CHARS_ALERT")
				package_enabled_msg+=$(TextBrightRed false)
				name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
			fi

			if QPKG.IsMinRAMOk "$name"; then
				package_min_ram_msg+=$(TextBrightGreen "$package_min_ram")
			else
				package_min_ram_msg=$(TextBrightRed "$CHARS_ALERT")
				package_min_ram_msg+=$(TextBrightRed "$package_min_ram")
				name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
			fi

			if QPKG.IsMinOSVerOk "$name"; then
				package_min_os_msg+=$(TextBrightGreen "$package_min_os")
			else
				package_min_os_msg=$(TextBrightRed "$CHARS_ALERT")
				package_min_os_msg+=$(TextBrightRed "$package_min_os")
				name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
			fi

			if QPKG.IsMaxOSVerOk "$name"; then
				package_max_os_msg+=$(TextBrightGreen "$package_max_os")
			else
				package_max_os_msg=$(TextBrightRed "$CHARS_ALERT")
				package_max_os_msg+=$(TextBrightRed "$package_max_os")
				name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
			fi

			if QPKG.IsArchOK "$name"; then
				package_arch_msg+=$(TextBrightGreen true)
			else
				package_arch_msg=$(TextBrightRed "$CHARS_ALERT")
				package_arch_msg+=$(TextBrightRed false)
				name_msg=${CHARS_BLANK}$(TextBrightRed "$name")
			fi
			;;
		muted)
			name_msg+=$(TextDarkGrey "$name")
			package_deps_msg=$(TextDarkGrey "$CHARS_NORMAL")

			if [[ $package_deps_raw != none ]]; then
				for dep in $package_deps_raw; do
					[[ -n $package_deps ]] && package_deps+=' '
					package_deps+=$(TextDarkGrey "$dep")
				done
			else
				package_deps+=$(TextDarkGrey "$package_deps_raw")
			fi


			package_deps_msg+=${package_deps// /$(TextDarkGrey ', ')}
			package_installed_msg+=$(TextDarkGrey false)
			package_enabled_msg+=$(TextDarkGrey 'N/A')

			if QPKG.IsMinRAMOk "$name"; then
				package_min_ram_msg+=$(TextDarkGrey "$package_min_ram")
			else
				package_min_ram_msg=$(TextBrightOrange "$CHARS_ATTENTION")
				package_min_ram_msg+=$(TextBrightOrange "$package_min_ram")
				name_msg=${CHARS_BLANK}$(TextBrightOrange "$name")
			fi

			if QPKG.IsMinOSVerOk "$name"; then
				package_min_os_msg+=$(TextDarkGrey "$package_min_os")
			else
				package_min_os_msg=$(TextBrightOrange "$CHARS_ATTENTION")
				package_min_os_msg+=$(TextBrightOrange "$package_min_os")
				name_msg=${CHARS_BLANK}$(TextBrightOrange "$name")
			fi

			if QPKG.IsMaxOSVerOk "$name"; then
				package_max_os_msg+=$(TextDarkGrey "$package_max_os")
			else
				package_max_os_msg=$(TextBrightOrange "$CHARS_ATTENTION")
				package_max_os_msg+=$(TextBrightOrange "$package_max_os")
				name_msg=${CHARS_BLANK}$(TextBrightOrange "$name")
			fi

			if QPKG.IsArchOK "$name"; then
				package_arch_msg+=$(TextDarkGrey true)
			else
				package_arch_msg=$(TextBrightOrange "$CHARS_ATTENTION")
				package_arch_msg+=$(TextBrightOrange false)
				name_msg=${CHARS_BLANK}$(TextBrightOrange "$name")
			fi
			;;
		highlighted)
			name_msg+=$(TextBrightRed "$name")

			if [[ $package_deps_raw != none ]]; then
				for dep in $package_deps_raw; do
					[[ -n $package_deps ]] && package_deps+=' '

					if QPKG.IsInstalled "$dep" && QPKG.IsEnabled "$dep"; then
						package_deps+=$(TextBrightGreen "$dep")
					else
						package_deps+=$(TextBrightRed "$dep")
					fi
				done
			else
				package_deps+=$(TextBrightGreen "$package_deps_raw")
			fi

			package_deps_msg+=${package_deps// /, }
			package_installed_msg=$(TextBrightRedBlink "$CHARS_ALERT")
			package_installed_msg+=$(TextBrightRedBlink 'missing')

			if QPKG.IsEnabled "$name"; then
				package_enabled_msg+=$(TextBrightGreen true)
			else
				package_enabled_msg=$(TextBrightRedBlink "$CHARS_ALERT")
				package_enabled_msg+=$(TextBrightRed 'false')
			fi

			if QPKG.IsMinRAMOk "$name"; then
				package_min_ram_msg+=$(TextBrightGreen "$package_min_ram")
			else
				package_min_ram_msg=$(TextBrightRed "$CHARS_ALERT")
				package_min_ram_msg+=$(TextBrightRed "$package_min_ram")
			fi

			if QPKG.IsMinOSVerOk "$name"; then
				package_min_os_msg+=$(TextBrightGreen "$package_min_os")
			else
				package_min_os_msg=$(TextBrightRed "$CHARS_ALERT")
				package_min_os_msg+=$(TextBrightRed "$package_min_os")
			fi

			if QPKG.IsMaxOSVerOk "$name"; then
				package_max_os_msg+=$(TextBrightGreen "$package_max_os")
			else
				package_max_os_msg=$(TextBrightRed "$CHARS_ALERT")
				package_max_os_msg+=$(TextBrightRed "$package_max_os")
			fi

			if QPKG.IsArchOK "$name"; then
				package_arch_msg+=$(TextBrightGreen true)
			else
				package_arch_msg=$(TextBrightRed "$CHARS_ALERT")
				package_arch_msg+=$(TextBrightRed false)
			fi
	esac

	# column 1: package name

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$name_msg")))s" "$name_msg"
	fi

	# column 2: package repository

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_DEPENDENCIES_COL_WIDTH+$(LenANSIDiff "$package_deps_msg")))s" "$package_deps_msg"
	fi

	# column 3: package installed?

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_INSTALLED_COL_WIDTH+$(LenANSIDiff "$package_installed_msg")))s" "$package_installed_msg"
	fi

	# column 4: package enabled?

	if [[ $report_max_cols -ge 4 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_ENABLED_COL_WIDTH+$(LenANSIDiff "$package_enabled_msg")))s" "$package_enabled_msg"
	fi

	# column 5: minimum NAS RAM required

	if [[ $report_max_cols -ge 5 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_MIN_RAM_COL_WIDTH+$(LenANSIDiff "$package_min_ram_msg")))s" "$package_min_ram_msg"
	fi

	# column 6: minimum OS fimware version supported

	if [[ $report_max_cols -ge 6 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_MIN_OS_COL_WIDTH+$(LenANSIDiff "$package_min_os_msg")))s" "$package_min_os_msg"
	fi

	# column 7: maximum OS fimware version supported

	if [[ $report_max_cols -ge 7 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_MAX_OS_COL_WIDTH+$(LenANSIDiff "$package_max_os_msg")))s" "$package_max_os_msg"
	fi

	# column 8: arch is compatible?

	if [[ $report_max_cols -ge 8 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((PACKAGE_ARCH_COL_WIDTH+$(LenANSIDiff "$package_arch_msg")))s" "$package_arch_msg"
	fi

	printf '\n'

	}

DisplayAsBacksReportTitleLine()
	{

	local a=''

	printf '\n'

	# column 1: backup filename

	if [[ $report_max_cols -ge 1 ]]; then
		a="${CHARS_BULLET}Backup file:"
		printf "%-$((FILE_NAME_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 2: filesize in bytes

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}size in bytes:"
		printf "%-$((FILE_BYTES_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	# column 3: last backup date

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		a="${CHARS_BULLET}last backup date:"
		printf "%-$((FILE_CHANGE_DATE_COL_WIDTH+2+$(LenANSIDiff "$a")))s" "$a"
	fi

	printf '\n'

	}

DisplayAsBacksReportItemLine()
	{

	# Input:
	#	$1 = last backup date in epoch seconds
	#	$2 = backup filename
	#	$3 = filesize in bytes
	#	$4 = age threshold to highlight (optional) '1 week ago' (default)		e.g. '2 days ago', '2 weeks ago', etc..

	local epoch_time=${1:-0}
	local epoch_time_msg=$CHARS_NORMAL
	local file_bytes=${3:-0}
	local file_bytes_msg=$CHARS_BLANK
	local file_name=${2:-}
	local file_name_msg=$CHARS_BLANK
	local highlight_older_than=${4:-'1 week ago'}
	local mode=''

	if [[ ${epoch_time%.*} -lt $(/bin/date --date="$highlight_older_than" +%s) ]]; then
		mode=highlighted
	else
		mode=normal
	fi

	case $mode in
		normal)
			epoch_time_msg+=$(/bin/date -d @"$epoch_time" +%c)
			file_bytes_msg+=$file_bytes
			file_name_msg+=$file_name
			;;
		highlighted)
			epoch_time_msg+=$(TextBrightRed "$(/bin/date -d @"$epoch_time" +%c)")
			file_bytes_msg+=$(TextBrightRed "$file_bytes")
			file_name_msg+=$(TextBrightRed "$file_name")
	esac

	# column 1: backup filename

	if [[ $report_max_cols -ge 1 ]]; then
		printf "%-$((FILE_NAME_COL_WIDTH+$(LenANSIDiff "$file_name_msg")))s" "$file_name_msg"
	fi

	# column 2: filesize in bytes

	if [[ $report_max_cols -ge 2 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%$((FILE_BYTES_COL_WIDTH+$(LenANSIDiff "$file_bytes_msg")))s" "$file_bytes_msg "	# append 1 x whitespace char to force right-justified numbers to the left a bit. Looks nicer.
	fi

	# column 3: last backup date

	if [[ $report_max_cols -ge 3 ]]; then
		printf "%$((COLUMN_SPACING))s"
		printf "%-$((FILE_CHANGE_DATE_COL_WIDTH+$(LenANSIDiff "$epoch_time_msg")))s" "$epoch_time_msg"
	fi

	printf '\n'

	}

DisplayAsHelpTitle()
	{

	# Input:
	#	$1 = text

	printf "\n${CHARS_BULLET}%s\n" "$(Capitalise "${1:-}" | tr -s ' ')"

	}

DisplayAsHelpTitleHighlighted()
	{

	# Input:
	#	$1 = text

	# shellcheck disable=2059
	printf "\n$(TextBrightOrange "${CHARS_BULLET}%s\n")" "$(Capitalise "${1:-}")"

	}

DisplayAsIndentActionResultDurationReason()
	{

	# Input:
	#	$1 = action
	#	$2 = result message
	#	$3 = duration in milliseconds (optional)
	#	$4 = reason message (optional)

	[[ -n ${1:-} && -n ${2:-} ]] || return

	local action=''
	local duration=''

	case $1 in
		disableau)
			action='disable auto-update'
			;;
		enableau)
			action='enable auto-update'
			;;
		*)
			action=$1
	esac

	[[ -n ${3:-} ]] && duration=$(FormatMillisecsToMinutesSecs "$3")

	printf "%${ACTION_RESULT_INDENT}s" ''

	if [[ -z ${4:-} ]]; then
		printf "%s %s%s" "$(Lowercase "$action")" "$2" "$([[ -n $duration ]] && printf ' in %s' "$duration")"
	else
		printf "%s %s%s (%s)" "$(Lowercase "$action")" "$2" "$([[ -n $duration ]] && printf ' in %s' "$duration")" "$4"
	fi

	printf '\n'

	}

EraseThisLine()
	{

	# Reset cursor to start-of-line, erasing entire line, and stay on this line.

	[[ ${useropt_verbose:=false} = false ]] && printf '\033[2K\r'

	} >&2

Display()
	{

	if [[ -z ${1:-} ]]; then
		printf '\n'
	else
		printf '%s\n' "$1"
	fi

	}

DisplayWait()
	{

	printf '%s' "${1:-}"

	}

Help.Actions:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport actions

		{

		Help.Basic:Show
		DisplayAsHelpTitle "$(ShowAsAction) usage examples:"
		DisplayAsProjSynIndentExam 'activate these packages (this will upgrade internal applications where-supported)' "activate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "start $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'backup these application configurations to the backup location' "backup $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'check all application dependencies are installed' check
		DisplayAsProjSynIndentExam '' c
		DisplayAsProjSynIndentExam 'clean local repository files from these packages (your config is safe, application files will be downloaded again)' "clean $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'deactivate these packages' "deactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "stop $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'generate QPKG dependencies report' dependencies
		DisplayAsProjSynIndentExam '' d
		DisplayAsProjSynIndentExam 'disable these packages. This will prevent them being activated' "disable $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'disable auto-updating the application on package activation (where-supported)' "disable-auto-update $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'enable these packages. Packages must be enabled before they can be activated' "enable $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'enable auto-updating the application on package activation (where-supported)' "enable-auto-update $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'install these packages' "install $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "add $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'show application backup files' 'show backups'
		DisplayAsProjSynIndentExam '' b
# 		DisplayAsProjSynIndentExam "list $(ShowAsTitleName) object version numbers" 'list versions'
		DisplayAsProjSynIndentExam 'reactivate these packages (this will upgrade internal applications where-supported)' "reactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "restart $(ShowAsPackages)"
		DisplayAsProjSynIndentExam "reassign packages to $(ShowAsTitleName). Detach packages previously installed via an online repository from further management by that repository" "reassign $(ShowAsPackages)"
		DisplayAsProjSynIndentExam "rebuild these packages ('install' packages, then 'restore' configuration backups)" "rebuild $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'reinstall these packages' "reinstall $(ShowAsPackages)"
# 		DisplayAsProjSynIndentExam 'generate QPKG repository assignments report' repos
# 		DisplayAsProjSynIndentExam '' r
		DisplayAsProjSynIndentExam 'restore these application configurations from the backup location' "restore $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'digitally "sign" these QPKGs' "sign $(ShowAsPackages)"
# 		DisplayAsProjSynIndentExam 'generate QPKG status report' status
# 		DisplayAsProjSynIndentExam '' s
		DisplayAsProjSynIndentExam 'uninstall these packages' "uninstall $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "remove $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "rm $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'upgrade these packages (this will upgrade internal applications where-supported)' "upgrade $(ShowAsPackages)"

		DisplayAsProjSynExam "$(ShowAsAction)s to affect all packages can be seen with" 'help all-actions'
		DisplayAsProjSynIndentExam '' 'help actions-all'
		DisplayAsProjSynExam "multiple $(ShowAsAction)s are supported like this" "$(ShowAsAction) $(ShowAsPackages) $(ShowAsAction) $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' 'install sabnzbd sickgear reactivate transmission uninstall lazy nzbget upgrade nzbtomedia'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.ActionsAll:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport 'all actions'

		{

		Help.Basic:Show
		DisplayAsHelpTitle "the 'all' group applies to all QPKGs. If $(ShowAsAction) is 'install all' then all available QPKGs will be installed."
		DisplayAsHelpTitle "$(ShowAsAction) $(ShowAsPackageGroup) usage examples:"
		DisplayAsProjSynIndentExam 'activate all QPKGs (this will upgrade internal applications where-supported)' 'activate all'
		DisplayAsProjSynIndentExam '' 'start all'
		DisplayAsProjSynIndentExam 'backup all application configurations to the backup location' 'backup all'
		DisplayAsProjSynIndentExam 'clean local repository files from all QPKGs (your configs are safe, application files will be downloaded again)' 'clean all'
		DisplayAsProjSynIndentExam 'deactivate all QPKGs' 'deactivate all'
		DisplayAsProjSynIndentExam '' 'stop all'
		DisplayAsProjSynIndentExam 'disable all QPKGs. This will prevent them being activated' 'disable all'
		DisplayAsProjSynIndentExam 'disable auto-updating all applications on QPKG activation (where-supported)' 'disable-auto-update all'
		DisplayAsProjSynIndentExam 'enable all QPKGs. QPKGs must be enabled before they can be started' 'enable all'
		DisplayAsProjSynIndentExam 'enable auto-updating all applications on QPKG activation (where-supported)' 'enable-auto-update all'
		DisplayAsProjSynIndentExam 'install everything!' 'install all'
		DisplayAsProjSynIndentExam 'reactivate installed QPKGs (this will upgrade internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam '' 'restart all'
		DisplayAsProjSynIndentExam "reassign all QPKGs to $(ShowAsTitleName). Detach QPKGs previously installed via an online repository from further management by that repository" 'reassign all'
		DisplayAsProjSynIndentExam "rebuild all QPKGs where backup files exist ('install' QPKGs and 'restore' backups)" 'rebuild all'
		DisplayAsProjSynIndentExam 'reinstall all QPKGs' 'reinstall all'
		DisplayAsProjSynIndentExam 'restore all application configurations from the backup location' 'restore all'
		DisplayAsProjSynIndentExam 'digitally "sign" all QPKGs' 'sign all'
		DisplayAsProjSynIndentExam 'find the live status of each application in all QPKGs' 'status all'
		DisplayAsProjSynIndentExam 'uninstall all QPKGs' 'uninstall all'
		DisplayAsProjSynIndentExam 'upgrade all QPKGs (and internal applications where-supported)' 'upgrade all'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.BackupLocation:Show()
	{

	DisplayAsSynExam 'the backup location can be accessed by running' "cd $QPKG_BU_PATH"

	return 0

	}

Help.Basic:Show()
	{

	DisplayAsHelpTitle "usage: sherpa $(ShowAsAction) $(ShowAsPackages) $(ShowAsPackageGroup) $(ShowAsOptions)"

	return 0

	}

Help.Basic.Examples:Show()
	{

	DisplayAsProjSynIndentExam "to see available $(ShowAsAction)s" 'help actions'
	DisplayAsProjSynIndentExam "to see available $(ShowAsPackages)" 'show packages'
	DisplayAsProjSynIndentExam '' p
	DisplayAsProjSynIndentExam "to see available $(ShowAsPackageGroup)s" 'help groups'
	DisplayAsProjSynIndentExam "or, for more $(ShowAsOptions)" 'help options'
	DisplayAsHelpTitle "more in the wiki: $(ShowAsURL 'https://github.com/OneCDOnly/sherpa/wiki')"

	Display

	return 0

	}

Help.Groups:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport groups

		{

		Help.Basic:Show
		DisplayAsHelpTitle "$(ShowAsPackageGroup) usage examples:"
		DisplayAsProjSynIndentExam 'select every package' "$(ShowAsAction) all"
		DisplayAsProjSynIndentExam 'select only independent QPKGs (these do not depend on other QPKGs)' "$(ShowAsAction) independent"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) independents"
		DisplayAsProjSynIndentExam 'select only dependent QPKGs (these require another QPKG to be installed and active)' "$(ShowAsAction) dependent"
		DisplayAsProjSynIndentExam 'select only active QPKGs' "$(ShowAsAction) active"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) started"
		DisplayAsProjSynIndentExam 'select only inactive QPKGs' "$(ShowAsAction) inactive"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) stopped"
		DisplayAsProjSynIndentExam 'select only installed QPKGs' "$(ShowAsAction) installed"
		DisplayAsProjSynIndentExam 'select only QPKGs that are not installed' "$(ShowAsAction) not-installed"
		DisplayAsProjSynIndentExam 'select only QPKGs that are backed-up' "$(ShowAsAction) backedup"
		DisplayAsProjSynIndentExam 'select only QPKGs that are not backed-up' "$(ShowAsAction) not-backedup"
		DisplayAsProjSynIndentExam 'select only QPKGs that are upgradable' "$(ShowAsAction) upgradable"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) new"
		DisplayAsProjSynIndentExam 'select only missing QPKGs (these are partly installed and broken)' "$(ShowAsAction) missing"
		DisplayAsProjSynExam 'multiple groups are supported like this' "$(ShowAsAction) $(ShowAsPackageGroup) $(ShowAsPackageGroup)"

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Issue:Show()
	{

	DisplayAsHelpTitle "please consider creating a new issue for this on GitHub: $(ShowAsURL 'https://github.com/OneCDOnly/sherpa/issues')"
	DisplayAsHelpTitle "alternatively, post on the QNAP NAS Community Forum: $(ShowAsURL 'https://forum.qnap.com/viewtopic.php?f=320&t=132373')"
	DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
	DisplayAsProjSynIndentExam "view the entire $(ShowAsTitleName) session log" log
	DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
	DisplayAsHelpTitleHighlighted "if you need help, please include a copy of your $(ShowAsTitleName) $(TextBrightOrange 'log for analysis!')"

	Display

	return 0

	}

Help.Lists:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport lists

		{

		Help.Basic:Show
		DisplayAsHelpTitle "'list' usage examples:"
		DisplayAsProjSynIndentExam 'list all available QPKGs' 'list all'
# 		DisplayAsProjSynIndentExam 'list package backup files' 'list backups'
# 		DisplayAsProjSynIndentExam '' b
		DisplayAsProjSynIndentExam 'list only QPKGs that can be installed' 'list installable'
		DisplayAsProjSynIndentExam '' installable
		DisplayAsProjSynIndentExam 'list only installed QPKGs' 'list installed'
		DisplayAsProjSynIndentExam '' installed
		DisplayAsProjSynIndentExam 'list only QPKGs that are not installed' 'list not-installed'
		DisplayAsProjSynIndentExam '' not-installed
		DisplayAsProjSynIndentExam 'list only upgradable QPKGs' 'list upgradable'
		DisplayAsProjSynIndentExam '' upgradable
		DisplayAsProjSynIndentExam "list $(ShowAsTitleName) object version numbers" 'list versions'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Report.Results:Show()
	{

	# Input:
	#	$1 = `ok`, `skipped`, `failed`

	local action=''
	local -i datetime=0
	local -i duration=0
	local found=false
	local package_name=''
	local package_type=''
	local plural='these actions'
	local reason=''
	local result=''
	local singular='this action'

		{

		if [[ -e $SESS_ACTION_RESULTS_PATHFILE ]]; then
			local IFS='|'

			while read -r datetime action package_name result duration reason package_type; do
				if [[ $display_last_action_datetime = true ]]; then
					DisplayAsHelpTitle "the following package actions were run: $(/bin/date -d @"$datetime")"
					display_last_action_datetime=false
				fi

				if [[ $result = "$1" ]] || [[ $1 = skipped && ($result = 'skipped-ok' || $result = 'skipped-error' || $result = 'skipped-abort') ]]; then
					[[ $action = status && $useropt_show_results = false ]] && continue		# Don't need to see the result of `status` checks unless a 'results' report has been requested.

					case $result in
						ok)
							[[ $found = false ]] && DisplayAsHelpTitle "$plural completed $(TextBrightGreen OK):"
							;;
						skipped*)
							[[ $found = false ]] && DisplayAsHelpTitle "$plural were $(TextBrightOrange skipped) (and why):"
							;;
						failed)
							[[ $found = false ]] && DisplayAsHelpTitle "$plural $(TextBrightRed failed) (and why):"
					esac

					ShowAsActionLogDetail "$datetime" "$package_name" "$action" "$result" "$duration" "$reason"
					found=true
				fi
			done < "$SESS_ACTION_RESULTS_PATHFILE"
		fi

		if [[ $found = false ]]; then
			case $1 in
				ok)
					DisplayAsHelpTitle "no package actions completed $(TextBrightGreen OK)."
					;;
				skipped)
					DisplayAsHelpTitle "no package actions were $(TextBrightOrange skipped)."
					;;
				failed)
					DisplayAsHelpTitle "no package actions $(TextBrightRed failed)."
			esac
		fi

		} > "$REPORT_OUTPUT_PATHFILE"

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		$CAT_CMD "$REPORT_OUTPUT_PATHFILE"
	fi

	return 0

	}

Help.Show:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport show

		{

		Help.Basic:Show
		DisplayAsHelpTitle "'show' usage examples:"
		DisplayAsProjSynIndentExam 'show QPKG abbreviations' 'show abbreviations'
		DisplayAsProjSynIndentExam '' 'show abs'
		DisplayAsProjSynIndentExam '' a
		DisplayAsProjSynIndentExam 'show application backup files' 'show backups'
		DisplayAsProjSynIndentExam '' b
		DisplayAsProjSynIndentExam 'show QPKG dependency report' 'show dependencies'
		DisplayAsProjSynIndentExam '' 'show deps'
		DisplayAsProjSynIndentExam '' d
		DisplayAsProjSynIndentExam 'show QPKG repository assignments report' 'show repositories'
		DisplayAsProjSynIndentExam '' 'show repos'
		DisplayAsProjSynIndentExam '' r
		DisplayAsProjSynIndentExam 'show last session action results' 'show results'
		DisplayAsProjSynIndentExam '' results
		DisplayAsProjSynIndentExam 'find the live status of each application in all QPKGs' 'show status'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Options:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport options

		{

		Help.Basic:Show
		DisplayAsHelpTitle "$(ShowAsOptions) usage examples:"
		DisplayAsProjSynIndentExam 'show live debugging information, and record it to file' "$(ShowAsAction) $(ShowAsPackages) verbose"
		DisplayAsProjSynIndentExam '' v
		DisplayAsProjSynIndentExam 'record debugging information to file-only' "$(ShowAsAction) $(ShowAsPackages) debug"

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Packages:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport packages

		{

		Help.Basic:Show
		DisplayAsHelpTitle 'usage examples for QPKGs will go here:'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Problems:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport problems

		{

		Help.Basic:Show
		DisplayAsHelpTitle 'usage examples for dealing with problems:'
		DisplayAsProjSynIndentExam 'activate these QPKGs' "activate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'ensure all dependencies exist for installed QPKGs' check
		DisplayAsProjSynIndentExam '' c
		DisplayAsProjSynIndentExam 'clear local repository files from these QPKGs' "clean $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'deactivate these QPKGs' "deactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'record debugging information to file-only' "$(ShowAsAction) $(ShowAsPackages) debug"
		DisplayAsProjSynIndentExam "increase the default 'qpkg_service' timeouts from 3 minutes to 30 minutes" 'install increasetimeouts'
		DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
		DisplayAsProjSynIndentExam '' l
		DisplayAsProjSynIndentExam "view the entire $(ShowAsTitleName) session log" log
		DisplayAsProjSynIndentExam "upload the most-recent session in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste last'
		DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
		DisplayAsProjSynIndentExam 'reactivate installed QPKGs (upgrades internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam "remove all cached $(ShowAsTitleName) items and logs" reset
		DisplayAsProjSynIndentExam 'find the live status of each application in these QPKGs' "status $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "s $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'show live debugging information, and record it to file' "$(ShowAsAction) $(ShowAsPackages) verbose"
		DisplayAsProjSynIndentExam '' v
		DisplayAsHelpTitleHighlighted "if you need help, please include a copy of your $(ShowAsTitleName) $(TextBrightOrange "log for analysis!")"

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Upgrades:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport upgrades

		{

		Help.Basic:Show
		DisplayAsHelpTitle 'usage examples for upgrading your QPKGs:'
		DisplayAsProjSynIndentExam 'upgrade only the upgradable QPKGs' 'upgrade upgradable'
		DisplayAsProjSynIndentExam '' 'upgrade new'
		DisplayAsProjSynIndentExam 'show a list of upgradable QPKGs' 'list upgradable'
		DisplayAsProjSynIndentExam '' 'list new'
		DisplayAsProjSynIndentExam 'find the live application status of upgradable QPKGs' 'status upgradable'
		DisplayAsProjSynIndentExam '' 's upgradable'
		DisplayAsProjSynIndentExam '' 's new'

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Help.Tips:Show()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport tips

		{

		Help.Basic:Show
		DisplayAsHelpTitle 'helpful tips and shortcuts:'
		DisplayAsProjSynIndentExam "install all available $(ShowAsTitleName) QPKGs" 'install all'
		DisplayAsProjSynIndentExam 'package abbreviations and aliases also work. To see these' 'help abs'
		DisplayAsProjSynIndentExam '' a
		DisplayAsProjSynIndentExam 'reactivate all QPKGs (upgrades internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam 'list only QPKGs that can be installed' 'list installable'
		DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
		DisplayAsProjSynIndentExam '' l
		DisplayAsProjSynIndentExam 'activate all inactive QPKGs' 'activate inactive'
		DisplayAsProjSynIndentExam 'upgrade the internal applications only' "reactivate $(ShowAsPackages)"
		Help.BackupLocation:Show

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	return 0

	}

Log.Last:View()
	{

	# View only the last session log.

	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail
	EraseThisLine

	if [[ -e $SESS_LAST_PATHFILE ]]; then
		DisplayFileInViewport "$SESS_LAST_PATHFILE" linenumbers
		Display
	else
		ShowAsError 'no last session log to display'
	fi

	return 0

	}

Log.Tail:View()
	{

	# View only the last session log.

	DisableDebugToArchiveAndFile
	ExtractTailFromLog
	EraseThisLine

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		DisplayFileInViewport "$SESS_TAIL_PATHFILE" linenumbers
		Display
	else
		ShowAsError 'no session log tail to display'
	fi

	return 0

	}

DisplayFileInViewport()
	{

	# Input:
	# 	$1 = pathfile to display
	# 	$2/$3/$4 (optional, and in any order)
	#		= 'linenumbers' : display file contents with line numbers.
	#		= 'jumptoend'   : display file contents scrolled to the last line.
	#		= 'wrap'		: wrap lines of text to displayport.

	local filename=${1:-}
	local jumptoend=false
	local options=''
	local prompt=' use arrow-keys to scroll up-down & left-right, press Q to quit '
	local showlinenumbers=false
	local wraplines=false

	if [[ ! -e $filename ]]; then
		echo "filename '$filename' not found"

		return 1
	fi

	case 'linenumbers' in
		${2:-}|${3:-}|${4:-})
			showlinenumbers=true
	esac

	case 'jumptoend' in
		${2:-}|${3:-}|${4:-})
			jumptoend=true
	esac

	case 'wrap' in
		${2:-}|${3:-}|${4:-})
			wraplines=true
	esac

	if [[ $useropt_verbose = true ]]; then
		if [[ -e $CAT_CMD ]]; then
			$CAT_CMD "$filename"

			return
		else
			echo "$(<$1)"

			return
		fi
	fi

	if [[ $($WC_CMD -l < "$filename") -ge $SESS_ROWS ]]; then
		if [[ -e $GNU_LESS_CMD ]]; then
			options=' --quit-on-intr --tilde --mouse --RAW-CONTROL-CHARS --shift 4 --redraw-on-quit --quit-if-one-screen'
			[[ $wraplines = false ]] && options+=' --chop-long-lines'
			[[ $showlinenumbers = true ]] && options+=' --LINE-NUMBERS'
			[[ $jumptoend = true ]] && options+=' +G'
			LESSSECURE=1 ${GNU_LESS_CMD}${options} --prompt "$prompt" "$filename"

			return
		fi

		if [[ -e $LESS_CMD ]]; then
			options=' -~'
			[[ $wraplines = false ]] && options+='S'
			[[ $showlinenumbers = true ]] && options+='N'
			${LESS_CMD}${options} "$filename"

			return
		fi
	fi

	if [[ -e $CAT_CMD ]]; then
		[[ $showlinenumbers = true ]] && options+=' --number'
		${CAT_CMD}${options} "$filename"

		return
	elif [[ -e $MORE_CMD ]]; then
		$MORE_CMD "$filename"

		return
	fi

	# and, when there's really no-better option ...

	echo "$(<$1)"

	}

Log.Last:Paste()
	{

	local link=''

	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail

	if [[ -e $SESS_LAST_PATHFILE ]]; then
		if Quiz "Press 'Y' to post the most-recent session in your $(ShowAsTitleName) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "upload $(ShowAsTitleName) log"

			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$SESS_LAST_PATHFILE" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(ShowAsTitleName) log is now online at $(ShowAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(ShowAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_zero_qpkgs=false

			return 1
		fi
	else
		ShowAsError 'no last session log found'
	fi

	return 0

	}

Log.Tail:Paste()
	{

	local link=''

	DisableDebugToArchiveAndFile
	ExtractTailFromLog

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		if Quiz "Press 'Y' to post the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(ShowAsTitleName) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "upload $(ShowAsTitleName) log"

			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$SESS_TAIL_PATHFILE" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(ShowAsTitleName) log is now online at $(ShowAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(ShowAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_zero_qpkgs=false

			return 1
		fi
	else
		ShowAsError 'no session log tail found'
	fi

	return 0

	}

GetLogSessStartLine()
	{

	# Input:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*started:' "$SESS_TAIL_PATHFILE" | $TAIL_CMD -n${1:-1} | $HEAD_CMD -n1 | cut -d':' -f1)-1))
	[[ $linenum -lt 1 ]] && linenum=1
	echo -n "$linenum"

	}

GetLogSessFinishLine()
	{

	# Input:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*finished:' "$SESS_TAIL_PATHFILE" | $TAIL_CMD -n${1:-1} | cut -d':' -f1)+2))
	[[ $linenum -eq 2 ]] && linenum=3
	echo -n "$linenum"

	}

ArchiveActiveSessLog()
	{

	[[ -n ${sess_active_pathfile:-} && -e $sess_active_pathfile ]] && $CAT_CMD "$sess_active_pathfile" >> "$SESS_ARCHIVE_PATHFILE"

	}

ArchivePriorSessLogs()
	{

	# Check for incomplete previous session logs (crashed, interrupted?) and save to archive.

	local f=''

	for f in "$THIS_PACKAGE_PATH"/session.*.active.log; do
		if [[ -f $f && $f != "$sess_active_pathfile" ]]; then
			$CAT_CMD "$f" >> "$SESS_ARCHIVE_PATHFILE"
			rm -f "$f"
		fi
	done

	}

ResetActiveSessLog()
	{

	rm -f "$sess_active_pathfile"

	}

ExtractPrevSessFromTail()
	{

	local -i end_line=0
	local -i old_session=1
	local -i old_session_limit=12		# Don't try to find "started:" further back than this many sessions.
	local -i start_line=0

	ExtractTailFromLog

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		end_line=$(GetLogSessFinishLine "$old_session")
		start_line=$((end_line+1))		# Ensure an invalid condition, to be solved by the loop.

		while [[ $start_line -ge $end_line ]]; do
			start_line=$(GetLogSessStartLine "$old_session")

			((old_session++))
			[[ $old_session -gt $old_session_limit ]] && break
		done

		$SED_CMD "$start_line,$end_line!d" "$SESS_TAIL_PATHFILE" > "$SESS_LAST_PATHFILE"
	else
		rm -f "$SESS_LAST_PATHFILE"
	fi

	return 0

	}

ExtractTailFromLog()
	{

	if [[ -e $SESS_ARCHIVE_PATHFILE ]]; then
		$TAIL_CMD -n${LOG_TAIL_LINES} "$SESS_ARCHIVE_PATHFILE" > "$SESS_TAIL_PATHFILE"	# Trim main log first so there's less to `grep`.
	else
		rm -f "$SESS_TAIL_PATHFILE"
	fi

	return 0

	}

Report.Versions:Show()
	{

	DisableDebugToArchiveAndFile
	EraseThisLine

	Display "QPKG: ${THIS_PACKAGE_VER:-undefined}"
	Display "manager: ${THIS_SCRIPT_VER:-undefined}"
	Display "loader: ${LOADER_SCRIPT_VER:-undefined}"
	Display "objects: ${OBJECTS_VER:-undefined}"
	Display "packages: ${PACKAGES_VER:-undefined}"

	return 0

	}

InitForkCounts()
	{

	# Create directories so background processes can be monitored.

	MakePath "$ACTION_FORKS_COUNT" 'action forks'
	proc_counts_path=$($MKTEMP_CMD -d "$ACTION_FORKS_COUNT"/"${FUNCNAME[1]}"_XXXXXX)
	[[ -n ${proc_counts_path:?undefined proc counts path} ]] || return

	EraseForkCountPaths

	proc_fork_count_path=$proc_counts_path/fork.count
	proc_ok_count_path=$proc_counts_path/ok.count
	proc_skip_count_path=$proc_counts_path/skip.count
	proc_skip_ok_count_path=$proc_counts_path/skip.ok.count
	proc_skip_error_count_path=$proc_counts_path/skip.error.count
	proc_skip_abort_count_path=$proc_counts_path/skip.abort.count
	proc_fail_count_path=$proc_counts_path/fail.count

	mkdir -p "$proc_fork_count_path"
	mkdir -p "$proc_ok_count_path"
	mkdir -p "$proc_skip_count_path"
	mkdir -p "$proc_skip_ok_count_path"
	mkdir -p "$proc_skip_error_count_path"
	mkdir -p "$proc_skip_abort_count_path"
	mkdir -p "$proc_fail_count_path"

	InitProgress

	}

IncForkProgressIndex()
	{

	((progress_index++))
	local a=$(printf '%02d' "$progress_index")

	proc_fork_pathfile=$proc_fork_count_path/$a
	proc_ok_pathfile=$proc_ok_count_path/$a
	proc_skip_pathfile=$proc_skip_count_path/$a
	proc_skip_ok_pathfile=$proc_skip_ok_count_path/$a
	proc_skip_error_pathfile=$proc_skip_error_count_path/$a
	proc_skip_abort_pathfile=$proc_skip_abort_count_path/$a
	proc_fail_pathfile=$proc_fail_count_path/$a

	}

RefreshForkCounts()
	{

	fork_count=$(ls -A -1 "$proc_fork_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	ok_count=$(ls -A -1 "$proc_ok_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_count=$(ls -A -1 "$proc_skip_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_ok_count=$(ls -A -1 "$proc_skip_ok_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_error_count=$(ls -A -1 "$proc_skip_error_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_abort_count=$(ls -A -1 "$proc_skip_abort_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	fail_count=$(ls -A -1 "$proc_fail_count_path" 2>/dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')

	} &>/dev/null

EraseForkCountPaths()
	{

	ClearPath /var/run/sherpa/actions/forks "$proc_counts_path"
	[[ -e $ACTION_ABORT_PATHFILE ]] && rm -f "$ACTION_ABORT_PATHFILE"

	} &>/dev/null

InitProgress()
	{

	progress_index=0
	prev_clean_msg=''

	RefreshForkCounts

	}

UpdateForkProgress()
	{

	# All input vars are global.

	local a=''
	local b=''

	RefreshForkCounts
	[[ $useropt_verbose = false && ! -e $DISPLAY_INHIBIT_PATHFILE ]] || return		# Don't display progress, it's difficult to read with so-many other writes to the screen.

	a=$((skip_count+skip_ok_count+skip_error_count+skip_abort_count))
	b=$(PercFrac "$ok_count" "$a" "$fail_count" "$total_count")

	if [[ $ok_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightGreen "$ok_count") OK"
	fi

	if [[ $a -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightOrange "$a") skipped"
	fi

	if [[ $fail_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightRed "$fail_count") failed"
	fi

	if [[ $fork_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightYellow "$fork_count") in-progress"
	fi

	[[ -n $b && ! -e $DISPLAY_INHIBIT_PATHFILE ]] && ShowAsProc "${fork_progress_prefix:-}" "$b"

	return 0

	} >&2

QPKGs.Missing:Show()
	{

	# Check installed QPKGs and check if they're missing. If so, advise on-screen.

	# Output:
	#	$? = 0 if no packages are missing
	#	$? = 1 if one-or-more packages are missing

	QPKGs.AClist.ISmissing.IsNt || return 0
	QPKGs.ACreinstall.ISmissing.IsNt || return 0

	local a=''
	local b=''
	local c=''
	local -i i=0
	local name_limit=2
	local -a packages=()

	if [[ $(QPKGs-ISmissing:Count) -eq 0 ]]; then
		return 0
	else
		packages+=($(QPKGs-ISmissing:Array))
	fi

	# shellcheck disable=2322
	for ((i=0; i<=((${#packages[@]}-1)); i++)); do
		a+=$(TextBrightRed "${packages[$i]}")

		if [[ $((i+1)) -ge $name_limit && $((${#packages[@]}-name_limit)) -gt 0 ]]; then
			a+=" & $(TextBrightRed "$((${#packages[@]}-name_limit))") other$(Pluralise "$((${#packages[@]}-name_limit))")"
			break
		elif [[ $((i+2)) -lt ${#packages[@]} ]]; then
			a+=', '
		elif [[ $((i+2)) -eq ${#packages[@]} ]]; then
			a+=' & '
		fi
	done

	if [[ ${#packages[@]} -eq 1 ]]; then
		b=' is'
		c='it'
	else
		b='s are'
		c='them'
	fi

	ShowAsNote "the $a QPKG${b} missing or broken. Please reinstall $c"

	return 1

	}

QPKGs.NewVers:Show()
	{

	# Check installed QPKGs and compare versions against upgradable array. If new versions are available, advise on-screen.

	# Output:
	#	$? = 0 if all packages are up-to-date
	#	$? = 1 if one-or-more packages can be upgraded

	QPKGs.AClist.ISupgradable.IsNt || return 0
	QPKGs.ACupgrade.ISupgradable.IsNt || return 0

	local a=''
	local b=''
	local c=''
	local -i i=0
	local name_limit=2
	local -a packages=()

	if [[ $(QPKGs-ISupgradable:Count) -eq 0 ]]; then
		return 0
	else
		packages+=($(QPKGs-ISupgradable:Array))
	fi

	# shellcheck disable=2322
	for ((i=0; i<=((${#packages[@]}-1)); i++)); do
		a+=$(TextBrightOrange "${packages[$i]}")

		if [[ $((i+1)) -ge $name_limit && $((${#packages[@]}-name_limit)) -gt 0 ]]; then
			a+=" & $(TextBrightOrange "$((${#packages[@]}-name_limit))") other$(Pluralise "$((${#packages[@]}-name_limit))")"
			break
		elif [[ $((i+2)) -lt ${#packages[@]} ]]; then
			a+=', '
		elif [[ $((i+2)) -eq ${#packages[@]} ]]; then
			a+=' & '
		fi
	done

	if [[ ${#packages[@]} -eq 1 ]]; then
		b='a '
		c='version is'
	else
		c="version$(Pluralise "${#packages[@]}") are"
	fi

	ShowAsNote "${b}new QPKG $c available for $a"

	return 1

	}

QPKGs.Conflicts:Check()
	{

	[[ $run_package_actions = false ]] || return 0

	local a=''

	if [[ -n ${BASE_QPKG_CONFLICTS_WITH:-} ]]; then
		# shellcheck disable=2068
		for a in "${BASE_QPKG_CONFLICTS_WITH[@]}"; do
			if QPKG.IsEnabled "$a"; then
				ShowAsError "the '$a' QPKG is enabled. $(ShowAsTitleName) is incompatible with this package. Please consider stopping this QPKG in your App Center"
				run_package_actions=false

				return 1
			fi
		done
	fi

	return 0

	}

QPKGs.Warnings:Check()
	{

	local a=''

	if [[ -n ${BASE_QPKG_WARNINGS:-} ]]; then
		# shellcheck disable=2068
		for a in "${BASE_QPKG_WARNINGS[@]}"; do
			if QPKG.IsEnabled "$a"; then
				ShowAsWarn "the '$a' QPKG is enabled. This may cause problems with $(ShowAsTitleName) applications. Please consider stopping this QPKG in your App Center"

				return 1
			fi
		done
	fi

	return 0

	}

QPKGs.Actions:List()
	{

	[[ $useropt_debug = true ]] || return

	Func:Init

	local a=''
	local b=''
	local border_shown=false

	for a in "${QPKG_ACTIONS[@]}"; do
		for b in ok er sk so se sa; do
			if QPKGs-AC${a}-${b}.IsAny; then
				if [[ $border_shown = false ]]; then
					DebugInfoMinSepr
					border_shown=true
				fi

				case $b in
					ok|sk|so)
						DebugQpkg info "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
						;;
					se|sa)
						DebugQpkg warning "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
						;;
					er)
						DebugQpkg error "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
				esac
			fi
		done
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr

	Func:Exit

	}

IPKs.Actions:List()
	{

	[[ $useropt_debug = true ]] || return

	Func:Init

	local a=''
	local border_shown=false

	for a in "${IPK_ACTIONS[@]}"; do
		if IPKs-AC${a}-ok.IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk info "AC${a}-ok" "($(IPKs-AC${a}-ok:Count)) $(IPKs-AC${a}-ok:ListCSV) "
		fi

		if IPKs-AC${a}-er.IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk error "AC${a}-er" "($(IPKs-AC${a}-er:Count)) $(IPKs-AC${a}-er:ListCSV) "
		fi
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr

	Func:Exit

	}

PIPs.Actions:List()
	{

	[[ $useropt_debug = true ]] || return

	Func:Init

	local a=''
	DebugInfoMinSepr

	for a in "${PIP_ACTIONS[@]}"; do
		PIPs-AC${a}-ok.IsAny && DebugPipInfo "AC${a}-ok" "($(PIPs-AC${a}-ok:Count)) $(PIPs-AC${a}-ok:ListCSV) "
		PIPs-AC${a}-er.IsAny && DebugPipError "AC${a}-er" "($(PIPs-AC${a}-er:Count)) $(PIPs-AC${a}-er:ListCSV) "
	done

	DebugInfoMinSepr

	Func:Exit

	}

QPKGs.Actions:ListAll()																						#devdebug
	{																										#devdebug

	# Only used when debugging.																				#devdebug

	Func:Init																								#devdebug

	local a=''																								#devdebug
	local b=''																								#devdebug
	DebugInfoMinSepr																						#devdebug

	for a in "${QPKG_ACTIONS[@]}"; do																		#devdebug
		for b in to ok er sk so se sa; do																	#devdebug
			if QPKGs-AC${a}-${b}.IsAny; then																#devdebug
				DebugQpkg info "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "	#devdebug
			fi																								#devdebug
		done																								#devdebug
	done																									#devdebug

	DebugInfoMinSepr																						#devdebug

	Func:Exit																								#devdebug

	}																										#devdebug

QPKGs.States:List()
	{

	[[ $useropt_debug = true ]] || return

	Func:Init

	local a=''

	QPKGs.States:Build
	DebugInfoMinSepr

	for a in "${QPKG_IS_STATES[@]}" "${QPKG_SERVICE_RESULTS[@]}"; do
		[[ $a = installed ]] && continue

		if [[ $a = unknown ]]; then
			QPKGs-IS${a}.IsAny && DebugQpkg warning "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
		else
			QPKGs-IS${a}.IsAny && DebugQpkg info "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
		fi
	done

	for a in "${QPKG_ISNT_STATES[@]}" "${QPKG_SERVICE_RESULTS[@]}"; do
		[[ $a = installed ]] && continue

		if [[ $a = ok ]]; then
			QPKGs-ISNT${a}.IsAny && DebugQpkg error "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		elif [[ $a = backedup ]]; then
			QPKGs-ISNT${a}.IsAny && DebugQpkg warning "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		else
			QPKGs-ISNT${a}.IsAny && DebugQpkg info "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		fi
	done

	for a in "${QPKG_STATES_TRANSIENT[@]}"; do
		# shellcheck disable=2043
		QPKGs-IS${a}.IsAny && DebugQpkg info "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
	done

	DebugInfoMinSepr

	Func:Exit

	}

QPKGs.IndependentDependent:Build()
	{

	# There are three tiers of package: `independent`, `auxiliary` and `dependent`.
	# ... but only two tiers of QPKG: `independent` and `dependent`.

	# `independent` QPKGs don't depend-on other QPKGs, but may be required for other QPKGs. They should be installed/activated before any `dependent` QPKGs.
	# `dependent` QPKGs depend-on other QPKGs. They should be installed/activated after all `independent` QPKGs.

	local a=''

	for a in "${QPKG_NAME[@]}"; do
		if QPKG.IsDependent "$a"; then
			QPKGs-GRdependent:Add "$a"
		else
			QPKGs-GRindependent:Add "$a"
		fi
	done

	return 0

	}

QPKGs.States:Build()
	{

	# Builds several lists of QPKGs:
	#   - can be installed or reinstalled by the user
	#   - are installed or not
	#   - can be upgraded
	#   - are enabled or disabled in [/etc/config/qpkg.conf]
	#   - are active or inactive
	#   - have backup files in backup location
	#   - have config blocks in [/etc/config/qpkg.conf], but no files on-disk
	#   - those in the process of starting, stopping, or restarting

	Func:Init

	local a=''
	local b=''
	local c=''
	local f=''

	if [[ ${qpkgs_states_built:=false} = true ]]; then
		DebugAsDone "don't build states: they're already built"

		Func:Exit; return
	fi

	Packages:Load
	QPKGs.States:Init

	OS.IsStarting && ShowAsWarn "$(GetQnapOS) is starting all enabled QPKGs $CHARS_ELLIPSIS check again in a few minutes"
	OS.IsStopping && ShowAsWarn "$(GetQnapOS) is shutting-down and all QPKGs are stopping"

	if OS.IsLoadAverageInsane; then
		ShowAsWarn 'the NAS currently has an exceptionally-high system-load, recommend aborting and trying again later'
	elif OS.IsLoadAverageHigh; then
		ShowAsWarn 'the NAS currently has an unusually-high system-load, so this will take a while'
	elif OS.IsLoadAverageElevated; then
		ShowAsNote 'the NAS currently has an elevated system-load, this will take a little longer than usual'
	fi

	ShowAsProc 'QPKG states'

	MakePath "$QPKG_STATES_PATH" states || return

	# Faster to launch several concurrent loops in the background, than a single loop. Launch those requiring more processing-time first.

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		if QPKG.IsNtInstalled "$a"; then
			if QPKG.IsInstallable "$a"; then
				echo installable
			else
				echo notinstallable
			fi >> "$QPKG_STATES_PATH/$a"
		fi
	done &

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		if QPKG.IsInstalled "$a"; then
			echo installed							# Only write this once per-file.

			if QPKG.IsUpgradable "$a"; then
				echo upgradable
			else
				echo notupgradable
			fi
		fi >> "$QPKG_STATES_PATH/$a"
	done &

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		if QPKG.IsInstalled "$a"; then
			if QPKG.IsEnabled "$a"; then
				echo enabled
			else
				echo notenabled
			fi
		fi >> "$QPKG_STATES_PATH/$a"
	done &

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		if QPKG.IsCanBackup "$a"; then
			echo backupable

			if QPKG.IsBackupExist "$a"; then
				echo backedup
			else
				echo notbackedup
			fi >> "$QPKG_STATES_PATH/$a"
		else
			echo notbackupable
		fi >> "$QPKG_STATES_PATH/$a"
	done &

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		if QPKG.IsInstalled "$a"; then
			if QPKG.IsMissing "$a"; then
				echo missing
			else
				echo notmissing
			fi
		else
			echo notinstalled
		fi >> "$QPKG_STATES_PATH/$a"
	done &

	wait 2>/dev/null

	# Load status lines from individual files.

	for a in $(QPKGs-GRall:Array); do
		[[ $a = "$b" ]] && continue || b=$a

		f=/var/run/$a.last.operation

		if [[ -e $f ]]; then
			case $(<$f) in
				start)
					QPKGs-ISstarting:Add "$a"
					;;
				restart)
					QPKGs-ISrestarting:Add "$a"
					;;
				stop)
					QPKGs-ISstopping:Add "$a"
					;;
				failed)
					QPKGs-ISNTok:Add "$a"
					;;
				ok)
					QPKGs-ISok:Add "$a"
			esac
		fi

		f="$QPKG_STATES_PATH/$a"
		[[ -e $f ]] || continue

		for c in $(<$f); do
			case $c in
				backedup)
					QPKGs-ISbackedup:Add "$a"
					;;
				notbackedup)
					QPKGs-ISNTbackedup:Add "$a"
					;;
				backupable)
					: # ignore for now.
					;;
				notbackupable)
					: # ignore for now.
					;;
				enabled)
					QPKGs-ISenabled:Add "$a"
					;;
				notenabled)
					QPKGs-ISNTenabled:Add "$a"
					;;
				installable)
					QPKGs-ISinstallable:Add "$a"
					;;
				notinstallable)
					QPKGs-ISNTinstallable:Add "$a"
					;;
				installed)
					QPKGs-ISinstalled:Add "$a"
					;;
				notinstalled)
					QPKGs-ISNTinstalled:Add "$a"
					;;
				missing)
					QPKGs-ISmissing:Add "$a"

					# Also mark as not OK.
					QPKGs-ISok:Remove "$a"
					QPKGs-ISNTok:Add "$a"
					;;
				notmissing)
					QPKGs-ISNTmissing:Add "$a"
					;;
				upgradable)
					QPKGs-ISupgradable:Add "$a"
					;;
				notupgradable)
					QPKGs-ISNTupgradable:Add "$a"
			esac
		done
	done

	qpkgs_states_built=true
	QPKGs.Missing:Show
	QPKGs.NewVers:Show

	Func:Exit

	}

QPKGs.States:Init()
	{

	# Clears in-memory state list objects

	Objects:Load || return

	Func:Init

	local a=''

	DebugAsProc 'initialising state lists'

	for a in "${QPKG_IS_STATES[@]:-}" "${QPKG_STATES_TRANSIENT[@]:-}"; do
		[[ $a = active ]] && continue		# don't reset.
		QPKGs-IS${a}:Init
	done

	for a in "${QPKG_ISNT_STATES[@]:-}"; do
		[[ $a = active ]] && continue		# don't reset.
		QPKGs-ISNT${a}:Init
	done

	ClearPath /var/run/sherpa/packages "$QPKG_STATES_PATH"

	DebugAsDone 'initialised state lists'
	qpkgs_states_built=false

	Func:Exit

	}

QPKGs.IsCanBackup:Build()
	{

	# Build a list of QPKGs that support `backup` and `restore` actions.

	Func:Init

	local a=''

	for a in $(QPKGs-GRall:Array); do
		QPKG.IsCanBackup "$a" && QPKGs-GRcanbackup:Add "$a"
	done

	Func:Exit

	}

QPKGs.IsCanRestartToUpdate:Build()
	{

	# Build a list of QPKGs that support application update on QPKG restart.

	Func:Init

	local a=''

	for a in $(QPKGs-GRall:Array); do
		QPKG.IsCanRestartToUpdate "$a" && QPKGs-GRcanrestarttoupdate:Add "$a"
	done

	Func:Exit

	}

QPKGs.IsCanClean:Build()
	{

	# Build a list of QPKGs that support `clean` actions.

	Func:Init

	local a=''

	for a in $(QPKGs-GRall:Array); do
		QPKG.IsCanClean "$a" && QPKGs-GRcanclean:Add "$a"
	done

	Func:Exit

	}

QPKGs.IsTimeoutsIncreased()
	{

	[[ -e /usr/local/sbin/qpkg_service.orig ]]

	}

Help.Abbreviations:Show()
	{

	# Output:
	#   $report_max_cols (global)

	Func:Init

	local a=''
	local b=''
	report_max_cols=2
	local -i m=0
	local -i n=0

	Packages:Load

	local -i t=$(QPKGs-GRall:Count)

	DisableDebugToArchiveAndFile
	DisplayProcReport abbreviations
	ResetReportsPath &>/dev/null

		{

		Help.Basic:Show
		DisplayAsHelpTitle "$(ShowAsTitleName) can recognise various abbreviations and aliases as $(ShowAsPackages)."
		DisplayAsAbsReportTitleLine

		} >"$REPORT_OUTPUT_PATHFILE"

	for a in $(QPKGs-GRall:Array); do
		((n++))
		DisplayAsAbsReportItemLine "$a" > "$REPORTS_PATH/$n" &
	done

	m=$n
	wait 2>/dev/null

	# load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$REPORTS_PATH/$n"
		[[ -e $f ]] && b+="$(<$f)\n"		# add newline to each imported report line
	done

	[[ -n $b ]] && echo -en "$b" >>"$REPORT_OUTPUT_PATHFILE"

		{

		DisplayAsProjSynExam "example: to install $(ShowAsPackageName SABnzbd), $(ShowAsPackageName Mylar3) and $(ShowAsPackageName nzbToMedia) all-at-once" 'install sab my nzb2'

		} >> "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
		Display
	else
		ShowAsError 'no information to display'
	fi

	QPKGs.States:List

	Func:Exit

	}

Report.Backups:Show()
	{

	Func:Init

	local epoch_time=0		# Allow float as seconds have a fractional component.
	local file_bytes=0
	local file_date=''
	local file_name=''
	local file_time=''
	local highlight_older_than='2 weeks ago'
	report_max_cols=3

	DisableDebugToArchiveAndFile
	DisplayProcReport backups

		{

		DisplayAsHelpTitle "the location for $(ShowAsTitleName) backups is: $QPKG_BU_PATH"

		DisplayAsHelpTitle "backups are listed oldest-first, and those shown in $(TextBrightRed '! red') were last updated more-than $highlight_older_than."

		DisplayAsBacksReportTitleLine

		if [[ -e $GNU_FIND_CMD ]]; then				# Prefer GNU `find` for this.
			while read -r epoch_time file_name file_bytes; do
				[[ -z $epoch_time || -z $file_name ]] && break

				DisplayAsBacksReportItemLine "$epoch_time" "$file_name" "$file_bytes" "$highlight_older_than"
			done <<< "$($GNU_FIND_CMD "$QPKG_BU_PATH"/*.config.tar.gz -maxdepth 1 -printf '%C@ %f %s\n' 2>/dev/null | $SORT_CMD)"
		else										# If GNU `find` isn't available, do-it the hard-way.
			while read -r file_date file_time file_name file_bytes; do
				[[ -z $file_date || -z $file_name ]] && break

				epoch_time=$(/bin/date -d "$file_date $file_time" +"%s")
				file_name=$($BASENAME_CMD "$file_name")

				DisplayAsBacksReportItemLine "$epoch_time" "$file_name" "$file_bytes" "$highlight_older_than"
			done <<< "$(cd "$QPKG_BU_PATH" && ls -l1tr --time-style=+"%Y-%m-%d %H:%M:%S" ./*.config.tar.gz 2>/dev/null | $AWK_CMD '{print $6" "$7" "$8" "$5}')"
		fi

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
	else
		ShowAsError 'no information to display'
	fi

	Func:Exit

	}

Report.Dependencies:Show()
	{

	# Output:
	#   $report_max_cols (global)

	Func:Init

	local a=''
	local b=''
	report_max_cols=8
	local -i m=0
	local -i n=0
	local -i t=$(QPKGs-GRall:Count)

	DisableDebugToArchiveAndFile
	DisplayProcReport dependency
	ResetReportsPath &>/dev/null

		{

		DisplayAsHelpTitle "package dependencies are automatically installed/started/stopped/restarted as-required."
		DisplayAsHelpTitle "requirements shown in \"$(TextBrightOrange '* orange')\" prevent the package being installed."
		DisplayAsHelpTitle "those shown in \"$(TextBrightRed '! red')\" are preventing the package from working correctly."
		DisplayAsDepsReportTitleLine

		} >"$REPORT_OUTPUT_PATHFILE"

	for a in $(QPKGs-GRall:Array); do
		((n++))
		DisplayAsDepsReportItemLine "$a" > "$REPORTS_PATH/$n" &
	done

	m=$n
	wait 2>/dev/null

	# load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$REPORTS_PATH/$n"
		[[ -e $f ]] && b+="$(<$f)\n"		# add newline to each imported report line
	done

	[[ -n $b ]] && echo -en "$b" >>"$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
	else
		ShowAsError 'no information to display'
	fi

	QPKGs.States:List

	Func:Exit

	}

Report.Packages:Show()
	{

	# Output:
	#   $report_max_cols (global)

	Func:Init

	local a=''
	report_max_cols=3

	DisableDebugToArchiveAndFile
	DisplayProcReport package

		{

		Help.Basic:Show
		DisplayAsHelpTitle "one-or-more $(ShowAsPackages) may be specified at-once."
		DisplayAsPacksReportTitleLine

		for a in $(QPKGs-GRall:Array); do
			DisplayAsPacksReportItemLine "$a"
		done

		DisplayAsProjSynExam "abbreviations and aliases may also be used to specify $(ShowAsPackages). To list these" 'help abs'
		DisplayAsProjSynIndentExam '' a

		} > "$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
	else
		ShowAsError 'no information to display'
	fi

	Func:Exit

	}

Report.Repos:Show()
	{

	# Output:
	#   $report_max_cols (global)

	Func:Init

	local a=''
	local b=''
	report_max_cols=3
	local -i m=0
	local -i n=0
	local -i t=$(QPKGs-GRall:Count)

	DisableDebugToArchiveAndFile
	DisplayProcReport repository
	ResetReportsPath &>/dev/null
	DisplayAsReposReportTitleLine >"$REPORT_OUTPUT_PATHFILE"

	for a in $(QPKGs-GRall:Array); do
		((n++))
		DisplayAsReposReportItemLine "$a" > "$REPORTS_PATH/$n" &
	done

	m=$n
	wait 2>/dev/null

	# load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$REPORTS_PATH/$n"
		[[ -e $f ]] && b+="$(<$f)\n"		# add newline to each imported report line
	done

	[[ -n $b ]] && echo -en "$b" >>"$REPORT_OUTPUT_PATHFILE"

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
	else
		ShowAsError 'no information to display'
	fi

	QPKGs.States:List

	Func:Exit

	}

Report.Statuses:Show()
	{

	# Output:
	#   $report_max_cols (global)

	Func:Init

	local a=''
	local b=''
	local f=''
	local -i m=0
	report_max_cols=5
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport status
	ResetReportsPath &>/dev/null
	CalcMaxStatusReportCols
	DisplayAsStatusReportTitleLine >"$REPORT_OUTPUT_PATHFILE"

	for a in $(QPKGs-GRall:Array); do
		QPKGs-ACstatus-dn.Exist $a || continue
		((n++))
		DisplayAsStatusReportItemLine "$a" > "$REPORTS_PATH/$n" &
	done

	m=$n
	wait 2>/dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$REPORTS_PATH/$n"
		[[ -e $f ]] && b+="$(<$f)\n"		# add newline to each imported report line
	done

	[[ -n $b ]] && echo -en "$b" >>"$REPORT_OUTPUT_PATHFILE"

	if QPKGs-ISslow.IsAny; then
		{

		DisplayAsHelpTitle "statuses shown as '$(TextBrightOrange slow)' are usually because the application has been page-swapped to disk and must be reloaded into RAM to respond to a status request. Requesting the QPKG status again shortly afterward should return a useful status result."

		} >>"$REPORT_OUTPUT_PATHFILE"
	fi

	EraseThisLine

	if [[ -e $REPORT_OUTPUT_PATHFILE ]]; then
		DisplayFileInViewport "$REPORT_OUTPUT_PATHFILE"
	else
		ShowAsError 'no information to display'
	fi

	QPKGs.States:List

	Func:Exit

	}

QPKGs.ISbackedup:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISbackedup.IsAny; then
		for a in $(QPKGs-ISbackedup:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'backed-up' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTbackedup:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTbackedup.IsAny; then
		for a in $(QPKGs-ISNTbackedup:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'not backed-up' QPKGs"
	fi

	return 0

	}

QPKGs.ISenabled:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISenabled.IsAny; then
		for a in $(QPKGs-ISenabled:Array); do
			QPKGs-ISinstalled.Exist "$a" && Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'enabled' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTenabled:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTenabled.IsAny; then
		for a in $(QPKGs-ISNTenabled:Array); do
			QPKGs-ISinstalled.Exist "$a" && Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'not enabled' QPKGs"
	fi

	return 0

	}

QPKGs.ISinstalled:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISinstalled.IsAny; then
		for a in $(QPKGs-ISinstalled:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'installed' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTinstalled:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTinstalled.IsAny; then
		for a in $(QPKGs-ISNTinstalled:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'not installed' QPKGs"
	fi

	return 0

	}

#QPKGs.GRall:Show()
# 	{
#
# 	local a=''
#
# 	DisableDebugToArchiveAndFile
# 	EraseThisLine
#
# 	if QPKGs-GRall.IsAny; then
# 		for a in $(QPKGs-GRall:Array); do
# 			Display "$a"
# 		done
# 	else
# 		ShowAsWarn "unable to find any QPKGs"
# 	fi
#
# 	return 0
#
# 	}

QPKGs.ISinstallable:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISinstallable.IsAny; then
		for a in $(QPKGs-ISinstallable:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'installable' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTinstallable:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTinstallable.IsAny; then
		for a in $(QPKGs-ISNTinstallable:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'not installable' QPKGs"
	fi

	return 0

	}

QPKGs.ISmissing:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISmissing.IsAny; then
		for a in $(QPKGs-ISmissing:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'missing' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTmissing:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTmissing.IsAny; then
		for a in $(QPKGs-ISNTmissing:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'not missing' QPKGs"
	fi

	return 0

	}

QPKGs.ISactive:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISactive.IsAny; then
		for a in $(QPKGs-ISactive:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'active' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTactive:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTactive.IsAny; then
		for a in $(QPKGs-ISNTactive:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'inactive' QPKGs"
	fi

	return 0

	}

QPKGs.ISupgradable:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISupgradable.IsAny; then
		for a in $(QPKGs-ISupgradable:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'upgradable' QPKGs"
	fi

	return 0

	}

QPKGs.ISNTupgradable:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-ISNTupgradable.IsAny; then
		for a in $(QPKGs-ISNTupgradable:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'non-upgradable' QPKGs"
	fi

	return 0

	}

QPKGs.GRindependent:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-GRindependent.IsAny; then
		for a in $(QPKGs-GRindependent:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'independent' QPKGs"
	fi

	return 0

	}

QPKGs.GRdependent:Show()
	{

	local a=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if QPKGs-GRdependent.IsAny; then
		for a in $(QPKGs-GRdependent:Array); do
			Display "$a"
		done
	else
		ShowAsWarn "unable to find any 'dependent' QPKGs"
	fi

	return 0

	}

SendParentChangeEnv()
	{

	# Send a message into message stream to change a sherpa parent environment variable or variables.
	# This function is only called from within background functions.

	# Input:
	#   $1 = action request

	WriteToActionMsgPipe env "$1" '' ''

	}

SendPackageStateChange()
	{

	# Send a message into message stream to change the state of this QPKG to $1 in sherpa parent environment.
	# This might be: `isinstalled`, `isntenabled`, `isstarted`, `scntupgradable`, etc ...
	# This function is only called from within background functions.

	# Input:
	#   $1 = action request

	WriteToActionMsgPipe change "$1" package "$PACKAGE_NAME"

	}

SendActionStatus()
	{

	# Send a message into message stream to update sherpa parent environment with the status of this action for $PACKAGE_NAME.
	# This can be: `ok`, `so`, `sk`, `se`, `er`, `ex`. `ab`.
	# This function is only called from within background functions.

	# Input:
	#   $1 = status update

	WriteToActionMsgPipe status "$1" package "$PACKAGE_NAME"

	}

WriteToActionMsgPipe()
	{

	# Send a message into message stream to update sherpa parent shell environment.

	[[ $action_msg_pipe_fd != none && -e /proc/$$/fd/$action_msg_pipe_fd ]] && echo "$1|$2|$3|$4" >&$action_msg_pipe_fd

	return 0

	}

ReadFromActionMsgPipe()
	{

	local _msg1_key
	local _msg1_value
	local _msg2_key
	local _msg2_value

	IFS='|' read -r _msg1_key _msg1_value _msg2_key _msg2_value <&$action_msg_pipe_fd

	eval "$1='$_msg1_key' $2='$_msg1_value' $3='$_msg2_key' $4='$_msg2_value'"

	return 0

	}

FindNextFD()
	{

	# Find next available file descriptor: https://stackoverflow.com/a/41603891

	local -i fd=-1

	for fd in {10..100}; do
		if [[ ! -e /proc/$$/fd/$fd ]]; then
			echo -n "$fd"

			return 0
		fi
	done

	return 1

	}

MarkThisActionForkAsStarted()
	{

	[[ -n $proc_fork_pathfile ]] && $TOUCH_CMD "$proc_fork_pathfile"

	}

MarkThisActionForkAsOk()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_ok_pathfile"
	SendActionStatus ok

	}

MarkThisActionForkAsSkippedOk()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_ok_pathfile"
	SendActionStatus so

	}

MarkThisActionForkAsSkipped()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_pathfile"
	SendActionStatus sk

	}

MarkThisActionForkAsSkippedError()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_error_pathfile"
	SendActionStatus se

	}

MarkThisActionForkAsSkippedAbort()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_abort_pathfile"
	SendActionStatus sa

	}

MarkThisActionForkAsFailed()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_fail_pathfile"
	SendActionStatus er

	}

NoteIpkAcAsOk()
	{

	# Move specified IPK package name from `to` action array into associated `ok` array.

	# Input:
	#   $1 = package name
	#   $2 = action

	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-ok:Add "$1"

	return 0

	}

NoteIpkAcAsEr()
	{

	# Move specified IPK package name from `to` action array into associated `er` array.

	# Input:
	#   $1 = package name
	#   $2 = action
	#   $3 = reason (optional)

	local a="failing request to $2 $(ShowAsPackageName "$1")"

	[[ -n ${3:-} ]] && a+=" as $3"
	DebugAsError "$a" >&2
	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-er:Add "$1"

	return 0

	}

ModPathToEntware()
	{

	local a=''
	local b=/opt/bin:/opt/sbin

	if QPKGs-ISenabled.Exist Entware; then
		! [[ $PATH =~ $b ]] || return
		a=$($SED_CMD "s|${b}:||" <<< "$PATH:")		# Append colon prior to searching, then remove existing Entware paths.
		export PATH=$b:${a%:}						# ... now prepend Entware paths and remove trailing colon
		DebugAsDone 'prepended Entware to $PATH'
	else
		[[ $PATH =~ $b ]] || return
		a=$($SED_CMD "s|${b}:||" <<< "$PATH:")		# Append colon prior to searching, then remove existing Entware paths.
		export PATH=${a%:}							# ... now remove trailing colon
		DebugAsDone 'removed Entware from $PATH'
	fi

	DebugVar PATH

	return 0

	}

GetCPUInfo()
	{

	# QTS 4.5.1 & BusyBox 1.01 don't support `-m` option for `grep`, so extract first mention the hard-way with `head`.

	if $GREP_CMD -q '^model name' /proc/cpuinfo; then
		$GREP_CMD '^model name' /proc/cpuinfo | $HEAD_CMD -n1 | $SED_CMD 's|^.*: ||' | tr -s ' '
	elif $GREP_CMD -q '^Processor name' /proc/cpuinfo; then
		$GREP_CMD '^Processor name' /proc/cpuinfo | $HEAD_CMD -n1 | $SED_CMD 's|^.*: ||' | tr -s ' '
	else
		printf unknown

		return 1
	fi

	return 0

	}

GetArch()
	{

	$UNAME_CMD -m

	}

GetKernelVersion()
	{

	$UNAME_CMD -r

	}

GetKernelPageSize()
	{

	# Accuracy of this method is uncertain.

	$GREP_CMD KernelPageSize /proc/1/smaps | $HEAD_CMD -n1 | cut -f2 -d':' | tr -d ' '

	}

GetPlatform()
	{

	# Output:
	#   $? = 0 if found, 250 if not

	/sbin/getcfg '' Platform -d undefined -f /etc/platform.conf

	}

GetDefVol()
	{

	# Output:
	#   $? = 0 if found, 250 if not

	/sbin/getcfg SHARE_DEF defVolMP -d undefined -f /etc/config/def_share.info

	}

GetPython3Ver()
	{

	GetPythonVer "${1:-python3}"

	}

GetPythonVer()
	{

	GetThisBinPath ${1:-python} &>/dev/null && ${1:-python} -V 2>&1 | $SED_CMD 's|^Python ||'

	}

GetPerlVer()
	{

	GetThisBinPath ${1:-perl} &>/dev/null && ${1:-perl} -e 'print "$^V\n"' 2>/dev/null | $SED_CMD 's|v||'

	}

GetThisBinPath()
	{

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined binary} ]] && command -v "$1" 2>&1

	}

GetRepoURLFromStoreID()
	{

	# Input:
	#	$1 = store ID to lookup repo URL for

	# Output:
	#   $? = 0 if found, 250 if not

	[[ -n ${1:-} ]] || return

	/sbin/getcfg "$1" u -d undefined -f /etc/config/3rd_pkg_v2.conf

	}

GetUptime()
	{

	local n=$(</proc/uptime)

	FormatSecsToHoursMinutesSecs "${n%%.*}"

	}

GetTimeInShell()
	{

	local n=0

	if [[ -n ${LOADER_SCRIPT_PPID:-} ]]; then
		n=$($PS_CMD -o pid,etime | $GREP_CMD $LOADER_SCRIPT_PPID | $HEAD_CMD -n1)
	fi

	FormatLongMinutesSecs "${n:6}"

	}

GetSysLoadAverages()
	{

	$UPTIME_CMD | $SED_CMD 's|.*load average: ||' | $AWK_CMD -F', ' '{print "1m:"$1", 5m:"$2", 15m:"$3}'

	}

GetSysLoad1MinAverage()
	{

	$UPTIME_CMD | $SED_CMD 's|.*load average: ||' | $AWK_CMD -F', ' '{print $1}'

	}

GetCPUCores()
	{

	local n=$($GREP_CMD -c '^processor' /proc/cpuinfo)

	[[ $n -eq 0 ]] && n=$($GREP_CMD -c '^Processor' /proc/cpuinfo)

	echo -n "$n"

	}

GetInstalledRAM()
	{

	$GREP_CMD MemTotal /proc/meminfo | $SED_CMD 's|.*: ||;s|kB||;s| ||g'

	}

GetFirmwareVer()
	{

	# Output:
	#   $? = 0 if found, 250 if not

	/sbin/getcfg System Version -d undefined -f /etc/config/uLinux.conf

	}

GetFirmwareBuild()
	{

	# Output:
	#   $? = 0 if found, 250 if not

	/sbin/getcfg System Number -d undefined -f /etc/config/uLinux.conf

	}

GetFirmwareDate()
	{

	# Output:
	#   $? = 0 if found, 250 if not

	/sbin/getcfg System 'Build Number' -d undefined -f /etc/config/uLinux.conf

	}

GetQnapOS()
	{

	if $GREP_CMD -q zfs /proc/filesystems; then
		printf 'QuTS hero'
	else
		printf QTS
	fi

	}

GetQpkgArch()
	{

	# Translate arch from QTS/QuTS-to-sherpa notation.

	case $NAS_ARCH in
		x86_64)
			[[ ${NAS_FIRMWARE_VER//.} -ge 430 ]] && printf i64 || printf i86
			;;
		i686|x86)
			printf i86
			;;
		armv5tel)
			printf a19
			;;
		armv7l)
			case $NAS_PLATFORM in
				ARM_MS)
					printf a31
					;;
				ARM_AL)
					printf a41
					;;
				*)
					printf none
			esac
			;;
		aarch64)
			printf a64
			;;
		*)
			printf none
	esac

	}

GetEntwareType()
	{

	if QPKG.IsInstalled Entware; then
		if [[ -e /opt/etc/passwd ]]; then
			if [[ -L /opt/etc/passwd ]]; then
				printf std
			else
				printf alt
			fi
		else
			printf none
		fi
	else
		printf 'not-installed'
	fi

	} 2>/dev/null

GetSudoUID()
	{

	echo -n "${SUDO_UID:-undefined}"

	}

GetUpState()
	{

	if OS.IsStarting; then
		printf 'starting-up'
	elif OS.IsStopping; then
		printf 'shutting-down'
	else
		printf stable
	fi

	}

OS.IsOk()
	{

	if ! OS.IsQNAP; then
		ShowAsAbort 'QNAP shell functions not found ... is this a QNAP NAS?'

		return 1
	fi

	return 0

	}

OS.IsQNAP()
	{

	# Is this a QNAP NAS?

	[[ -e /etc/init.d/functions ]]

	}

OS.IsCompatibleWithSigned()
	{

	# QTS builds released over these 6 days don't allow unsigned QPKGs to run at-all.

	[[ $NAS_FIRMWARE_DATE -lt 20201015 || $NAS_FIRMWARE_DATE -gt 20201020 ]]

	}

OS.IsSupported()
	{

	# Unable to test firmwares any earlier than 4.2.6 (but still have 4.2.0 available for TS-559Pro+)

	[[ ${NAS_FIRMWARE_VER//.} -ge 400 ]]

	}

OS.IsSupportSecureDownload()
	{

	# `curl` with SSL certificate verification enabled:
	#	fails in:
	# 		QTS 4.2.6
	# 		QTS 4.4.1
	# 		QTS 4.5.1
	# 		QTS 4.5.4.1715
	#	works in:
	# 		QTS 4.5.4.2627

	[[ ${NAS_FIRMWARE_VER//.} -ge 500 ]]

	}

OS.IsSupportQpkgTimeout()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 430 ]]

	}

OS.IsSupportSignedPackages()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 435 ]]

	}

OS.IsSupportSudo()
	{

	[[ -e /usr/bin/sudo ]]

	}

OS.IsAllowUnsignedPackages()
	{

	[[ $(/sbin/getcfg 'QPKG Management' Ignore_Cert) = TRUE ]]

	}

OS.IsStarting()
	{

	$PS_CMD | $GREP_CMD -F '/bin/sh /etc/init.d/rcS' | $GREP_CMD -v grep

	} &>/dev/null

OS.IsStopping()
	{

	$PS_CMD | $GREP_CMD -F '/bin/sh /etc/init.d/rcK' | $GREP_CMD -v grep

	} &>/dev/null

OS.IsStdKernelPageSize()
	{

	# Standard kernel page size for most QNAP NAS is 4kB. Non-standard size is 32kB (confirmed on the TS-431XeU, TS-431X3 & TS-1635).
	# https://www.qnap.com/en-us/how-to/faq/article/why-do-the-installed-third-party-containers-not-run-successfully-on-specific-32-bit-arm-devices

	[[ ${KERNEL_PAGE_SIZE:=$(GetKernelPageSize)} = 4kB ]]

	}

OS.IsNonStdKernelPageSize()
	{

	! OS.IsStdKernelPageSize

	}

OS.IsLoadAverageElevated()
	{

	local a=$(GetSysLoad1MinAverage); a=${a/./}
	local b=$((CPU_CORES*2*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

OS.IsLoadAverageHigh()
	{

	local a=$(GetSysLoad1MinAverage); a=${a/./}
	local b=$((CPU_CORES*4*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

OS.IsLoadAverageInsane()
	{

	local a=$(GetSysLoad1MinAverage); a=${a/./}
	local b=$((CPU_CORES*8*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

Error:Set()
	{

	run_package_actions=false
	Error.IsSet && return
	_script_error_flag_=true
	DebugVar _script_error_flag_

	}

Error.IsSet()
	{

	[[ ${_script_error_flag_:=false} = true ]]

	}

Error.IsNt()
	{

	[[ ${_script_error_flag_:=false} != true ]]

	}

ShowZeroQpkgs()
	{

	[[ ${packages_loaded:=false} = true ]] || return

	local a=''
	local b=''

	for a in "${QPKG_IS_STATES[@]:-}"; do
		for b in "${USER_QPKG_ACTIONS[@]:-}"; do
			[[ $b = list ]] && continue			# action results lists are unavailable for these

			QPKGs.AC${b}.IS${a}.IsSet && QPKGs-AC${b}-ok.IsNone && ShowAsWarn "no QPKGs were able to $(Lowercase "$b")"
		done
	done

	return 0

	}

LockFile:Claim()
	{

	local a=''
	readonly LOCK_PATHFILE=/var/run/sherpa.lock		# global

	for a in sherpa-manager.sh sherpa-manager.source; do
		if [[ -e $LOCK_PATHFILE && -d /proc/$(<"$LOCK_PATHFILE") && $(</proc/"$(<"$LOCK_PATHFILE")"/cmdline) =~ $a ]]; then
			ShowAsAbort "another sherpa instance was found (PID:$(<"$LOCK_PATHFILE")), can't continue"

			return 1
		fi
	done

	echo "$$" > "$LOCK_PATHFILE"

	return 0

	}

LockFile:Release()
	{

	rm -f "$LOCK_PATHFILE"

	}

Verbose:Enable()
	{

	useropt_verbose=true
	DebugVar useropt_verbose

	useropt_terse=false
	Keystrokes:Show
	Cursor:Show

	}

EnableDebugToArchiveAndFile()
	{

	useropt_debug=true
	DebugVar useropt_debug

	ShowAsNote "debug mode activated, $(ShowAsTitleName) will run a little slower than usual"

	archive_debug_afterward=true
	DebugVar archive_debug_afterward

	}

DisableDebugToArchiveAndFile()
	{

	archive_debug_afterward=false
	useropt_debug=false

	}

SaveActionResultToLog()
	{

	# Write package type, package name, datetime in seconds, action, result, reason to actions logfile, and into actions durations file.

	# Input:						example:
	#   $1 = package type			`QPKG`, `IPK`, `PIP`
	#   $2 = package or group name	`SABnzbd`, `essential`
	#   $3 = action					`download`, `activate`
	#   $4 = result					`ok`, `skipped-ok`, `skipped`, `failed`
	#   $5 = reason (optional)		"file already exists in local cache"

	# Calculate duration here.

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}
	local -r PACKAGE_TYPE=${1:?${FUNCNAME[0]}'()': undefined package type}
	local -r PACKAGE_NAME=${2:?${FUNCNAME[0]}'()': undefined package name}
	local -r ACTION=${3:?${FUNCNAME[0]}'()': undefined action}
	local -r CLEAN_ACTION=${ACTION//\"/}
	local -r RESULT=${4:?${FUNCNAME[0]}'()': undefined result}
	local -r REASON=${5:-}
	local -r DURATION=$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")
	local -r ACTION_TIMES_PATHFILE=$ACTION_TIMES_PATH/$CLEAN_ACTION.milliseconds

	if [[ $2 = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$2"

		return 1
	fi

	# Write new action results entry.
	echo "$(/bin/date +%s)|$ACTION|$PACKAGE_NAME|$RESULT|$DURATION|$REASON|$PACKAGE_TYPE" >> "$SESS_ACTION_RESULTS_PATHFILE"

	# Remove previous action duration entry if one exists.

	if [[ -e $ACTION_TIMES_PATHFILE ]] && $GREP_CMD -q "^$PACKAGE_NAME|" < "$ACTION_TIMES_PATHFILE"; then
		$SED_CMD -i "/^$PACKAGE_NAME|/d" "$ACTION_TIMES_PATHFILE"
	fi

	# Add new action duration entry.
	echo "$PACKAGE_NAME|$DURATION" >> "$ACTION_TIMES_PATHFILE"

	case $4 in
		ok|skipped-ok)
			DebugAsInfo "$REASON"
			;;
		skipped)
			DebugAsWarn "$REASON"
			;;
		failed|skipped-@(error|abort))
			DebugAsError "$REASON"
	esac

	return 0

	}

# * Action return codes (only recorded in debug log).
# 	0 = ok
# 	1 = skipped
# 	2 = skipped-ok
# 	3 = skipped-abort
# 	4 = skipped-error

_QPKG:reassign_()
	{

	# * This function runs autonomously *
	# Removes the `storeid` assignment for the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if ! QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif [[ $(QPKG.GetStoreID "$PACKAGE_NAME") = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign skipped 'QPKG is already assigned to sherpa'
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "reassigning $(ShowAsPackageName "$PACKAGE_NAME")"
	RunAndLog "/sbin/setcfg -e $PACKAGE_NAME store -f /etc/config/qpkg.conf" "$LOGS_PATH/$PACKAGE_NAME.$REASSIGN_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign failed "$z"
		MarkThisActionForkAsFailed
		z=1   # remap to 1
	fi

	FuncFork:Exit $z

	}

_QPKG:download_()
	{

	# * This function runs autonomously *
	# Downloads the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
		local -r REMOTE_HASH=$(QPKG.GetHash "$PACKAGE_NAME")
		local -r REMOTE_URL=$(QPKG.GetURL "$PACKAGE_NAME")
			local -r REMOTE_FILENAME=$($BASENAME_CMD "$REMOTE_URL")
				local -r LOCAL_PATHFILE=$QPKG_DL_PATH/$REMOTE_FILENAME
					local -r LOCAL_FILENAME=$($BASENAME_CMD "$LOCAL_PATHFILE")
						local -r LOG_PATHFILE=$LOGS_PATH/$LOCAL_FILENAME.$DOWNLOAD_LOG_FILE
	local -i z=0

	if [[ -z $REMOTE_URL || -z $REMOTE_HASH ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" download skipped 'NAS arch is incompatible'
		MarkThisActionForkAsSkipped
		z=1
	elif [[ -f $LOCAL_PATHFILE ]]; then
		if FileMatchesMD5 "$LOCAL_PATHFILE" "$REMOTE_HASH"; then
			SaveActionResultToLog QPKG "$PACKAGE_NAME" download skipped-ok "existing file $(ShowAsFileName "$LOCAL_FILENAME") checksum correct"
			MarkThisActionForkAsSkippedOk
			z=2
		else
			DebugInfo "deleting $(ShowAsFileName "$LOCAL_FILENAME") as checksum is incorrect"
			rm -f "$LOCAL_PATHFILE"
		fi
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	if [[ ! -f $LOCAL_PATHFILE ]]; then
		DebugAsProc "downloading $(ShowAsFileName "$REMOTE_FILENAME")"

		rm -f "$LOG_PATHFILE"

		RunAndLog "$CURL_CMD --location --output $LOCAL_PATHFILE $REMOTE_URL" "$LOG_PATHFILE" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			if FileMatchesMD5 "$LOCAL_PATHFILE" "$REMOTE_HASH"; then
				[[ $(Lowercase "${LOCAL_PATHFILE##*.}") = zip ]] && $UNZIP_CMD -nq "$LOCAL_PATHFILE" -d "$QPKG_DL_PATH"
				SaveActionResultToLog QPKG "$PACKAGE_NAME" download ok
				SendPackageStateChange ISdownloaded
				MarkThisActionForkAsOk
			else
				SaveActionResultToLog QPKG "$PACKAGE_NAME" download failed "cache file $(ShowAsFileName "$LOCAL_FILENAME") has incorrect checksum"
				SendPackageStateChange ISNTdownloaded
				MarkThisActionForkAsFailed
				z=1
			fi
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" download failed "$z"
			MarkThisActionForkAsFailed
			z=1   # remap to 1 (last time I checked, 'curl' had 92 return codes)
		fi
	fi

	FuncFork:Exit $z

	}

_QPKG:install_()
	{

	# * This function runs autonomously *
	# Installs the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'QPKG is already installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsArchOK "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'NAS arch is incompatible'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsMinOSVerOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped "$(GetQnapOS) version is incompatible"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsMinRAMOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'NAS has insufficient RAM'
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local local_pathfile=$(QPKG.GetPathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped-error 'no local file found for processing: please report this issue'
		MarkThisActionForkAsSkippedError
		z=4
# 	elif ! FileMatchesMD5 "$local_pathfile" "$(QPKG.GetHash "$PACKAGE_NAME")"; then
# 		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped-error "cache file $(ShowAsFileName "$($BASENAME_CMD "$local_pathfile")") has incorrect checksum"
# 		MarkThisActionForkAsSkippedError
# 		z=4
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	if [[ $PACKAGE_NAME = Entware ]] && ! QPKGs-ISinstalled.Exist Entware && QPKGs-ACinstall-to.Exist Entware; then
		local -r OPT_PATH=/opt
		local -r OPT_BU_PATH=/opt.orig

		if [[ -d $OPT_PATH && ! -L $OPT_PATH && ! -e $OPT_BU_PATH ]]; then
			DebugAsProc 'backup original /opt'
			mv "$OPT_PATH" "$OPT_BU_PATH"
			DebugAsDone complete
		fi
	fi

	local target_path=''

	DebugAsProc "installing $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	[[ ${QPKGs_were_installed_name[*]:-} = *"$PACKAGE_NAME"* ]] && target_path="QINSTALL_PATH=$(QPKG.GetOriginalPath "$PACKAGE_NAME") "
	RunAndLog "${a}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$INSTALL_LOG_FILE" log:failure-only 10
	z=$?

	[[ $PACKAGE_NAME = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1

	if [[ $z -eq 0 || $z -eq 10 ]]; then
		QPKG.ServiceStatus:Log
		SendPackageStateChange ISinstalled

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		SaveActionResultToLog QPKG "$PACKAGE_NAME" install ok "version $(QPKG.Local.GetVer "$PACKAGE_NAME")"

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			SendParentChangeEnv UpdateEntwarePackageList
			PatchEntwareService

			# Shift all files from original [/opt] into new [/opt]

			if [[ -L ${OPT_PATH:-} && -d ${OPT_BU_PATH:-} ]]; then
				DebugAsProc 'restoring original /opt'
				mv "$OPT_BU_PATH"/* "$OPT_PATH" && ClearPath / "$OPT_BU_PATH"
				DebugAsDone complete
			fi
		fi

		SendParentChangeEnv "QPKGs-ACsign-to:Add $PACKAGE_NAME"
		MarkThisActionForkAsOk
		z=0   # Remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK, but unfortunately will include installation aborts).
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:reinstall_()
	{

	# * This function runs autonomously *
	# Reinstalls the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if ! QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped "QPKG is not installed, please use 'install' instead."
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local local_pathfile=$(QPKG.GetPathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped-error 'no local file found for processing, please report this issue.'
		MarkThisActionForkAsSkippedError
		z=4
# 	elif ! FileMatchesMD5 "$local_pathfile" "$(QPKG.GetHash "$PACKAGE_NAME")"; then
# 		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped-error "cache file $(ShowAsFileName "$($BASENAME_CMD "$local_pathfile")") has incorrect checksum"
# 		MarkThisActionForkAsSkippedError
# 		z=4
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local target_path=''

	DebugAsProc "reinstalling $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	QPKG.IsInstalled "$PACKAGE_NAME" && target_path="QINSTALL_PATH=$($DIRNAME_CMD "$(QPKG.GetInstallationPath $PACKAGE_NAME)") "
	RunAndLog "${a}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$REINSTALL_LOG_FILE" log:failure-only 10
	z=$?

	[[ $PACKAGE_NAME = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1

	if [[ $z -eq 0 || $z -eq 10 ]]; then
		QPKG.ServiceStatus:Log

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		local current_ver=$(QPKG.Local.GetVer "$PACKAGE_NAME")
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall ok "version $current_ver"
		MarkThisActionForkAsOk
		z=0   # Remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK, but unfortunately will include installation aborts).
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:rebuild_()
	{

	# * This function runs autonomously *
	# Meta-action: rebuilds the QPKG named in $1. This is a `download`, `install` and `restore`, but only if a backup file exists for this QPKG.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if ! QPKG.IsCanBackup; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" meta-rebuild skipped 'QPKG does not support rebuild'
		MarkThisActionForkAsSkipped
		z=1
	elif QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" meta-rebuild skipped "QPKG is already installed, please use 'restore' instead"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsBackupExist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" meta-rebuild skipped 'QPKG backup does not exist'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" meta-rebuild skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "meta-rebuilding $(ShowAsPackageName "$PACKAGE_NAME")"
	# Nothing-to-do here, real QPKG actions have already been assigned in Env:Check().

	SaveActionResultToLog QPKG "$PACKAGE_NAME" meta-rebuild ok
	MarkThisActionForkAsOk
	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:upgrade_()
	{

	# * This function runs autonomously *
	# Upgrades the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if ! QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKGs-ISupgradable.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped 'no new QPKG is available'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local local_pathfile=$(QPKG.GetPathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped-error 'no local file found for processing, please report this issue'
		MarkThisActionForkAsSkippedError
		z=4
# 	elif ! FileMatchesMD5 "$local_pathfile" "$(QPKG.GetHash "$PACKAGE_NAME")"; then
# 		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped-error "cache file $(ShowAsFileName "$($BASENAME_CMD "$local_pathfile")") has incorrect checksum"
# 		MarkThisActionForkAsSkippedError
# 		z=4
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local prev_ver=$(QPKG.Local.GetVer "$PACKAGE_NAME")
	local target_path=''

	DebugAsProc "upgrading $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	QPKG.IsInstalled "$PACKAGE_NAME" && target_path="QINSTALL_PATH=$($DIRNAME_CMD "$(QPKG.GetInstallationPath "$PACKAGE_NAME")") "
	RunAndLog "${a}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$UPGRADE_LOG_FILE" log:failure-only 10
	z=$?

	[[ $PACKAGE_NAME = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1

	if [[ $z -eq 0 || $z -eq 10 ]]; then
		QPKG.ServiceStatus:Log
		SendPackageStateChange ISNTupgradable

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		local current_ver=$(QPKG.Local.GetVer "$PACKAGE_NAME")

		if [[ $current_ver = "$prev_ver" ]]; then
			SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade ok "version $current_ver"
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade ok "upgraded from version $prev_ver to version $current_ver"
		fi

		MarkThisActionForkAsOk
		z=0   # Remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK, but unfortunately will include installation aborts).
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:uninstall_()
	{

	# * This function runs autonomously *
	# Uninstalls the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall skipped "it's needed here! 😉"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	local -r QPKG_UNINSTALLER_PATHFILE=$(QPKG.GetInstallationPath "$PACKAGE_NAME")/.uninstall.sh

	[[ $PACKAGE_NAME = Entware ]] && SaveIpkAndPipList

	if [[ -e $QPKG_UNINSTALLER_PATHFILE ]]; then
		DebugAsProc "uninstalling $(ShowAsPackageName "$PACKAGE_NAME")"
		[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

		RunAndLog "${a}${SH_CMD} $QPKG_UNINSTALLER_PATHFILE" "$LOGS_PATH/$PACKAGE_NAME.$UNINSTALL_LOG_FILE" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			# ALERT: beware of `qpkg_cli --remove`, it removes the QPKG installation path around 10-20 seconds after execution. If sherpa has moved-on and starts an install, `qpkg_cli` will remove the newly created QPKG installation path partway through the installation. So, check if QPKG is to be installed: if this is the case, don't use `qpkg_cli --remove`.
			[[ -e /sbin/qpkg_cli ]] && ! QPKGs-ACinstall-to.Exist "$PACKAGE_NAME" && /sbin/qpkg_cli --remove "$PACKAGE_NAME" &>/dev/null
			SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall ok
			/sbin/rmcfg "$PACKAGE_NAME" -f /etc/config/qpkg.conf
			DebugAsDone 'removed icon information from App Center'

			if [[ $PACKAGE_NAME = Entware ]]; then
				SendParentChangeEnv ModPathToEntware
				SendParentChangeEnv UpdateColourisation
				UpdateColourisation
			fi

			SendPackageStateChange ISNTinstalled
			SendPackageStateChange ISNTactive
			SendPackageStateChange ISNTenabled
			MarkThisActionForkAsOk
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall failed "$z"
			MarkThisActionForkAsFailed
			z=1   # Remap to 1.
		fi
	else
		# Standard QPKG `.uninstall.sh` was not found, so can't continue with uninstallation (maybe force this instead with `rm -r` ?).
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall failed '.uninstall.sh script is missing'
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $z

	}

_QPKG:activate_()
	{

	# * This function runs autonomously *
	# Activates/starts the service script for the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate skipped "QPKG is not enabled, please 'enable' it first"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$ACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_START_TIMEOUT_SECONDS"
	local service_pathfile=$(QPKG.GetServicePathFile "$PACKAGE_NAME")

	DebugAsProc "activating $(ShowAsPackageName "$PACKAGE_NAME")"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate skipped-error 'QPKG service script file undefined'
		MarkThisActionForkAsSkippedError

		FuncFork:Exit 4
	elif [[ $useropt_debug = true ]]; then
		a='DEBUG_QPKG=true '
		RunAndLog "${a}${service_pathfile} start" "$LOG_PATHFILE" log:failure-only
		z=$?
	elif QPKG.IsCanLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} start $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile start" "$LOG_PATHFILE" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate ok

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			SendParentChangeEnv UpdateColourisation
			UpdateColourisation
		fi

		SendPackageStateChange ISactive
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate failed "$z"
		SendPackageStateChange ISNTactive
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:reactivate_()
	{

	# * This function runs autonomously *
	# Reactivates/restarts the service script for the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate skipped "QPKG is not enabled, please 'enable' it first"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$REACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_RESTART_TIMEOUT_SECONDS"
	local service_pathfile=$(QPKG.GetServicePathFile "$PACKAGE_NAME")

	DebugAsProc "reactivating $(ShowAsPackageName "$PACKAGE_NAME")"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate skipped-error 'QPKG service script file undefined'
		MarkThisActionForkAsSkippedError

		FuncFork:Exit 4
	elif [[ $useropt_debug = true ]]; then
		a='DEBUG_QPKG=true '
		RunAndLog "${a}${service_pathfile} restart" "$LOG_PATHFILE" log:failure-only
		z=$?
	elif QPKG.IsCanLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} restart $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile restart" "$LOG_PATHFILE" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate failed "$z"
		MarkThisActionForkAsFailed
		z=1   # remap to 1
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:deactivate_()
	{

	# * This function runs autonomously *
	# Deactivates/stops the service script for the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped "it's needed here! 😉"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$DEACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_STOP_TIMEOUT_SECONDS"
	local service_pathfile=$(QPKG.GetServicePathFile "$PACKAGE_NAME")

	DebugAsProc "deactivating $(ShowAsPackageName "$PACKAGE_NAME")"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped-error 'QPKG service script file undefined'
		MarkThisActionForkAsSkippedError

		FuncFork:Exit 4
	elif [[ $useropt_debug = true ]]; then
		a='DEBUG_QPKG=true '
		RunAndLog "${a}${service_pathfile} stop" "$LOG_PATHFILE" log:failure-only
		z=$?
	elif QPKG.IsCanLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} stop $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile stop" "$LOG_PATHFILE" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate ok

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			SendParentChangeEnv UpdateColourisation
			UpdateColourisation
		fi

		SendPackageStateChange ISNTactive
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	QPKG.AppCenterNotifier:Clear

	FuncFork:Exit $z

	}

_QPKG:enable_()
	{

	# * This function runs autonomously *
	# Enables the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enable skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif QPKGs-ISenabled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enable skipped 'QPKG is already enabled'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enable skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$ENABLE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_ENABLE_TIMEOUT_SECONDS"

	DebugAsProc "enabling $(ShowAsPackageName "$PACKAGE_NAME")"

	RunAndLog "/sbin/qpkg_service${timeout} enable $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
	QPKG.IsEnabled "$PACKAGE_NAME" && SendPackageStateChange ISenabled
	QPKG.AppCenterNotifier:Clear
	SaveActionResultToLog QPKG "$PACKAGE_NAME" enable ok
	MarkThisActionForkAsOk

	FuncFork:Exit $z

	}

_QPKG:disable_()
	{

	# * This function runs autonomously *
	# Disabled the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped 'QPKG is already disabled'
		MarkThisActionForkAsSkipped
		z=1
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped "it's needed here! 😉"
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$DISABLE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_DISABLE_TIMEOUT_SECONDS"

	DebugAsProc "disabling $(ShowAsPackageName "$PACKAGE_NAME")"

	RunAndLog "/sbin/qpkg_service${timeout} disable $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
	! QPKG.IsEnabled "$PACKAGE_NAME" && SendPackageStateChange ISNTenabled

	QPKG.AppCenterNotifier:Clear
	SaveActionResultToLog QPKG "$PACKAGE_NAME" disable ok
	MarkThisActionForkAsOk

	FuncFork:Exit $z

	}

_QPKG:enableau_()
	{

	# * This function runs autonomously *
	# Enables auto-updating of the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enableau skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsCanRestartToUpdate "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enableau skipped 'QPKG does not support auto-updating'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enableau skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "enabling auto-update $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	RunAndLog "${a}$(QPKG.GetServicePathFile) enable-auto-update" "$LOGS_PATH/$PACKAGE_NAME.$ENABLEAU_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enableau ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enableau failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:disableau_()
	{

	# * This function runs autonomously *
	# Disables auto-updating of the QPKG named in $1.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disableau skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsCanRestartToUpdate "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disableau skipped 'QPKG does not support auto-updating'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disableau skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "disabling auto-update $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	RunAndLog "${a}$(QPKG.GetServicePathFile) disable-auto-update" "$LOGS_PATH/$PACKAGE_NAME.$DISABLEAU_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disableau ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disableau failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:backup_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `backup` action.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsCanBackup; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup skipped 'QPKG does not support backup'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "backing-up $(ShowAsPackageName "$PACKAGE_NAME") configuration"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	RunAndLog "${a}$(QPKG.GetServicePathFile) backup" "$LOGS_PATH/$PACKAGE_NAME.$BACKUP_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup ok
		SendPackageStateChange ISbackedup
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:restore_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `restore` action.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsCanBackup; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped 'QPKG does not support restore'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsBackupExist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped 'QPKG backup does not exist'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "restoring $(ShowAsPackageName "$PACKAGE_NAME") configuration"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	RunAndLog "${a}$(QPKG.GetServicePathFile) restore" "$LOGS_PATH/$PACKAGE_NAME.$RESTORE_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore ok
		SendPackageStateChange ISrestored
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:clean_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `clean` action.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsCanClean; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean skipped 'QPKG does not support cleaning'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "cleaning $(ShowAsPackageName "$PACKAGE_NAME")"
	[[ $useropt_debug = true ]] && a='DEBUG_QPKG=true '

	RunAndLog "${a}$(QPKG.GetServicePathFile) clean" "$LOGS_PATH/$PACKAGE_NAME.$CLEAN_LOG_FILE" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean failed "$z"
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:sign_()
	{

	# * This function runs autonomously *
	# Modify the QTS App Center certificate dB, and add an unsigned QPKG as-if it were signed. It adds a QNAP-generated certificate and digital signature to the certificate database for the unsigned QPKG.

	# Running the code below makes the target QPKG effectively "signed", and allows user to install and run this QPKG with the 'Allow installation of applications without a valid digital signature' App Center option unticked.

	# Should only be required for QTS 4.3.5-and-later firmwares.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	local b=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if [[ -e $ACTION_ABORT_PATHFILE ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped-abort 'abort requested, unable to continue'
		MarkThisActionForkAsSkippedAbort
		z=3
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugVar SQLITE_CMD

	if ! QPKGs-ISinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	elif ! OS.IsSupportSignedPackages; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'not required: firmware < 4.3.5'
		MarkThisActionForkAsSkipped
		z=1
	elif ! QPKG.IsRepoOk "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped "QPKG is assigned to another repository, please 'reassign' it first"
		MarkThisActionForkAsSkipped
		z=1
	elif [[ ! -e $SQLITE_CMD ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped-abort 'sqlite3 unavailable'
		MarkThisActionForkAsSkippedAbort
		z=3
	elif [[ ! -e $CERT_DB_PATHFILE ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped-abort "$(GetQnapOS) certificate database not found"
		MarkThisActionForkAsSkippedAbort
		z=3
	else
		a="SELECT 1 FROM Certificate WHERE QpkgName = '$PACKAGE_NAME' LIMIT 1;"
		b=$($SQLITE_CMD "$CERT_DB_PATHFILE" "$a")

		if [[ $b = 1 ]]; then
			SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped-ok 'QPKG is already signed'
			MarkThisActionForkAsSkippedOk
			z=2
		fi
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "\"signing\" $(ShowAsPackageName "$PACKAGE_NAME")"

# 	a="DELETE FROM Certificate WHERE QpkgName = '$PACKAGE_NAME'; INSERT INTO Certificate (Type,QpkgName,Cert,DigitalSignature) VALUES ('qpkg','$PACKAGE_NAME','$QPKG_CERTIFICATE','$QPKG_SIGNATURE');"

#	a="INSERT INTO Certificate (Type, QpkgName, Cert, DigitalSignature) SELECT 'qpkg','$PACKAGE_NAME','$QPKG_CERTIFICATE','$QPKG_SIGNATURE' WHERE NOT EXISTS (SELECT * FROM Certificate WHERE QpkgName = '$PACKAGE_NAME');"

	a="INSERT INTO Certificate (Type,QpkgName,Cert,DigitalSignature) VALUES ('qpkg','$PACKAGE_NAME','$QPKG_CERTIFICATE','$QPKG_SIGNATURE');"

	for ((retries=0; retries<10; retries++)); do
		$SQLITE_CMD "$CERT_DB_PATHFILE" "$a"
		z=$?

		case $z in
			5) 		# SQLITE_BUSY
				sleep 0.5
				;;
			*)
				break
		esac
	done

	if [[ $z -eq 0 ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' ok
		SendPackageStateChange ISsigned
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' failed "($z) but don't know why. Please report this as a bug"
		SendParentChangeEnv 'show_suggest_raise_issue=true'
		MarkThisActionForkAsFailed
		z=1   # Remap to 1.
	fi

	FuncFork:Exit $z

	}

_QPKG:status_()
	{

	# * This function runs autonomously *
	# Query a QPKG for its 'status'. Each compatible QPKG will return 0 if application process is active or ready-to-run, 0 if not.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = none, this function executes in the background.

	[[ $useropt_verbose != true ]] && exec &>/dev/null

	FuncFork:Init

	local a=''
	local b=''
	PACKAGE_NAME=${1:?${FUNCNAME[0]}'()': undefined package name}
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" status skipped 'QPKG is not installed'
		MarkThisActionForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncFork:Exit $z

	DebugAsProc "status $(ShowAsPackageName "$PACKAGE_NAME")"

	a=$(QPKG.GetActiveTest "$PACKAGE_NAME")

	if [[ $a = builtin ]]; then
		[[ $useropt_debug = true ]] && b='DEBUG_QPKG=true '

		# Run status query with GNU 'timeout' if-possible.

		if [[ -e $GNU_TIMEOUT_CMD ]]; then
			$GNU_TIMEOUT_CMD "$QPKG_STATUS_CHECK_TIMEOUT_SECONDS" /bin/bash -c "${b}$(QPKG.GetServicePathFile) status"
			z=$?
		else
			RunAndLog "${b}$(QPKG.GetServicePathFile) status" "$LOGS_PATH/$PACKAGE_NAME.$STATUS_LOG_FILE" log:failure-only
			z=$?
		fi
	elif [[ $a != none ]]; then
		eval "$a" &>/dev/null
		z=$?
	fi

	DebugVar z

	# returncodes 124 and-up are generated by GNU 'timeout'.

	case $z in
		0)
			SendPackageStateChange ISactive
			;;
		1)
			SendPackageStateChange ISNTactive
			;;
		124)
			SendPackageStateChange ISslow
			;;
		*)
			SendPackageStateChange ISunknown
	esac

	SaveActionResultToLog QPKG "$PACKAGE_NAME" status ok
	MarkThisActionForkAsOk

	FuncFork:Exit

	}

QPKG.AppCenterNotifier:Clear()
	{

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name to clear from notifier list.

	# KLUDGE: `clean` QTS 4.5.1+ App Center notifier status
	[[ -e /sbin/qpkg_cli ]] && /sbin/qpkg_cli --cancel "$PACKAGE_NAME"

	QPKG.IsNtInstalled "$PACKAGE_NAME" && return 0

	# Need to do this when installing QPKGs at the CLI.
	/sbin/setcfg "$PACKAGE_NAME" Status complete -f /etc/config/qpkg.conf

	return 0

	} &>/dev/null

QPKG.ServiceStatus:Clear()
	{

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name

	rm -f /var/run/"$PACKAGE_NAME".last.operation

	}

QPKG.LastResultWasOk()
	{

	# Returns true if last operation for this package is `ok`.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name

	[[ $(QPKG.GetServiceStatus "$PACKAGE_NAME") = ok ]]

	}

QPKG.ServiceStatus:Log()
	{

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name

	if ! local a=$(QPKG.GetServiceStatus "$PACKAGE_NAME"); then
		DebugAsWarn "unable to get status of $(ShowAsPackageName "$PACKAGE_NAME") service. It may be a non-sherpa package, or a sherpa package earlier than 200816c that doesn't support service results."

		return 1
	fi

	case $a in
		?(re)start|stop)
			DebugInfo "$(ShowAsPackageName "$PACKAGE_NAME") service is $a"
			;;
		ok)
			DebugInfo "$(ShowAsPackageName "$PACKAGE_NAME") service action completed OK"
			;;
		failed)
			if [[ -e /var/log/$PACKAGE_NAME.log ]]; then
				DebugAsError "$(ShowAsPackageName "$PACKAGE_NAME") service action failed. Check $(ShowAsFileName "/var/log/$PACKAGE_NAME.log") for more information"
				AddExtLogToSessLog /var/log/$PACKAGE_NAME.log
			else
				DebugAsError "$(ShowAsPackageName "$PACKAGE_NAME") service action failed"
			fi
			;;
		*)
			DebugAsWarn "$(ShowAsPackageName "$PACKAGE_NAME") service status is unrecognised or unsupported"
	esac

	return 0

	}

QPKG.GetInstallationPath()
	{

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = the installation path to this QPKG
	#   $? = 0 if found, 250 if not

	/sbin/getcfg "${1:-${PACKAGE_NAME:-sherpa}}" Install_Path -d undefined -f /etc/config/qpkg.conf

	}

QPKG.GetServicePathFile()
	{

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = service script pathfile
	#   $? = 0 if found, 250 if not

	/sbin/getcfg "${1:-${PACKAGE_NAME:-sherpa}}" Shell -d undefined -f /etc/config/qpkg.conf

	}

QPKG.App.GetVer()
	{

	# Returns the version number of the application contained within a QPKG.

	# Input: (must specify at-least one)
	#   $1 = QPKG name
	#   $2 = QPKG index in 'packages' (optional).

	# Output:
	#   stdout = application version
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=-1			# default to not-found.

	[[ -n ${1:-} ]] || return
	[[ -n ${2:-} ]] && i=$2 || i=$(QPKG.GetArchIndex "$1")
	[[ $i -ge 0 ]] || return

	a=${QPKG_APP_VERSION[$i]}

	[[ $a = default ]] && a=${QPKG_APP_VERSION[$(QPKG.GetDefaultArchIndex "$1")]}
	[[ $a = version ]] && a=${QPKG_VERSION[$(QPKG.GetDefaultArchIndex "$1")]}

	echo -n "$a"

	return 0

	}

QPKG.Avail.GetVer()
	{

	# Returns the version number of an available QPKG.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = package version
	#   $? = 0 if found, !0 if not

	local a=''
	local b=''
	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		a=${QPKG_NAME[$i]}
		[[ $a = "$b" ]] && continue || b=$a
		[[ ${1:-${PACKAGE_NAME:-sherpa}} = "$a" ]] || continue
		echo -n "${QPKG_VERSION[$i]}"

		return 0
	done

	return 1

	}

QPKG.Local.GetVer()
	{

	# Returns the version number of an installed QPKG.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = package version
	#   $? = 0 if found, 250 if not

	/sbin/getcfg "${1:-${PACKAGE_NAME:-sherpa}}" Version -d undefined -f /etc/config/qpkg.conf

	}

QPKG.GetStoreID()
	{

	# Returns the presently assigned repository store ID of an installed QPKG.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = package store ID
	#   $? = 0 if found, 250 if not

	/sbin/getcfg "${1:-${PACKAGE_NAME:-sherpa}}" store -d sherpa -f /etc/config/qpkg.conf

	}

QPKG.IsRepoOk()
	{

	# Is this QPKG managable by sherpa?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   $? = 0 if true, 1 if false

	local a=$(QPKG.GetStoreID "${1:-${PACKAGE_NAME:-sherpa}}")

	[[ -z $a || $a = sherpa ]]

	}

QPKG.GetInstallDate()
	{

	# Returns the date specified QPKG was installed.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default: sherpa)
	#   $1 = (optional) if specified, use this as QPKG name

	# Output:
	#   stdout = package store ID
	#   $? = 0 if found, 250 if not

	/sbin/getcfg "${1:-${PACKAGE_NAME:-sherpa}}" date -d undefined -f /etc/config/qpkg.conf

	}

QPKG.IsBackupExist()
	{

	# Does this QPKG have an existing `backup` file?

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if true, 1 if false

	[[ -e $QPKG_BU_PATH/${1:?${FUNCNAME[0]}'()': undefined package name}.config.tar.gz ]]

	}

QPKG.IsDependent()
	{

	# Does this QPKG depend on any other QPKGs?

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if true, 1 if false (first package found).

	local a=''
	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		a=${QPKG_DEPENDS_ON[$i]}
		[[ $a = default ]] && a=${QPKG_DEPENDS_ON[$(QPKG.GetDefaultArchIndex "${QPKG_NAME[$i]}")]}
		[[ $a = none ]] && break

		[[ -n $a ]] && return
	done

	return 1

	}

QPKG.IsUpgradable()
	{

	# Does an upgraded QPKG exist?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false

	local a=${1:-$PACKAGE_NAME}

	QPKG.IsInstalled "$a" && QPKG.IsRepoOk "$a" && [[ $(QPKG.Local.GetVer "$a") != "$(QPKG.Avail.GetVer "$a")" ]] && QPKG.IsArchOK "$a" && QPKG.IsMinOSVerOk "$a" && QPKG.IsMinRAMOk "$a"

	}

QPKG.IsInstallable()
	{

	# Can this QPKG be installed?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false

	local a=${1:-$PACKAGE_NAME}

	! QPKG.IsInstalled "$a" && QPKG.IsRepoOk "$a" && QPKG.IsArchOK "$a" && QPKG.IsMinOSVerOk "$a" && QPKG.IsMinRAMOk "$a"

	}

QPKG.GetOriginalPath()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = the original installation path of this QPKG (even if it was migrated to another volume).
	#   $? = 0 if successful, 1 if failed

	local -i i=0

	if [[ ${#QPKGs_were_installed_name[@]} -gt 0 ]]; then
		for i in "${!QPKGs_were_installed_name[@]}"; do
			[[ ${QPKGs_were_installed_name[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
			echo -n "${QPKGs_were_installed_path[$i]}"

			return 0
		done
	fi

	return 1

	}

QPKG.MatchAbbrv()
	{

	# Input:
	#   $1 = a potential package abbreviation supplied by user.

	# Output:
	#   stdout = matched installable package name (empty if unmatched).
	#   $? = 0 (matched) or 1 (unmatched).

	local -a ar=()
	local -i i=0
	local -i j=0
	local -i z=1			# default to unmatched

	for i in "${!QPKG_NAME[@]}"; do
		ar=(${QPKG_ABBRVS[$i]})

		for j in "${!ar[@]}"; do
			[[ ${ar[$j]} = "$1" ]] || continue
			echo -n "${QPKG_NAME[$i]}"
			z=0
			break 2
		done
	done

	return $z

	}

QPKG.GetPathFilename()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = QPKG local filename.
	#   $? = 0 if successful, 1 if failed.

	local a=$(QPKG.GetURL "${1:?${FUNCNAME[0]}'()': undefined package name}")

	[[ -n $a ]] || return
	[[ $(Lowercase "${a##*.}") != qpkg ]] && a=${a%.*}.qpkg		# Swap `zip` for `qpkg` here (only for compatibilty with `QDK.zip`).

	echo -n "$QPKG_DL_PATH/$($BASENAME_CMD "$a")"

	return 0

	}

QPKG.GetHash()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = QPKG MD5, specific to this NAS arch.
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] && [[ ${QPKG_ARCH[$i]} = all || ${QPKG_ARCH[$i]} = "$NAS_QPKG_ARCH" ]] || continue
		echo -n "${QPKG_HASH[$i]}"

		return 0
	done

	return 1

	}

QPKG.GetURL()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = QPKG remote URL, specific to this NAS arch.
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] && [[ ${QPKG_ARCH[$i]} = all || ${QPKG_ARCH[$i]} = "$NAS_QPKG_ARCH" ]] || continue
		echo -n "${QPKG_URL[$i]}"

		return 0
	done

	return 1

	}

QPKG.IsArchOK()
	{

	# Does an arch-compatible QPKG exist to suit this NAS?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = (optional) if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false.

	local a=$(QPKG.GetURL "${1:-$PACKAGE_NAME}")

	[[ -n $a && $a != none ]]

	}

QPKG.GetMinRAM()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = minimum kB of installed RAM required by this QPKG (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_MIN_RAM_KB[$i]}"

		return 0
	done

	return 1

	}

QPKG.IsMinRAMOk()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if this NAS meets the minium RAM requirements for QPKG name, 1 if not.

	local a=$(QPKG.GetMinRAM "${1:?${FUNCNAME[0]}'()': undefined package name}")

	[[ -n $a ]] && [[ $a = none || $NAS_RAM_KB -ge $a ]]

	}

QPKG.GetMinOSVer()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = minimum QTS/QuTS version required by this QPKG (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_MIN_OS_VERSION[$i]}"

		return 0
	done

	return 1

	}

QPKG.IsMinOSVerOk()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if this NAS meets the minium OS firmware version requirements for QPKG name, 1 if not.

	local a=$(QPKG.GetMinOSVer "${1:?${FUNCNAME[0]}'()': undefined package name}")

	[[ -n $a ]] && [[ $a = none || ${NAS_FIRMWARE_VER//.} -ge $a ]]

	}

QPKG.GetMaxOSVer()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = maximum QTS/QuTS version required by this QPKG (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_MAX_OS_VERSION[$i]}"

		return 0
	done

	return 1

	}

QPKG.IsMaxOSVerOk()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if this NAS meets the maximum OS firmware version requirements for QPKG name, 1 if not.

	local a=$(QPKG.GetMaxOSVer "${1:?${FUNCNAME[0]}'()': undefined package name}")

	[[ -n $a ]] && [[ $a = none || ${NAS_FIRMWARE_VER//.} -le $a ]]

	}

QPKG.GetAuthor()
	{

	# Return the maintainer of the specified QPKG.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = QPKG author (first package found).
	#   $? = 0 if found, !0 if not.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_AUTHOR[$i]}"

		return 0
	done

	return 1

	}

#QPKG.GetAuthorEmail()
# 	{
#
# 	# Return the email address for the maintainer of the specified QPKG.
#
# 	# Input:
# 	#   $1 = QPKG name
#
# 	# Output:
# 	#   stdout = QPKG author (first package found).
# 	#   $? = 0 if found, !0 if not.
#
# 	local -i i=0
#
# 	for i in "${!QPKG_NAME[@]}"; do
# 		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		echo -n "${QPKG_AUTHOR_EMAIL[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

#QPKG.GetAppAuthor()
# 	{
#
# 	# Return the author of the application contained within the specified QPKG.
#
# 	# Input:
# 	#   $1 = QPKG name
#
# 	# Output:
# 	#   stdout = application author (first package found).
# 	#   $? = 0 if found, !0 if not.
#
# 	local -i i=0
#
# 	for i in "${!QPKG_NAME[@]}"; do
# 		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		echo -n "${QPKG_APP_AUTHOR[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

#QPKG.GetAppAuthorEmail()
# 	{
#
# 	# Return the email address for the author of the application contained within the specified QPKG.
#
# 	# Input:
# 	#   $1 = QPKG name
#
# 	# Output:
# 	#   stdout = application author (first package found).
# 	#   $? = 0 if found, !0 if not.
#
# 	local -i i=0
#
# 	for i in "${!QPKG_NAME[@]}"; do
# 		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		echo -n "${QPKG_APP_AUTHOR_EMAIL[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

QPKG.GetDesc()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = QPKG description (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_DESC[$i]}"

		return 0
	done

	return 1

	}

QPKG.GetNote()
	{

	# return any additional notes to be prominently displayed.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = package note (first package found).
	#   $? = 0 if found, !0 if not.

	local a=''
	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		a=${QPKG_NOTE[$i]}
		[[ $a != none ]] && echo -n "$a"

		return 0
	done

	return 1

	}

QPKG.GetAbbrvs()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = list of abbreviations that may be used to specify this package (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "${QPKG_ABBRVS[$i]}"

		return 0
	done

	return 1

	}

QPKG.GetArchIndex()
	{

	# Return the 0-based index of the named arch-specific QPKG in 'packages' file.

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   stdout = QPKG index. '-1' if a compatible arch could not be found.
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		[[ ${QPKG_ARCH[$i]} = all || ${QPKG_ARCH[$i]} = "$NAS_QPKG_ARCH" ]] || continue
		echo -n "$i"

		return 0
	done

	printf '-1'		# matching arch was not found.

	return 1

	}

QPKG.GetDefaultArchIndex()
	{

	# Return the 0-based index of the first-named QPKG in 'packages' file.

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   stdout = QPKG index. '-1' if a compatible arch could not be found.
	#   $? = 0 if successful, 1 if failed.

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		echo -n "$i"

		return 0
	done

	printf '-1'		# default arch was not found.

	return 1

	}

QPKG.GetDependencies()
	{

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   stdout = list of QPKGs this QPKG depends-upon.
	#   $? = 0 if successful, 1 if failed.

	local alt=''
	local first=''
	local found=false
	local g=''
	local -i i=-1			# default to not-found.
	local oldIFS=$IFS
	local out=''
	local x=''

	i=$(QPKG.GetArchIndex "$1")
	[[ $i -ge 0 ]] || return

	g=${QPKG_DEPENDS_ON[$i]}
	[[ $g = none ]] && return 1
	[[ $g = default ]] && g=${QPKG_DEPENDS_ON[$(QPKG.GetDefaultArchIndex "$1")]}

	if [[ $g != *'|'* ]]; then		# no alternatives were listed.
		echo -n "$g"

		return 0
	fi

	# If buffer contains a pipe character, then need to separately examine each name.
	# 	Read each name by word boundaries.
	# 	If name contains pipe, then read name with IFS as pipe.
	# 		Test each alternative name for compatibility with this NAS. Only output the compatible one.
	#		If none are compatible, then output the first name found.

	IFS=' '

	for x in $g; do
		found=false

		if [[ $x != *'|'* ]]; then
			out+=" $x"
			continue
		fi

		IFS='|'

		for alt in $x; do
			[[ -z $first && -n $alt ]] && first=$alt

			# Test alternative for compatibility

			if QPKG.IsArchOK "$alt"; then
				out+=" $alt"
				found=true
				break
			fi
		done

		[[ $IFS != "$oldIFS" ]] && IFS=$oldIFS

		if [[ $found = false ]]; then
			out+=" $first"
			first=''
		fi
	done

	echo -n "$out"

	return 0

	}

QPKG.GetIPKs()
	{

	# Input: (must specify at-least one)
	#   $1 = QPKG name
	#   $2 = QPKG index in 'packages' (optional).

	# Output:
	#   stdout = list of IPKs $1 depends-upon.
	#   $? = 0 if successful, 1 if failed.

	local a=''
	local -i i=-1			# default to not-found.

	[[ -n ${1:-} ]] || return
	[[ -n ${2:-} ]] && i=$2 || i=$(QPKG.GetArchIndex "$1")
	[[ $i -ge 0 ]] || return

	a=${QPKG_REQUIRES_IPKS[$i]}

	[[ $a = default ]] && a=${QPKG_REQUIRES_IPKS[$(QPKG.GetDefaultArchIndex "$1")]}
	[[ $a = none ]] && return 1

	echo -n "$a"

	return 0

	}

QPKG.GetDependents()
	{

	# Input: (must specify at-least one)
	#   $1 = QPKG name
	#   $2 = QPKG index in 'packages' (optional).

	# Output:
	#   stdout = list of QPKGs that depend-upon this QPKG (first package found).
	#   $? = 0 if successful, 1 if failed.

	local -a ar=()
	local -i i=-1			# default to not-found.
	local re=\\b${1:-}\\b

	if QPKGs-GRindependent.Exist "$1"; then
		for i in "${!QPKG_NAME[@]}"; do
			if [[ ${QPKG_DEPENDS_ON[$i]} =~ $re ]]; then
				[[ ${ar[*]:-} != "${QPKG_NAME[$i]}" ]] && ar+=(${QPKG_NAME[$i]})
			fi
		done
	fi

	if [[ ${#ar[@]} -gt 0 ]]; then
		echo -n "${ar[@]}"

		return 0
	fi

	return 1

	}

QPKG.IsCanBackup()
	{

	# Does this QPKG service-script support `backup` and `restore` actions?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false (first package found).

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:-$PACKAGE_NAME}" ]] || continue
		${QPKG_CAN_BACKUP[$i]} && return 0 || break
	done

	return 1

	}

QPKG.IsCanRestartToUpdate()
	{

	# Does this QPKG service-script support updating the internal application when the QPKG is restarted?

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 if true, 1 if false (first package found).

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		${QPKG_CAN_RESTART_TO_UPDATE[$i]} && return 0 || break
	done

	return 1

	}

QPKG.IsCanClean()
	{

	# Does this QPKG service-script support cleaning of the internal application?

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false (first package found).

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:-$PACKAGE_NAME}" ]] || continue
		${QPKG_CAN_CLEAN[$i]} && return 0 || break
	done

	return 1

	}

QPKG.IsCanLog()
	{

	# Does this QPKG service-script support logging of operations? When an action fails, this means user can be directed to check the service script log.

	# Input:
	#   $PACKAGE_NAME (global) = QPKG name (default).
	#   $1 = if specified, use this as QPKG name instead.

	# Output:
	#   $? = 0 if true, 1 if false (first package found).

	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:-$PACKAGE_NAME}" ]] || continue
		${QPKG_CAN_LOG_SERVICE_OPERATIONS[$i]} && return 0 || break
	done

	return 1

	}

QPKG.GetActiveTest()
	{

	# Return any custom commands required to determine if specified QPKG is active or not.

	# Input:
	#   $1 = QPKG name

	# Output:
	#   stdout = bash tests.
	#   $? = 0 if found, !0 if not.

	local a=''
	local -i i=0

	for i in "${!QPKG_NAME[@]}"; do
		[[ ${QPKG_NAME[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
		a=${QPKG_TEST_FOR_ACTIVE[$i]}
		[[ -n $a ]] || break

		echo -n "$a"

		return 0
	done

	return 1

	}

QPKG.IsInstalled()
	{

	# Input:
	#   $1 = QPKG name

	# Output:
	#   $? = 0 (true) or 1 (false)

	$GREP_CMD -q "^\[${1:?${FUNCNAME[0]}'()': undefined package name}\]" /etc/config/qpkg.conf

	}

QPKG.IsNtInstalled()
	{

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   $? = 0 (true) or 1 (false)

	! QPKG.IsInstalled "${1:?${FUNCNAME[0]}'()': undefined package name}"

	}

QPKG.IsMissing()
	{

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   $? = 0 (true) or 1 (false).

	local a=$(QPKG.GetInstallationPath "${1:?${FUNCNAME[0]}'()': undefined package name}")

	[[ $a != undefined && ! -d $a ]]

	}

QPKG.IsEnabled()
	{

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   $? = 0 (true) or 1 (false).

	[[ $(/sbin/getcfg "${1:?${FUNCNAME[0]}'()': undefined package name}" Enable -u -f /etc/config/qpkg.conf) = TRUE ]]

	}

QPKG.GetServiceStatus()
	{

	# Input:
	#   $1 = QPKG name.

	# Output:
	#   $stdout = last known package service status.
	#   $? = 0 if found, 1 if not found.

	local a=${1:?${FUNCNAME[0]}'()': undefined package name}

	[[ -e /var/run/$a.last.operation ]] && echo "$(</var/run/"$a".last.operation)"

	}

QPKG.Signing:Load()
	{

	QPKG_CERTIFICATE=''
	QPKG_SIGNATURE=''

	# This certificate block is the same used by QNAP for LicenseCenter.
	read -r -d '' QPKG_CERTIFICATE << EOB
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIFALhDVuwwDQYJKoZIhvcNAQELBQAwgYAxCzAJBgNVBAYT
AlRXMQ8wDQYDVQQIDAZUYWl3YW4xDzANBgNVBAcMBlRhaXBlaTENMAsGA1UECgwE
UU5BUDEMMAoGA1UECwwDTkFTMRAwDgYDVQQDDAdRTkFQX0NBMSAwHgYJKoZIhvcN
AQkBFhFzZWN1cml0eUBxbmFwLmNvbTAeFw0yMjAzMTgwNzM5MTRaFw0yNTAzMTcw
NzM5MTRaMIGGMQswCQYDVQQGEwJUVzEPMA0GA1UECAwGVGFpd2FuMQ8wDQYDVQQH
DAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsMA05BUzEWMBQGA1UEAwwN
TGljZW5zZUNlbnRlcjEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlAcW5hcC5jb20w
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/bAgbZryVvBXfpBHNUKQV
sAkAfvDXjKnxa7lKHrRIcFcOnf+voUZcP1Ly9qWb782gB2eUHsUS1Xqj4CF/dUJf
FEnOBrQUo9+Q9B3x4oTRpMdky7acP4dxAbt4T92swgaReQXAewy9s9//a52HIBca
1dAA4JPwplqiZ/oh18GDCKxh84Iu9Gcu2J5e+VXEI/KUxCwKUd22aDTpv128MSoq
dYexCerCJtQbgM3cwkkMiDnFpjrsta5iFpyrNKdLoBJ7YbY3d5Onkqy4DjE8hwR7
0j7Qd+3xbMqv3FOCKeLLLn6N03IXHKP/big/MdXKY1dJQVA3/ks/knPH8mhcOM0d
AgMBAAGjPDA6MDgGA1UdHwQxMC8wLaAroCmGJ2h0dHA6Ly9kb3dubG9hZC5xbmFw
LmNvbS9jcmwvcXRzX3YxLmNybDANBgkqhkiG9w0BAQsFAAOCAQEAWlT1GDH6v8G3
laIAs2/RdxhPgtKX4aL+fnTEFNF5V2yH0G4luyq5tHQw+VCHtDM6Z3GXWhciKPAR
upbRcHq744JCFaUb6i8z1w1KVJDaQ38EVE5+JtpoPMrrnb+hKB/gGmi4PoMSpnvX
VCxLbCbBnwi19o6t/MnPbz0shvUB2NDngnal6lYQFw/F8Sr6cSjV6GAY4TOZotdu
+gunwqQtYUycEVfNyiWVk/flgED8R8oxTPl9ZoDGen+OgjkZrvgynKnqPLHyxZSd
hYSoWyWcZWkMCQ+69kOgJVvrRa7z9F9y30uAHXIUrsLV2d/dImVjApMHbZ60iALG
AVIlas0e4g==
-----END CERTIFICATE-----
EOB

	# This digital signature block is the same used by QNAP for LicenseCenter.
	read -r -d '' QPKG_SIGNATURE << EOB
MIME-Version: 1.0
Content-Disposition: attachment; filename="smime.p7m"
Content-Type: application/pkcs7-mime; smime-type=signed-data; name="smime.p7m"
Content-Transfer-Encoding: base64

MIIGtAYJKoZIhvcNAQcCoIIGpTCCBqECAQExDTALBglghkgBZQMEAgEwIwYJKoZI
hvcNAQcBoBYEFAkoseBaFir08zCz63r2YA82DXzxoIIDxzCCA8MwggKroAMCAQIC
BQC4Q1bsMA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJUVzEPMA0GA1UECAwG
VGFpd2FuMQ8wDQYDVQQHDAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsM
A05BUzEQMA4GA1UEAwwHUU5BUF9DQTEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlA
cW5hcC5jb20wHhcNMjIwMzE4MDczOTE0WhcNMjUwMzE3MDczOTE0WjCBhjELMAkG
A1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UEBwwGVGFpcGVpMQ0wCwYD
VQQKDARRTkFQMQwwCgYDVQQLDANOQVMxFjAUBgNVBAMMDUxpY2Vuc2VDZW50ZXIx
IDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAv2wIG2a8lbwV36QRzVCkFbAJAH7w14yp8Wu5Sh60
SHBXDp3/r6FGXD9S8valm+/NoAdnlB7FEtV6o+Ahf3VCXxRJzga0FKPfkPQd8eKE
0aTHZMu2nD+HcQG7eE/drMIGkXkFwHsMvbPf/2udhyAXGtXQAOCT8KZaomf6IdfB
gwisYfOCLvRnLtieXvlVxCPylMQsClHdtmg06b9dvDEqKnWHsQnqwibUG4DN3MJJ
DIg5xaY67LWuYhacqzSnS6ASe2G2N3eTp5KsuA4xPIcEe9I+0Hft8WzKr9xTgini
yy5+jdNyFxyj/24oPzHVymNXSUFQN/5LP5Jzx/JoXDjNHQIDAQABozwwOjA4BgNV
HR8EMTAvMC2gK6AphidodHRwOi8vZG93bmxvYWQucW5hcC5jb20vY3JsL3F0c192
MS5jcmwwDQYJKoZIhvcNAQELBQADggEBAFpU9Rgx+r/Bt5WiALNv0XcYT4LSl+Gi
/n50xBTReVdsh9BuJbsqubR0MPlQh7QzOmdxl1oXIijwEbqW0XB6u+OCQhWlG+ov
M9cNSlSQ2kN/BFROfibaaDzK652/oSgf4BpouD6DEqZ711QsS2wmwZ8ItfaOrfzJ
z289LIb1AdjQ54J2pepWEBcPxfEq+nEo1ehgGOEzmaLXbvoLp8KkLWFMnBFXzcol
lZP35YBA/EfKMUz5fWaAxnp/joI5Ga74Mpyp6jyx8sWUnYWEqFslnGVpDAkPuvZD
oCVb60Wu8/Rfct9LgB1yFK7C1dnf3SJlYwKTB22etIgCxgFSJWrNHuIxggKbMIIC
lwIBATCBijCBgDELMAkGA1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UE
BwwGVGFpcGVpMQ0wCwYDVQQKDARRTkFQMQwwCgYDVQQLDANOQVMxEDAOBgNVBAMM
B1FOQVBfQ0ExIDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tAgUAuENW
7DALBglghkgBZQMEAgGggeQwGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkq
hkiG9w0BCQUxDxcNMjIxMjAyMDMwOTE3WjAvBgkqhkiG9w0BCQQxIgQgvtdZSm+m
c7QevdJma9Em5ycFr3I7Wo4aG40Vcx/mT5IweQYJKoZIhvcNAQkPMWwwajALBglg
hkgBZQMEASowCwYJYIZIAWUDBAEWMAsGCWCGSAFlAwQBAjAKBggqhkiG9w0DBzAO
BggqhkiG9w0DAgICAIAwDQYIKoZIhvcNAwICAUAwBwYFKw4DAgcwDQYIKoZIhvcN
AwICASgwDQYJKoZIhvcNAQEBBQAEggEAuInAOUj+ebOkTqlqg3cf7v2FdKeCvZZn
cunx1xRnHJRVAAvcH/UZ3t7RF6MV5NmEQdVN79NBZl0KU1x7K3zyvcXnkacNuHnI
t+6neKKKkxJmB4hh4ljeYtx9a1RBgwH+PiYyH8+58S7+MF3MVhSH8jEiomgSbvsK
BroOCFQDoYWk14K/VIXW1scmvpNvFNBWwm19pYwi977rF+lPWzMHx/0jVXspFSEd
U48h9xKvPg6CsIlyfuKetHBjZZI6iSCvh2FZOWsD1/W2oGYkkY9Hdff24B34/res
cKXk/K9/JFAONWBbXUpxtzpBCeVJlZS1wQgu4Q+Fr6imaBXJkiyiNg==
EOB

	readonly QPKG_CERTIFICATE
	readonly QPKG_SIGNATURE

	}

MakePath()
	{

	# Input:
	#   $1 = path to create.
	#   $2 = reason for this path.

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined path} && -n ${2:?${FUNCNAME[0]}'()': undefined reason} ]] || return

	if [[ $1 != undefined ]] && ! mkdir -p "$1"; then
		ShowAsError "unable to create $2 path $(ShowAsFileName "$1") $(ShowAsExitcode "$?")"
		show_suggest_raise_issue=true

		return 1
	fi

	return 0

	}

ClearPath()
	{

	# Clear (empty) an existing directory, but don't delete the directory.
	# Delete files in a relatively safe manner. Parent of directory MUST be specified to avoid an 'rm -rf /*' situation through empty args.

	# Input:
	#	$1 = full path to parent of directory name to clear.
	#   $2 = directory name to clear.

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined parent path} && -n ${2:?${FUNCNAME[0]}'()': undefined target path} ]] || return

	local parent=${1:-undefined}
	local target=$($BASENAME_CMD "${2:-undefined}")

	[[ -n $parent && $parent != undefined && -n $target && $target != undefined && -d $parent/$target ]] && rm -rf "${parent:?}/${target:?}"/*

	}

RunAndLog()
	{

	# Run a commandstring, log the results, and show onscreen if required.

	# Input:
	#   $1 = commandstring to execute.
	#   $2 = pathfile to record stdout and stderr for commandstring.
	#   $3 = `log:failure-only` (optional) - if specified, stdout & stderr are only recorded in the specified log if the command failed. default is to always record stdout & stderr.
	#   $4 = e.g. `10` (optional) - an additional acceptable result code. Any other result from command (other than zero) will be considered a failure.

	# Output:
	#   stdout = commandstring stdout and stderr if script is in `debug` mode.
	#   pathfile (specified as $2) = stdout and stderr from commandstring (specified as $1).
	#   $? = result_code of commandstring.

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined commandstring} && -n ${2:?${FUNCNAME[0]}'()': undefined pathfile} ]] || return

	Func:Init

	MakePath "$RUN_LOGS_PATH" 'runtime logs'

	local -r LOG_PATHFILE=$($MKTEMP_CMD "$RUN_LOGS_PATH"/"${FUNCNAME[0]}"_XXXXXX)
	local -i z=0

	ShowAsCommand "$1" > "$2"
	DebugAsProc "exec: '$1'"

	if [[ $useropt_verbose = true ]]; then
		eval "$1 > >($TEE_CMD $LOG_PATHFILE) 2>&1"		# NOTE: `tee` buffers stdout here
		z=$?
	else
		(eval "$1" > "$LOG_PATHFILE" 2>&1)				# run in a subshell to suppress 'Terminated' message later
		z=$?
	fi

	if [[ -e $LOG_PATHFILE ]]; then
		ShowAsResultAndStdout "$z" "$(<"$LOG_PATHFILE")" >> "$2"
		rm -f "$LOG_PATHFILE"
	else
		ShowAsResultAndStdout "$z" '<null>' >> "$2"
	fi

	case $z in
		0|"${4:-}")
			[[ ${3:-} != log:failure-only || $useropt_debug = true ]] && AddExtLogToSessLog "$2"
			DebugAsDone 'exec: complete'
			[[ $useropt_debug = false ]] && rm -f "$2"
			;;
		*)
			AddExtLogToSessLog "$2"
			DebugAsError 'exec: complete, but with errors'
	esac

	Func:Exit $z

	}

DeDupeWords()
	{

	[[ -n ${1:-} ]] || return

	tr ' ' '\n' <<< "$1" | $SORT_CMD | $UNIQ_CMD | tr '\n' ' ' | $SED_CMD 's|^[[:blank:]]*||;s|[[:blank:]]*$||'

	}

FileMatchesMD5()
	{

	# Input:
	#   $1 = pathfile to generate an MD5 checksum for.
	#   $2 = MD5 checksum to compare against.

	[[ $($MD5SUM_CMD "${1:?${FUNCNAME[0]}'()': undefined pathfile}" | cut -f1 -d' ') = "${2:?${FUNCNAME[0]}'()': undefined checksum}" ]]

	}

Pluralise()
	{

	[[ ${1:-0} -ne 1 ]] && printf s

	}

Capitalise()
	{

	# Capitalise first character of $1.

	[[ -n ${1:-} ]] || return

	if [[ $1 == sherpa* ]]; then
		echo -n "$1"
	else
		echo -n "$(Uppercase ${1:0:1})${1:1}"
	fi

	}

Uppercase()
	{

	tr 'a-z' 'A-Z' <<< "${1:-}"

	}

Lowercase()
	{

	tr 'A-Z' 'a-z' <<< "${1:-}"

	}

LTrim()
	{

	# Trim leading whitespace from $1.

	[[ -n ${1:-} ]] || return

	(shopt -s extglob; printf '%s' "${1##+(' ')}")

	}

RTrim()
	{

	# Trim trailing whitespace from $1.

	[[ -n ${1:-} ]] || return

	(shopt -s extglob; printf '%s' "${1%%+(' ')}")

	}

Trim()
	{

	# Trim leading and trailing whitespace from $1.

	[[ -n ${1:-} ]] || return

	RTrim "$(LTrim "$1")"

	}

FormatAsThous()
	{

	# Format as thousands.

	# A string-based thousands-group formatter totally unreliant on locale.
	# Why? Because builtin `printf` in 32b ARM QTS versions doesn't follow locale. ¯\_(ツ)_/¯

	# $1 = integer value

	local a=$($SED_CMD 's/[^0-9]*//g' <<< "${1:-}")	# Strip everything not a numeral.
	local b=''
	local c=''

	while [[ ${#a} -gt 0 ]]; do
		b=${a:${#a}<3?0:-3}							# A nifty trick found here: https://stackoverflow.com/a/19858692

		if [[ -z $c ]]; then
			c=$b
		else
			c=$b,$c
		fi

		if [[ ${#b} -eq 3 ]]; then
			a=${a%???}								# Trim rightside 3 characters.
		else
			break
		fi
	done

	echo -n "$c"

	return 0

	}

FormatAsIsoBytes()
	{

	$AWK_CMD 'BEGIN{ u[0]="B"; u[1]="kB"; u[2]="MB"; u[3]="GB"} { n = $1; i = 0; while(n > 1000) { i+=1; n= int((n/1000)+0.5) } print n u[i] } ' <<< "$1"

	}

Title:Show()
	{

	[[ $show_title = true && $title_shown = false && $useropt_verbose = false ]] || return

	EraseThisLine

	# Only show ASCII title when no arguments have been specified.

	if [[ -z ${ARGS_RAW[*]:-} ]]; then
		Display "$(ShowTitleArt)"
	else
		Display "$(ShowAsTitleName) $(ShowAsVersion)"
	fi

	title_shown=true

	}

ShowAsTitleName()
	{

	TextBrightWhite sherpa

	}

ShowTitleArt()
	{

	Display "$(TextBrightOrange '     _')"
	Display "$(TextBrightOrange ' ___| |__   ___ _ __ _ __   __ _')"
	Display "$(TextBrightOrange "/ __| '_ \ / _ \ '__| '_ \ / _\` |")  $(ShowAsDescription)"
	Display "$(TextBrightOrange '\__ \ | | |  __/ |  | |_) | (_| |')  $(ShowAsCopyrightBasic)"
	Display "$(TextBrightOrange '|___/_| |_|\___|_|  | .__/ \__,_|')  $(ShowAsVersion)"
	Display "$(TextBrightOrange '                    |_|')"

	}

ShowAsDescription()
	{

	printf '%s' '<?title_description?>'

	}

ShowAsCopyrightBasic()
	{

	printf '%s' '<?copyright_basic?>'

	}

ShowAsVersion()
	{

	printf '%s' "v$THIS_SCRIPT_VER"

	}

#ShowAsEmail()
# 	{
#
# # 	printf '%s' '<?email?>'
# 	TextUnderlinedCyan '<?email?>'
#
# 	}

ShowAsAction()
	{

	TextBrightYellow '[action]'

	}

ShowAsPackages()
	{

	TextBrightOrange '[packages]'

	}

ShowAsPackageGroup()
	{

	TextBrightOrange '[package group]'

	}

ShowAsOptions()
	{

	TextBrightRed '[options]'

	}

ShowAsPackageName()
	{

	printf '%s' "${1:?${FUNCNAME[0]}'()': undefined package name}"

	}

ShowAsFileName()
	{

	printf '%s' "'${1:?${FUNCNAME[0]}'()': undefined filename}'"

	}

ShowAsURL()
	{

	TextUnderlinedCyan "${1:?${FUNCNAME[0]}'()': undefined URL}"

	}

ShowAsExitcode()
	{

	printf '%s' "[${1:?${FUNCNAME[0]}'()': undefined exitcode}]"

	}

ShowAsLogFilename()
	{

	printf '%s' "${CHARS_RESULTS}log file: '${1:?${FUNCNAME[0]}'()': undefined filename}'"

	}

ShowAsCommand()
	{

	echo "${CHARS_RESULTS}command: '${1:?${FUNCNAME[0]}'()': undefined commandstring}'"

	}

ShowAsResultAndStdout()
	{

	[[ -n ${1:-} ]] || return
	[[ -n ${2:-} ]] || return

	local a=$CHARS_RESULTS

	[[ ${1:-0} -ne 0 ]] && a=$CHARS_ALERT

	echo "${a}result_code: $(ShowAsExitcode "$1") ***** stdout/stderr begins below *****"
	echo "$2"
	echo "${a}***** stdout/stderr is complete *****"

	}

DisplayProcReport()
	{

	# Input:
	#	$1 = report type (optional)

	[[ ${report_title_shown:=false} = false ]] || return

	local a=''

	[[ -n ${1:-} ]] && a="$1 "

	ShowAsProc "${a}report"

	report_title_shown=true

	}

DebugInfoMajSepr()
	{

	# Debug info major separator.

	DebugInfo "$(eval printf '%0.s=' "{1..$DEBUG_LOG_DATAWIDTH}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugInfoMinSepr()
	{

	# Debug info minor separator.

	DebugInfo "$(eval printf '%0.s-' "{1..$DEBUG_LOG_DATAWIDTH}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugExtLogMinSepr()
	{

	# Debug external log minor separator.

	DebugAsLog "$(eval printf '%0.s-' "{1..$DEBUG_LOG_DATAWIDTH}")" # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugScript()
	{

	DebugDetectTabld SCRIPT "${1:-}" "${2:-}"

	}

DebugHardware()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld HARDWARE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld HARDWARE "${2:-}" "${3:-}"
	esac

	}

DebugFirmware()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld FIRMWARE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld FIRMWARE "${2:-}" "${3:-}"
	esac

	}

DebugUserspace()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld USERSPACE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld USERSPACE "${2:-}" "${3:-}"
	esac

	}

DebugIpk()
	{

	case ${1:-} in
		error)
			DebugErrorTabld IPK "${2:-}" "${3:-}"
			;;
		*)
			DebugInfoTabld IPK "${2:-}" "${3:-}"
	esac

	}

DebugQpkg()
	{

	case ${1:-} in
		error)
			DebugErrorTabld QPKG "${2:-}" "${3:-}"
			;;
		warning)
			DebugWarningTabld QPKG "${2:-}" "${3:-}"
			;;
		info)
			DebugInfoTabld QPKG "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld QPKG "${2:-}" "${3:-}"
	esac

	}

DebugDetectTabld()
	{

	# Debug detected tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and `none` as third field.
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugInfoTabld()
	{

	# Debug info tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and `none` as third field.
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugWarningTabld()
	{

	# Debug warning tabulated.

	if [[ -z ${3:-} ]]; then			# if $3 is nothing, then assume only 2 fields are required
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# if $3 is only a whitespace then print $2 with trailing colon and `none` as third field
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# if $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugErrorTabld()
	{

	# Debug error tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and `none` as third field.
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugVar()
	{

	# Input:
	#   $1 = variable name

	# Output:
	#   to debug log

	if [[ -n ${!1:-} ]]; then
		DebugAsVar "\$$1 : '${!1}'"
	else
		DebugAsVar "\$$1 : null"
	fi

	}

DebugArray()
	{

	# Input:
	#   $1 = array name
	#   $2 = array contents: i.e. "${myarray[*]}"

	# Output:
	#   to debug log

	[[ -n ${1:-} ]] || return

	if [[ -n ${2:-} ]]; then
		DebugAsArray "\$$1 : ['$2']"
	else
		DebugAsArray "\$$1 : [null]"
	fi

	}

DebugInfo()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${2:-} = ' ' || ${2:-} = "'' " ]]; then	# If $2 has no usable content then print $1 with trailing colon and `none` as second field.
		DebugAsInfo "$1: none"
	elif [[ -n ${2:-} ]]; then
		DebugAsInfo "$1: ${2:-}"
	else
		DebugAsInfo "$1"
	fi

	}

Func:Init()
	{

	# Debug function entry.

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	eval "$var_safe_name=$(/bin/date +%s%N)"

	DebugAsFuncEn

	}

Func:Exit()
	{

	# Debug function exit.

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	DebugAsFuncEx "${1:-0}" "$(ShowAsDuration "$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")")"

	return ${1:-0}

	}

FuncFork:Init()
	{

	# Debug forked function entry.

	# Redirect debug output to a temporary log, then add it to session log before exiting. This will keep action log progress in-order.
	original_sess_active_pathfile=$sess_active_pathfile
	MakePath "$ACTION_LOGS_PATH" 'action logs'
	sess_active_pathfile=$($MKTEMP_CMD "$ACTION_LOGS_PATH"/"${FUNCNAME[1]}"_XXXXXX)

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}
	eval "$var_safe_name=$(/bin/date +%s%N)"

	DebugAsFuncEn

	}

FuncFork:Exit()
	{

	# Debug forked function exit.

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	SendActionStatus ex
	DebugAsFuncEx "${1:-0}" "$(ShowAsDuration "$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")")"

	if [[ -n $sess_active_pathfile && -e $sess_active_pathfile ]]; then
		if [[ -s $sess_active_pathfile ]]; then
			$CAT_CMD "$sess_active_pathfile" >> "$original_sess_active_pathfile"
		fi

		rm -f "$sess_active_pathfile"
	fi

	sess_active_pathfile=$original_sess_active_pathfile
	original_sess_active_pathfile=''

	exit ${1:-0}

	}

CalcMilliDifference()
	{

	# Input:
	#	$1 = starttime in epoch nanoseconds
	#	$2 = endtime in epoch nanoseconds

	# Output:
	#	stdout = difference in milliseconds

	echo -n "$((($2-$1)/1000000))"

	}

ShowAsDuration()
	{

	# Input:
	#	$1 = duration in milliseconds

	if [[ ${1:-0} -lt 30000 ]]; then
		echo -n "$(FormatAsThous "${1:-0}")ms"
	else
		FormatSecsToHoursMinutesSecs "$(($1/1000))"
	fi

	}

DebugAsFuncEn()
	{

	DebugThis "(>>) ${FUNCNAME[2]}()"

	}

DebugAsFuncEx()
	{

	DebugThis "(<<) ${FUNCNAME[2]}|${1:-0}|${2:-}"

	}

DebugAsProc()
	{

	[[ -n $1 ]] && DebugThis "(--) $1"

	}

DebugAsDone()
	{

	[[ -n $1 ]] && DebugThis "(==) $1"

	}

DebugAsDetect()
	{

	[[ -n $1 ]] && DebugThis "(**) $1"

	}

DebugAsInfo()
	{

	[[ -n $1 ]] && DebugThis "(II) $1"

	}

DebugAsWarn()
	{

	[[ -n $1 ]] && DebugThis "(WW) $1"

	}

DebugAsError()
	{

	[[ -n $1 ]] && DebugThis "(EE) $1"

	}

DebugAsLog()
	{

	[[ -n $1 ]] && DebugThis "(LL) $1"

	}

DebugAsVar()
	{

	[[ -n $1 ]] && DebugThis "(vv) $1"

	}

DebugAsArray()
	{

	[[ -n $1 ]] && DebugThis "(aa) $1"

	}

DebugThis()
	{

	[[ -n ${1:-} ]] || return

	[[ ${useropt_verbose:-false} = true ]] && ShowAsDebug "$1"
	WriteToLog dbug "$1"

	}

AddExtLogToSessLog()
	{

	# Add the contents of pathfile $1 to the session debug log, with each line formatted as an external log entry.

	local a=''
	local b=false

	if [[ $useropt_verbose = true ]]; then   # Prevent external log contents appearing onscreen again, because they've already been seen "live".
		b=true
		useropt_verbose=false
	fi

	DebugAsLog 'adding external log to main log'
	DebugExtLogMinSepr
	DebugAsLog "$(ShowAsLogFilename "${1:?${FUNCNAME[0]}'()': undefined pathfile}")"

	while read -r a; do
		DebugAsLog "$a"
	done < "$1"

	DebugExtLogMinSepr
	useropt_verbose=$b

	}

ShowAsProcLong()
	{

	ShowAsProc "${1:-} (might take a while)" "${2:-}"

	} >&2

ShowAsProc()
	{

	# Input:
	#	$1 = task being carried-out.
	#	$2 = trailing task (after the ellipsis) (optional). If specified, $useropt_terse will be ignored.

	local a=''
	local b=''

	[[ -n ${1:-} ]] && a=$1 || return
	[[ -n ${2:-} ]] && b=${2:-}

	if [[ ${useropt_verbose:=false} = false && ${useropt_terse:=true} = true ]] || [[ ${useropt_verbose:=false} = false && -n ${2:-} ]]; then
		OpStepClearWait "$(TextBrightYellow proc)" "$a $CHARS_ELLIPSIS $b"
	else
		OpStepClear "$(TextBrightYellow proc)" "$a $CHARS_ELLIPSIS $b"
	fi

	WriteToLog proc "${a}${b}"

	} >&2

ShowAsDebug()
	{

	[[ -n ${1:-} ]] || return

	OpStepClear "$(TextBlackOnCyan dbug)" "$1"

	}

ShowAsNote()
	{

	# Note to user.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightYellow note)" "$a"
	WriteToLog note "$a"

	} >&2

ShowAsDone()
	{

	# Process completed OK.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightGreen 'done')" "$a"
	WriteToLog 'done' "$a"

	} >&2

ShowAsWarn()
	{

	# Warning only.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightOrange warn)" "$a"
	WriteToLog warn "$a"

	} >&2

ShowAsAbort()
	{

	# Fatal abort.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed bort)" "$a"
	WriteToLog bort "$a"
	Error:Set

	} >&2

ShowAsFail()
	{

	# Non-fatal error.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed fail)" "$a"
	WriteToLog fail "$a"

	} >&2

ShowAsError()
	{

	# Fatal error.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed derp)" "$a"
	WriteToLog derp "$a"
	Error:Set

	} >&2

ShowAsQuiz()
	{

	[[ -n ${1:-} ]] || return

	OpStepClearWait "$(TextBrightOrangeBlink quiz)" "$1:"
	WriteToLog quiz "$1:"

	}

ShowAsQuizDone()
	{

	[[ -n ${1:-} ]] || return

	OpStepClear "$(TextBrightOrange quiz)" "$1"

	}

AddPeriod()
	{

	[[ -n ${1:-} ]] || return

	[[ ${1: -1} != ':' && ${1: -1} != '?' && ${1: -1} != '.' ]] && printf '%s' "${1}." || printf '%s' "$1"

	}

ShowAsPercentProgress()
	{

	# Show single action package progress as percent-complete and a fraction of the total.

	# Input:
	#	$1 = verb (present) (optional)
	#	$2 = expected action duration: `long` (optional)
	#	$3 = ok count
	#	$4 = skip count
	#	$5 = fail count
	#	$6 = total count

	local -r a=${1:-}
	local -i b=${3:-0}
	local -i c=${4:-0}
	local -i d=${5:-0}
	local -i e=${6:-0}
	local -r f=$(PercFrac "$b" "$c" "$d" "$e")

	if [[ ${2:-} != long ]]; then
		ShowAsProc "$a" "$f"
	else
		ShowAsProcLong "$a" "$f"
	fi

	[[ $((b+c+d)) -ge $e ]] && sleep 0.5

	return 0

	} >&2

PercFrac()
	{

	# Calculate percent-complete and a fraction of the total.

	# Input:
	#	$1 = ok count
	#	$2 = skip count
	#	$3 = fail count
	#	$4 = total count

	local -i a=$((${1:-0}+${2:-0}+${3:-0}))
	local -i b=${4:-0}
	local c=''

	[[ $b -gt 0 ]] || return		# No-point calculating a fraction of zero.

	if [[ $a -gt $b ]]; then
		a=$b
		c='100%'
	else
		c="$((200*(a+1)/(b+1)%2+100*(a+1)/(b+1)))%"
	fi

	echo -n "$c ($(TextBrightWhite "$a")/$(TextBrightWhite "$b"))"

	return 0

	} 2>/dev/null

ShowAsIterativeProgress()
	{

	# Show single action package progress as an incrementing amount with no limit.

	# Input:
	#	$1 = operation 		"calculating"
	#	$2 = count1			15
	#	$3 = suffix1		"iterations"
	#	$4 = count2			560
	#	$5 = suffix2		"packages"
	#	$6 = expected action duration: `long` (optional) `short` (default)

	local -r a=${1:?${FUNCNAME[0]}'()': undefined action}
	local -i b=${2:-0}
	local -r c=${3:?${FUNCNAME[0]}'()': undefined suffix1}
	local -i d=${4:-0}
	local -r e=${5:?${FUNCNAME[0]}'()': undefined suffix2}
	local f=''

	f="$(TextBrightWhite "$b") ${c}$(Pluralise "$b"): $(TextBrightWhite "$d") ${e}$(Pluralise "$d")"

	if [[ ${6:-short} != long ]]; then
		ShowAsProc "$a" "$f"
	else
		ShowAsProcLong "$a" "$f"
	fi

	return 0

	}

ShowAsActionLogDetail()
	{

	# Input:								example:
	#   $1 = datetime in seconds (unused)
	#   $2 = package or group name			`SABnzbd`, `essential`
	#   $3 = action							`download`, 'downloaded'
	#   $4 = result							`ok`, `skipped-ok`, `skipped`, `failed`
	#   $5 = duration in milliseconds
	#   $6 = reason (optional)				"file already exists in local cache"

	if [[ ${2:-undefined} = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$2"

		return 1
	fi

	case ${4:-} in
		failed)
			if [[ -n "${6:-}" ]]; then
				# Must use different behaviours depending on action.

				case $3 in
					download|?(reas)sign|uninstall)
						DisplayAsIndentActionResultDurationReason "$3" "$2" "$5" "$6"
						;;
					*)
						if QPKG.IsCanLog "$2"; then
							DisplayAsIndentActionResultDurationReason "$3" "$2" "$5" "For more information: /etc/init.d/$($BASENAME_CMD "$(QPKG.GetServicePathFile "$2")") log"
						else
							DisplayAsIndentActionResultDurationReason "$3" "$2" "$5" "$6"
						fi
				esac
			else
				DisplayAsIndentActionResultDurationReason "$3" "$2" "$5" 'no reason was provided by the service script'
			fi
			;;
		skipped*)
			if [[ -n "${6:-}" ]]; then
				DisplayAsIndentActionResultDurationReason "$3" "$2" '' "$6"
			else
				DisplayAsIndentActionResultDurationReason "$3" "$2" '' "no reason provided"
			fi
			;;
		*)
			DisplayAsIndentActionResultDurationReason "$3" "$2" "$5"
	esac

	return 0

	}

OpStepClearWait()
	{

	# Displays script operation message from beginning of line, remain on this line, and leave cursor at end.

	# Input:
	#	$1 = a 4 character string such as `info`, `proc`, `done`, `derp`.
	#	$2 = detailed message.

	local -i n=4			# Width of the message type.

	[[ ${useropt_colourful:=false} = true ]] && n=10  	# Allow extra length for ANSI codes in message type.

	DisplayWait "$(printf "\033[2K\r%-${n}s: %s" "${1:-}" "${2:-}")"

	return 0

	}

OpStepClear()
	{

	# Displays script operation message from beginning of line, jump down a line, and leave cursor at start.

	# Input:
	#	$1 = a 4 character string such as `info`, `proc`, `done`, `derp`.
	#	$2 = detailed message.

	local -i n=4			# Width of the message type.

	[[ ${useropt_colourful:=false} = true ]] && n=10  	# Allow extra length for ANSI codes in message type.

	Display "$(printf "\033[2K\r%-${n}s: %s" "${1:-}" "${2:-}")"

	return 0

	}

WriteToLog()
	{

	# Input:
	#	$1 = pass/fail
	#	$2 = message

	[[ -n ${1:-} && -n ${2:-} ]] || return

	[[ ${useropt_debug:=false} = true && -n $sess_active_pathfile ]] && printf '%-4s: %s\n' "$(StripANSICodes "$1")" "$(StripANSICodes "$2")" >> "$sess_active_pathfile"

	}

TextBrightGreen()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;32m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightYellow()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;33m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightOrange()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;38;5;214m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightOrangeBlink()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;5;38;5;214m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightRed()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;31m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightRedBlink()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;5;31m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

#TextCyan()
# 	{
#
# 	[[ -n ${1:-} ]] || return
#
# 	if [[ ${useropt_colourful:=false} = true ]]; then
# 		printf '\033[1;36m%s\033[0m' "$1"
# 	else
# 		printf '%s' "$1"
# 	fi
#
# 	} 2>/dev/null

TextDarkGrey()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;90m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

#TextUnderlined()
# 	{
#
# 	[[ -n ${1:-} ]] || return
#
# 	if [[ ${useropt_colourful:=false} = true ]]; then
# 		printf '\033[4m%s\033[0m' "$1"
# 	else
# 		printf '%s' "$1"
# 	fi
#
# 	} 2>/dev/null

TextUnderlinedCyan()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[4;36m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBlackOnCyan()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[30;46m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

TextBrightWhite()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;97m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2>/dev/null

StripANSICodes()
	{

	# QTS 4.2.6 BusyBox `sed` doesn't fully support extended regexes, so code-stripping only works with a real `sed`.

	if [[ -e /opt/bin/sed && -L /opt/etc/passwd ]]; then	# Try to ensure Entware is active first.
		/opt/bin/sed -r 's/\x1b\[[0-9;]*m//g' <<< "${1:-}"	# https://superuser.com/a/380778
	else
		printf '%s' "${1:-}"		# Can't strip, so pass thru original message unaltered.
	fi

	} 2>/dev/null

UpdateColourisation()
	{

	# If it seems Entware is active, check if possible to return to colourful display.

	if [[ -e /opt/bin/sed && -L /opt/etc/passwd && $(LoadSetting Colourful "$colourful_default") = true ]]; then
		useropt_colourful=true
		SendParentChangeEnv 'useropt_colourful=true'
	else
		useropt_colourful=false
		SendParentChangeEnv 'useropt_colourful=false'
	fi

	}

Cursor:Hide()
	{

	[[ $useropt_verbose = false ]] && printf '\033[?25l'

	}

Cursor:Show()
	{

	printf '\033[?25h'

	}

Keystrokes:Hide()
	{

	[[ $useropt_verbose = false && -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD '-echo'

	}

Keystrokes:Show()
	{

	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD 'echo'

	}

FormatMillisecsToMinutesSecs()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# Input:
	#	$1 = a time in milliseconds to convert to `S seconds` or `Mm:SSs`.

	local seconds=$((${1:-0}/1000))
	((m=(seconds%3600)/60))
	((s=seconds%60))

	[[ $s -eq 0 ]] && s=1

	if [[ $m -eq 0 ]]; then
		if [[ $s -eq 1 ]]; then
			printf '%d second' "$s"
		else
			printf '%d seconds' "$s"
		fi
	else
		printf '%dm:%02ds' "$m" "$s"
	fi

	} 2>/dev/null

FormatSecsToHoursMinutesSecs()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# Input:
	#	$1 = a time in seconds to convert to `HHh:MMm:SSs`.

	((h=${1:-0}/3600))
	((m=(${1:-0}%3600)/60))
	((s=${1:-0}%60))

	printf '%01dh:%02dm:%02ds\n' "$h" "$m" "$s"

	} 2>/dev/null

FormatLongMinutesSecs()
	{

	# Input:
	#	$1 = a time in long minutes and seconds to convert to `MMMm:SSs`.

	# separate minutes from seconds
	local m=${1%%:*}
	local s=${1#*:}

	# remove leading whitespace
	m=${m##* }
	s=${s##* }

	printf '%01dm:%02ds\n' "$((10#$m))" "$((10#$s))"

	} 2>/dev/null

sleep()
	{

	# Input:
	#	$1 = seconds to sleep (decimal or integer) (optional), default is 1 second.

	local n=${1:-}

	[[ ${n//.} -eq 0 ]] && n=1

	if [[ -e $GNU_SLEEP_CMD && -L /opt/etc/passwd ]]; then  # Try to ensure Entware is active first.
		$GNU_SLEEP_CMD "$n"
	elif [[ $DECIMAL_SLEEP_SECONDS_SUPPORTED = false ]]; then
		$SLEEP_CMD "$((${n%.*}+1))"							# Ensure decimal seconds are rounded-up to next integer.
	else
		$SLEEP_CMD "$n"
	fi

	return 0

	} 2>/dev/null

Objects:Load()
	{

	# Ensure `objects` in the local cache is up-to-date, then source it.

	[[ ${objects_loaded:=false} = false ]] || return 0

	Func:Init

	Lists:Load

	if [[ ! -e $PWD/dont-refresh-objects ]]; then
		if [[ ! -e $OBJECTS_PATHFILE ]] || ! IsThisFileRecent "$OBJECTS_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES"; then
			ShowAsProc 'download objects'

			if $CURL_CMD --silent --fail "$OBJECTS_ARCHIVE_URL" > "$OBJECTS_ARCHIVE_PATHFILE"; then
				$TAR_CMD --extract --gzip --no-same-owner --file="$OBJECTS_ARCHIVE_PATHFILE" --directory="$CACHE_PATH"
			fi
		fi
	fi

	if [[ ! -e $OBJECTS_PATHFILE ]]; then
		ShowAsAbort 'objects missing'

		Func:Exit 1; exit
	fi

	ShowAsProc objects

	. "$OBJECTS_PATHFILE"
	objects_loaded=true

	readonly OBJECTS_VER
	DebugVar OBJECTS_VER

	Func:Exit

	}

Packages:Load()
	{

	# Ensure `packages` in the local cache is up-to-date, then source it.

	[[ ${packages_loaded:=false} = false ]] || return 0

	Func:Init

	Objects:Load

	if [[ ! -e $PWD/dont-refresh-packages ]]; then
		if [[ ! -e $PACKAGES_PATHFILE ]] || ! IsThisFileRecent "$PACKAGES_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES"; then
			ShowAsProc 'download QPKG list'

			if $CURL_CMD --silent --fail "$PACKAGES_ARCHIVE_URL" > "$PACKAGES_ARCHIVE_PATHFILE"; then
				$TAR_CMD --extract --gzip --no-same-owner --file="$PACKAGES_ARCHIVE_PATHFILE" --directory="$CACHE_PATH"
			fi
		fi
	fi

	if [[ ! -e $PACKAGES_PATHFILE ]]; then
		ShowAsAbort 'QPKG list missing'

		Func:Exit 1; exit
	fi

	ShowAsProc QPKGs

	. "$PACKAGES_PATHFILE"
	packages_loaded=true

	readonly BASE_QPKG_CONFLICTS_WITH
	readonly BASE_QPKG_WARNINGS
	readonly ESSENTIAL_IPKS
	readonly ESSENTIAL_PIPS
	readonly EXCLUSION_PIPS
	readonly MIN_PERL_VER
	readonly MIN_PYTHON_VER
	readonly PACKAGES_VER

	# Package list arrays are now full, so lock them.
	readonly QPKG_ABBRVS
	readonly QPKG_APP_AUTHOR
	readonly QPKG_APP_AUTHOR_EMAIL
	readonly QPKG_APP_VERSION
	readonly QPKG_ARCH
	readonly QPKG_AUTHOR
	readonly QPKG_AUTHOR_EMAIL
	readonly QPKG_CAN_BACKUP
	readonly QPKG_CAN_CLEAN
	readonly QPKG_CAN_LOG_SERVICE_OPERATIONS
	readonly QPKG_CAN_RESTART_TO_UPDATE
	readonly QPKG_CONFLICTS_WITH
	readonly QPKG_DEPENDS_ON
	readonly QPKG_DESC
	readonly QPKG_HASH
	readonly QPKG_MAX_OS_VERSION
	readonly QPKG_MIN_OS_VERSION
	readonly QPKG_MIN_RAM_KB
	readonly QPKG_NAME
	readonly QPKG_NOTE
	readonly QPKG_REQUIRES_IPKS
	readonly QPKG_TEST_FOR_ACTIVE
	readonly QPKG_URL
	readonly QPKG_VERSION

	DebugVar PACKAGES_VER
	QPKGs-GRall:Add "${QPKG_NAME[*]}"
	QPKGs.IndependentDependent:Build

	Func:Exit

	}

Traps:Set()
	{

	trap RunOnEXIT EXIT
	trap RunOnSIGINT INT

	}

RunOnSIGINT()
	{

	$TOUCH_CMD "$DISPLAY_INHIBIT_PATHFILE"
	EraseThisLine
	ShowAsAbort 'caught SIGINT'
	KillActiveFork
	CloseActionMsgPipe
	exit

	}

RunOnEXIT()
	{

	trap - INT
	Keystrokes:Show
	Cursor:Show
	LockFile:Release

	}

Init || exit
Actions:Proc
Results:Show
Error.IsNt
