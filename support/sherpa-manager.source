#!/usr/bin/env bash
#* <?dont_edit?>
#
#* <?filename?>
#
#* <?copyright?>
#
#* Description:
#*   This is the management script for the sherpa mini-package-manager.
#*   It's automatically downloaded via the `sherpa-loader.sh` script in the `sherpa` QPKG no-more than once-per-hour.
#
#* <?project?>
#
#* <?tested?>
#
#* <?license?>
#
# Project variable and function naming style-guide:
# 			   functions: 'CamelCase'
# asynchronous functions: '_CamelCaseWithLeadingAndTrailingUnderscores_'
# 	utility interceptors: (same as original)
#			   variables: 'snakecase'
#  flag "object" methods: 'Capitalised.CamelCase.With.Inline.Periods.And.Colon.Before:Method'
#	 flag "object" tests: 'Capitalised.CamelCase.With.Inline.Periods.And.Period.Before.Test'
#  list "object" methods: 'Capitalised-CamelCase-With-Inline-Hyphens-And-Colon-Before:Method'
#	 list "object" tests: 'Capitalised-CamelCase-With-Inline-Hyphens-And-Period-Before.Test'
#	 "object" properties: '_snakecase_with_leading_and_trailing_underscores_' (these should be managed ONLY by the object's methods)
#			   constants: 'r_snakecase_with_leading_r_underscore' (set as readonly ASAP)
#				 indents: 1 x tab char (= 4 space chars)
#
# Notes:
#   If on-screen line-spacing is required, this should only be done by the next function to print output.
#   Display functions should never finish by putting an empty line on-screen for spacing.

set -o nounset -o pipefail
shopt -s extglob
[[ $- != *m* ]] || set +m			# Disable job control if-enabled (only needed for QTS 4.2.6).
ln -fns /proc/self/fd /dev/fd		# KLUDGE: `/dev/fd` isn't always created by QTS.
readonly r_args_raw=$*

Init()
	{

	OsIsOk || return
	UserIsOk || return
	LoadConsts
	LoadVars
	UpdateCapabilities
	LoadCMDs
	CMDsIsOk || return
	HideKeystrokes
	HideCursor
	LoadEnv || return
	ClaimLockfile || return
	CreatePaths || return
	PrepareArgs
	ParseManagementArgs || return
	ParseHelpArgs || return
	ArchivePriorSessLogs
	DebugLogInit
	ParseShowArgs || return
	ParseListArgs || return
	ParseActionArgs || return
	ShowTitle
	ShowArgSuggestions
	CheckQPKGsConflicts || return
	CheckQPKGsWarnings
	DebugLogEnv
	CheckTasks
	CheckEnv
	QPKGsAssignToActions

	return 0

	}

ShowResults()
	{

	FuncInit

	if [[ $generate_show_report = true ]]; then
		if [[ $useropt_show_log_last = true ]]; then
			ReleaseLockfile
			ViewLogLast
		elif [[ $useropt_show_log_tail = true ]]; then
			ReleaseLockfile
			ViewLogTail
		elif [[ $useropt_show_backups = true ]]; then
			ReleaseLockfile
			ShowReportBackups
		elif [[ $useropt_show_dependencies = true ]]; then
			ShowReportDependencies
		elif [[ $useropt_show_features = true ]]; then
			ShowReportFeatures
		elif [[ $useropt_show_packages = true ]]; then
			ShowReportPackages
		elif [[ $useropt_show_repos = true ]]; then
			ShowReportRepos
		elif [[ $useropt_show_status = true ]]; then
			ShowReportStatuses
			show_action_results_report=false
		fi
	fi

	if [[ $generate_list_report = true ]]; then
		if [[ $useropt_list_versions = true ]]; then
			ReleaseLockfile
			ShowVersionsList
		else
			ShowQPKGLists
		fi
	fi

	if [[ $useropt_paste_log_last = true ]]; then
		PasteLogLast
	elif [[ $useropt_paste_log_tail = true ]]; then
		PasteLogTail
	fi

	if [[ $useropt_help_basic = true ]]; then
		ShowHelpBasic
		ShowHelpBasicExamples
	fi

	if [[ $generate_help_report = true ]]; then
		ReleaseLockfile

		if [[ $useropt_help_tips = true ]]; then
			ShowHelpTips
		elif [[ $useropt_help_abbreviations = true ]]; then
			HelpAbbreviations
		elif [[ $useropt_help_actions = true ]]; then
			ShowHelpActions
		elif [[ $useropt_help_actions_all = true ]]; then
			ShowHelpActionsAll
		elif [[ $useropt_help_lists = true ]]; then
			ShowHelpLists
		elif [[ $useropt_help_options = true ]]; then
			ShowHelpOptions
		elif [[ $useropt_help_packages = true ]]; then
			ShowHelpPackages
		elif [[ $useropt_help_show = true ]]; then
			ShowHelpShow
		elif [[ $useropt_help_problems = true ]]; then
			ShowHelpProblems
		elif [[ $useropt_help_upgrades = true ]]; then
			ShowHelpUpgrades
		elif [[ $useropt_help_groups = true ]]; then
			ShowHelpGroups
		fi
	fi

	if [[ $show_action_results_report = true ]]; then
		ShowReportAllActionResults
	fi

	[[ $show_backuploc = true ]] && ShowHelpBackupLocation
	[[ $show_suggest_raise_issue = true ]] && ShowHelpIssue

	DebugInfoMinSepr
	DebugScript finished "$(ConvertNowToFullDate)"
	DebugScript 'elapsed time' "$(ConvertSecondsToDuration "$(($(ConvertNowToSeconds)-r_script_startseconds))")"
	DebugInfoMajSepr

	FuncExit

	[[ $archive_debug_afterward = true ]] && ArchiveActiveSessLog
	ResetActiveSessLog

	}

DebugLogInit()
	{

	DebugInfoMajSepr
	DebugScript started "$(ConvertSecondsToFullDate "$r_script_startseconds")"
	DebugScript PID "$$"
	DebugInfoMinSepr
	DebugInfo 'Markers: (**) detected, (II) information, (WW) warning, (EE) error, (LL) log file, (--) processing,'
	DebugInfo '(==) done, (>>) f entry, (<<) f exit, (aa) array name & values, (vv) variable name & value,'
	DebugInfo '($1) positional argument value'
	DebugInfoMinSepr
	DebugVar r_this_package_ver
	DebugVar r_this_script_ver
	DebugVar LOADER_SCRIPT_VERSION

	}

LoadConsts()
	{

	# QPKG actions.

	readonly r_qpkg_disable_timeout_seconds=10
	readonly r_qpkg_enable_timeout_seconds=10
	readonly r_qpkg_restart_timeout_seconds=1800		# 30 minutes
	readonly r_qpkg_start_timeout_seconds=1500			# 25 minutes
	readonly r_qpkg_status_check_timeout_seconds=15
	readonly r_qpkg_stop_timeout_seconds=300			# 5 minutes

	# Fixed-widths for report columns when GNU `awk` isn't available.

	readonly r_report_qpkg_abbreviations_column_width=84
	readonly r_report_qpkg_action_column_width=27
	readonly r_report_qpkg_active_test_builtin_column_width=11
	readonly r_report_qpkg_appl_version_column_width=22
	readonly r_report_qpkg_arch_column_width=15
	readonly r_report_qpkg_author_column_width=40
	readonly r_report_qpkg_auto_update_column_width=10
	readonly r_report_qpkg_dependencies_column_width=29
	readonly r_report_qpkg_description_column_width=10
	readonly r_report_qpkg_install_date_column_width=20
	readonly r_report_qpkg_is_compatible_column_width=9
	readonly r_report_qpkg_is_enabled_column_width=10
	readonly r_report_qpkg_is_installed_column_width=12
	readonly r_report_qpkg_is_managed_column_width=10
	readonly r_report_qpkg_max_os_version_column_width=10
	readonly r_report_qpkg_min_os_version_column_width=10
	readonly r_report_qpkg_min_ram_column_width=14
	readonly r_report_qpkg_name_column_width=21
	readonly r_report_qpkg_path_column_width=48
	readonly r_report_qpkg_repo_column_width=40
	readonly r_report_qpkg_status_column_width=23
	readonly r_report_qpkg_supports_backup_column_width=10
	readonly r_report_qpkg_supports_clean_column_width=11
	readonly r_report_qpkg_supports_start_to_update_column_width=11
	readonly r_report_qpkg_tier_column_width=8
	readonly r_report_qpkg_version_column_width=15
	readonly r_report_lazy_column_width=28				# Use this when I can't be bothered calculating an optimum fixed column width.

	# Report, help and debug formatting.

	readonly r_debug_log_full_width=100
	readonly r_debug_log_first_column_width=9
	readonly r_debug_log_second_column_width=20
		readonly r_debug_log_third_column_width=$((r_debug_log_full_width-r_debug_log_first_column_width-r_debug_log_second_column_width-4))
	readonly r_help_desc_indent=3
	readonly r_help_syntax_indent=6
	readonly r_report_action_result_indent=6
	readonly r_report_column_spacing=2
	readonly r_report_file_bytes_column_width=16
	readonly r_report_file_change_date_column_width=60
	readonly r_report_file_name_column_width=$((r_report_qpkg_name_column_width+14))
	readonly r_report_footer_name_column_width=14
	readonly r_report_highlight_backups_older_than='2 weeks ago'

	# Report, help and onscreen messages.

	readonly r_chars_alert='! '
	readonly r_chars_attention='* '
	readonly r_chars_blank='  '
	readonly r_chars_bullet='• '
	readonly r_chars_dropend='└─ '
	readonly r_chars_ellipsis='...'
	readonly r_chars_normal='- '
	readonly r_chars_note='* '
	readonly r_chars_regular_prompt='$ '
		readonly r_chars_sudo_prompt="${r_chars_regular_prompt}sudo "
	readonly r_chars_results='= '
	readonly r_chars_super_prompt='# '

	if OsIsSupportSudo; then
		if [[ $(UserGetSudoUID) = undefined ]]; then
			readonly r_help_syntax_prefix=$r_chars_super_prompt
			readonly r_help_syntax_sudo_prefix=$r_chars_super_prompt
		else
			readonly r_help_syntax_prefix=$r_chars_regular_prompt
			readonly r_help_syntax_sudo_prefix=$r_chars_sudo_prompt
		fi
	else
		readonly r_help_syntax_prefix=$r_chars_super_prompt
		readonly r_help_syntax_sudo_prefix=$r_chars_super_prompt
	fi

	if [[ -t 0 ]]; then			# Only enable ANSI colour codes if running in a user terminal.
		readonly r_colourful_default=true
	else
		readonly r_colourful_default=false
	fi

	# Various.

	readonly r_file_change_threshold_minutes=60
	readonly r_log_tail_lines=5000

	}

LoadVars()
	{

	# Default flags.

	archive_debug_afterward=false
	generate_help_report=false
	generate_list_report=false
	generate_show_report=false
	get_qpkg_active_status=false
	get_qpkg_states=false
	ipks_downgrade=false
	ipks_install=false
	ipks_upgrade=false
	pips_install=false
	qpkg_timeouts_increased=false
	run_package_actions=false
	show_action_results_failed=false
	show_action_results_ok=false
	show_action_results_report=false
	show_action_results_skipped=false
	show_action_results_zero=false
	show_backuploc=false
	show_suggest_raise_issue=false
	show_title=true
	switch_branch=false
	switch_colour=false
	switch_report_footer=false
	switch_terse=false
	title_shown=false

	# Default values.

	action_msg_pipe_fd=none
	backup_stdin_fd=none
	proc_counts_path=''
	user_branch_value=''
	user_colourful_value=''
	user_report_footer_value=''
	user_terse_value=''

	# User-selectable flags.

	useropt_check=false
	useropt_debug=false
	useropt_help_abbreviations=false
	useropt_help_actions=false
	useropt_help_actions_all=false
	useropt_help_basic=false
	useropt_help_groups=false
	useropt_help_lists=false
	useropt_help_options=false
	useropt_help_packages=false
	useropt_help_problems=false
	useropt_help_show=false
	useropt_help_tips=false
	useropt_help_upgrades=false
	useropt_list_versions=false
	useropt_paste_log_last=false
	useropt_paste_log_tail=false
	useropt_report_footer=$(LoadSetting ReportFooter true)
	useropt_show_about=false
	useropt_show_aboutall=false
	useropt_show_backups=false
	useropt_show_dependencies=false
	useropt_show_features=false
	useropt_show_log_last=false
	useropt_show_log_tail=false
	useropt_show_packages=false
	useropt_show_previous_action_results_report=false
	useropt_show_repos=false
	useropt_show_status=false
	useropt_terse=$(LoadSetting Terse true)
	useropt_verbose=false

	if [[ -t 0 ]]; then			# Only enable ANSI colour codes if running in a user terminal.
		useropt_colourful=$(LoadSetting Colourful "$r_colourful_default")
	else
		useropt_colourful=false
	fi

	# User-selectable values.

	useropt_branch=$(LoadSetting Git_Branch stable)

	}

LoadCMDs()
	{

	# Cherry-pick Entware binaries.

	readonly GNU_AWK_CMD=/opt/bin/awk
	readonly GNU_FIND_CMD=/opt/bin/find
	readonly GNU_GREP_CMD=/opt/bin/grep
	readonly GNU_LESS_CMD=/opt/bin/less
	readonly GNU_SED_CMD=/opt/bin/sed
	readonly GNU_SLEEP_CMD=/opt/bin/sleep
	readonly GNU_SORT_CMD=/opt/bin/sort
	readonly GNU_STTY_CMD=/opt/bin/stty
	readonly GNU_TIMEOUT_CMD=/opt/bin/timeout
	readonly OPKG_CMD=/opt/bin/opkg
	readonly PERL_CMD=/opt/bin/perl
	readonly PYTHON_CMD=/opt/bin/python
	readonly PYTHON3_CMD=/opt/bin/python3
		readonly PIP_CMD="$PYTHON3_CMD -m pip"

	# Cherry-pick QTS/QuTS binaries.

	readonly AWK_CMD=/bin/awk
	readonly BASENAME_CMD=/usr/bin/basename
	readonly CAT_CMD=/bin/cat
	CURL_CMD=/sbin/curl			# Set as readonly later when secure download ability has been checked.
	# Don't assign a const for `/bin/date` as it's already been called before arriving here.
	readonly DF_CMD=/bin/df
	readonly DIRNAME_CMD=/usr/bin/dirname
	readonly DU_CMD=/usr/bin/du
	readonly GREP_CMD=/bin/grep
	readonly LESS_CMD=/bin/less
	readonly MD5SUM_CMD=/bin/md5sum
	readonly MKNOD_CMD=/bin/mknod
	readonly MKTEMP_CMD=/bin/mktemp
	readonly MORE_CMD=/bin/more
	readonly PS_CMD=/bin/ps
	readonly READLINK_CMD=/usr/bin/readlink
	readonly SCREEN_CMD=/usr/sbin/screen
	readonly SED_CMD=/bin/sed
	readonly SH_CMD=/bin/sh
	readonly SLEEP_CMD=/bin/sleep
	readonly SORT_CMD=/usr/bin/sort
	readonly TAIL_CMD=/usr/bin/tail
	readonly TAR_CMD=/bin/tar
	readonly TEE_CMD=/usr/bin/tee
	readonly UNAME_CMD=/bin/uname
	readonly UNIQ_CMD=/bin/uniq
	readonly UNZIP_CMD=/usr/bin/unzip
	readonly UPTIME_CMD=/usr/bin/uptime
	readonly WC_CMD=/usr/bin/wc

	}

CMDsIsOk()
	{

	# Confirm required binaries are present.

	IsSysFileExist $AWK_CMD || return
	IsSysFileExist $BASENAME_CMD || return
	IsSysFileExist $CAT_CMD || return
	# Don't check for `/bin/date` as it's already been called before arriving here.
	IsSysFileExist $CURL_CMD || return
	IsSysFileExist $DF_CMD || return
	IsSysFileExist $DIRNAME_CMD || return
	IsSysFileExist $DU_CMD || return
	IsSysFileExist $GREP_CMD || return
	# Don't check for `/bin/less` because it's not always there.
	IsSysFileExist $MD5SUM_CMD || return
	IsSysFileExist $MKNOD_CMD || return
	IsSysFileExist $MKTEMP_CMD || return
	# Don't check for `/bin/more` because it's a very low-priority utility (non-essential).
	IsSysFileExist $PS_CMD || return
	IsSysFileExist $READLINK_CMD || return
	IsSysFileExist $SCREEN_CMD || return
	# Don't check for `/bin/sed` as it's already been called before arriving here.
	IsSysFileExist $SH_CMD || return
	# Don't check for `/bin/sleep` as it's already been called before arriving here.
	[[ ! -e $SORT_CMD ]] && ln -s /bin/busybox "$SORT_CMD"		# KLUDGE: `/usr/bin/sort` randomly disappears from QTS.
	IsSysFileExist $TAIL_CMD || return
	IsSysFileExist $TAR_CMD || return
	IsSysFileExist $TEE_CMD || return
	IsSysFileExist $UNAME_CMD || return
	IsSysFileExist $UNIQ_CMD || return
	IsSysFileExist $UNZIP_CMD || return
	IsSysFileExist $UPTIME_CMD || return
	# Don't check for `/usr/bin/wc` as it's already been called before arriving here.

	LocateSQLiteBinary

	return 0

	}

LocateSQLiteBinary()
	{

	# Outputs: (global)
	#   $sqlite_cmd
	#   $sqlite_pathfile

	local a=''
	sqlite_cmd=''
	sqlite_pathfile=''

	# Prefer Entware-installed `sqlite3`.

	if [[ -z ${sqlite_cmd:-} ]] && QpkgIsReallyInstalled Entware; then
		sqlite_pathfile=/opt/bin/sqlite3
		[[ -e $sqlite_pathfile ]] && sqlite_cmd=$sqlite_pathfile
	fi

	# If that can't be found, then try several other locations...

	# These use a specific path to the binary:
	#	HybridBackup = `Hybrid Backup Sync`

	if [[ -z $sqlite_cmd ]] && QpkgIsReallyInstalled HybridBackup; then
		sqlite_pathfile=$(QpkgGetInstalledPath HybridBackup)/CloudConnector3/bin/sqlite3
		[[ -e $sqlite_pathfile ]] && sqlite_cmd=$sqlite_pathfile
	fi

	if [[ -z $sqlite_cmd ]] && QpkgIsReallyInstalled ArchiwareP5; then	# untested.
		sqlite_pathfile=$(QpkgGetInstalledPath ArchiwareP5)/binaries/Linux/unknown/64/sqlite3
		[[ -e $sqlite_pathfile ]] && sqlite_cmd=$sqlite_pathfile
	fi

	# These use the same path to the binary:
	#	container-station = `Container Station`

	if [[ -z $sqlite_cmd ]]; then
		for a in container-station HD_Station; do					# 'HD_Station' is untested.
			if QpkgIsReallyInstalled "$a"; then
				sqlite_pathfile=$(QpkgGetInstalledPath "$a")/usr/bin/sqlite3
				[[ -e $sqlite_pathfile ]] || continue
				sqlite_cmd=$sqlite_pathfile
				break
			fi
		done
	fi

	#	CacheMount = `HybridMount`
	# 	qmiixagent = `Qmiix Agent`

	if [[ -z $sqlite_cmd ]]; then
		for a in CacheMount qmiixagent qusbcam2 QPython312 QPython311 QPython39; do
			if QpkgIsReallyInstalled "$a"; then
				sqlite_pathfile=$(QpkgGetInstalledPath "$a")/bin/sqlite3
				[[ -e $sqlite_pathfile ]] || continue
				sqlite_cmd=$sqlite_pathfile
				break
			fi
		done
	fi

	# These use the same path to the binary, and require the linked-library path to be set:
	#	img2pdf = `Image2PDF`
	#	OCR_Converter = `OCR Converter`

	if [[ -z $sqlite_cmd ]]; then
		for a in img2pdf Qsirch OCR_Converter; do
			if QpkgIsReallyInstalled "$a"; then
				sqlite_pathfile=$(QpkgGetInstalledPath "$a")/bin/sqlite3
				[[ -e $sqlite_pathfile ]] || continue
				sqlite_cmd="LD_LIBRARY_PATH=$(QpkgGetInstalledPath "$a")/lib $sqlite_pathfile"
				break
			fi
		done
	fi

	if [[ -z $sqlite_cmd ]]; then				# Last-resort, hope Entware will be installed this session.
		sqlite_pathfile=/opt/bin/sqlite3
		sqlite_cmd=$sqlite_pathfile
	fi

	}

LoadEnv()
	{

	ShowAsProc env

	qpkg_name=sherpa
	readonly r_cert_db_pathfile=/etc/config/nas_sign_qpkg.db
	readonly r_cpu_cores=$(HardwareGetCPUCores)
		readonly r_concurrency=$r_cpu_cores			# Maximum concurrent package actions to run. Should probably make this account for CPU speed too.
	readonly r_entware_type=$(QpkgGetEntwareType)
	readonly r_kernel_page_size=$(OsGetKernelPageSize)
	readonly r_nas_arch=$(OsGetArch)
	readonly r_nas_firmware_build=$(OsGetFirmwareBuild)
	readonly r_nas_firmware_date=$(OsGetFirmwareDate)
	readonly r_nas_firmware_version=$(OsGetFirmwareVer)
	readonly r_nas_platform=$(HardwareGetPlatform)
	readonly r_nas_qpkg_arch=$(QpkgGetArch)
	readonly r_nas_ram_kb=$(HardwareGetInstalledRAM)
	readonly r_os_upstate=$(OsGetUpState)
	readonly r_this_package_ver=$(QpkgGetInstalledVer)

	OsIsSupportSecureDownload || CURL_CMD+=' --insecure'
	readonly CURL_CMD

	args=()						# Command-line argument array.
	args_incomplete=()
	qpkg_default_index=0
	qpkg_index=0
	readonly r_this_script_epoch='<?manager_epoch?>'
	useropt_branch=$(UserGetGitBranch)
		readonly r_objects_archive_url='<?cdn_sherpa_base_url?>'/$useropt_branch/objects.tar.gz
		readonly r_packages_archive_url='<?cdn_sherpa_packages_base_url?>'/$useropt_branch/packages.tar.gz
		readonly r_this_script_ver="$(ConvertSecondsToDatecode $r_this_script_epoch)-$useropt_branch"
	readonly r_qpkg_bu_path=$(UserGetDefVol)/.qpkg_config_backup
	readonly r_this_package_path=$(QpkgGetInstalledPath)
		if [[ -z $r_this_package_path || $r_this_package_path = undefined || ! -d $r_this_package_path ]]; then
			ShowAsError "$(ShowAsTitleName) installation path not found. Please reinstall the $(ShowAsTitleName) QPKG"

			return 1
		fi

		readonly r_cache_path=$r_this_package_path/cache
			readonly r_action_times_path=$r_cache_path/action.times
			readonly r_async_procs_path=$r_cache_path/proc
			readonly r_dependent_qpkgs_list_pathfile=$r_cache_path/dependents
			readonly r_display_inhibit_pathfile=$r_cache_path/display.inhibit
			readonly r_independent_qpkgs_list_pathfile=$r_cache_path/independents
			readonly r_ipk_cache_path=$r_cache_path/IPKs
				readonly r_ipk_downgrade_path=$r_ipk_cache_path/downgrade
				readonly r_ipk_download_path=$r_ipk_cache_path/downloads
				readonly r_prev_ipk_list_pathfile=$r_ipk_cache_path/ipk.list.save
			readonly r_objects_archive_pathfile=$r_cache_path/objects.tar.gz
			readonly r_objects_pathfile=$r_cache_path/objects
			readonly r_packages_archive_pathfile=$r_cache_path/packages.tar.gz
			readonly r_packages_pathfile=$r_cache_path/packages
			readonly r_pip_cache_path=$r_cache_path/PIPs
				readonly r_prev_pip_list_pathfile=$r_pip_cache_path/pip.list.save
			readonly r_qpkg_cache_path=$r_cache_path/QPKGs
				readonly r_qpkg_download_path=$r_qpkg_cache_path/downloads
		readonly r_logs_path=$r_this_package_path/logs
			readonly r_oom_log_pathfile=$r_logs_path/oom.log
			readonly r_ram_freeused_pathfile=$r_logs_path/ram.freeused
			readonly r_ramfs_freespace_pathfile=$r_logs_path/ramfs.freespace
			readonly r_screen_sessions_pathfile=$r_logs_path/screen.sessions
			readonly r_session_action_results_pathfile=$r_logs_path/session.action.results.log
			readonly r_session_archive_pathfile=$r_logs_path/session.archive.log
			readonly r_session_last_pathfile=$r_logs_path/session.last.log
			readonly r_session_tail_pathfile=$r_logs_path/session.tail.log
		sess_active_pathfile=$r_this_package_path/session.$$.active.log

	# Ephemeral files.

	readonly r_action_forks_count=/var/run/sherpa/actions/forks
	readonly r_action_logs_path=/var/log/sherpa/actions/logs
	readonly r_qpkg_states_path=/var/run/sherpa/packages/states
		readonly r_action_abort_pathfile=$r_qpkg_states_path/abort.action
		readonly r_action_msg_pipe=$r_qpkg_states_path/action.messages.pipe
	readonly r_report_columns_path=/var/run/sherpa/report/columns
	readonly r_report_flags_path=/var/run/sherpa/report/flags
	readonly r_reports_path=/var/log/sherpa/reports
			readonly r_report_output_pathfile=$r_reports_path/report.ansi
	readonly r_run_logs_path=/var/run/sherpa/run.logs

	# Entware

	readonly r_external_packages_archive_pathfile=/opt/var/opkg-lists/entware
	readonly r_external_packages_pathfile=$r_cache_path/Packages

	# KLUDGE: just in-case `python` has disappeared again ... ¯\_(ツ)_/¯
	[[ -e $PYTHON3_CMD && ! -L $PYTHON_CMD ]] && ln -s "$PYTHON3_CMD" "$PYTHON_CMD"

	rm -f "$r_report_output_pathfile" "$r_ramfs_freespace_pathfile" "$r_display_inhibit_pathfile" 2> /dev/null

	if [[ -e $GNU_STTY_CMD && -t 0 ]]; then
		local terminal_dimensions=$($GNU_STTY_CMD size)
		readonly r_sess_rows=${terminal_dimensions% *}
		readonly r_sess_columns=${terminal_dimensions#* }
	else
		readonly r_sess_rows=40
		readonly r_sess_columns=156
	fi

	}

LoadLists()
	{

	# Inputs: (global)
	#	$lists_loaded

	# Outputs: (global)
	#	$lists_loaded
	#	$r_ipk_actions[]
	#	$r_package_tiers[]
	#	$r_pip_actions[]
	#	$r_qpkg_actions[]
	#	$r_qpkg_is_groups[]
	#	$r_qpkg_is_states[]
	#	$r_qpkg_isnt_groups[]
	#	$r_qpkg_isnt_states[]
	#	$r_qpkg_service_results[]
	#	$r_qpkg_states_transient[]
	#	$r_user_qpkg_actions[]
	#	$r_"$(Lowercase "$action")"_log_file

	[[ ${lists_loaded:=false} = false ]] || return 0

	# First, clear existing list arrays (if-any).

	unset r_ipk_actions
	unset r_package_tiers
	unset r_pip_actions
	unset r_qpkg_actions
	unset r_qpkg_is_groups
	unset r_qpkg_is_states
	unset r_qpkg_isnt_groups
	unset r_qpkg_isnt_states
	unset r_qpkg_service_results
	unset r_qpkg_states_transient
	unset r_user_qpkg_actions

	# These are used internally by sherpa.
	# ordered

	r_package_tiers=(independent auxiliary dependent)

	# sorted

	r_qpkg_is_states=(active backedup downloaded enabled installable installed missing signed upgradable)
	r_qpkg_isnt_states=(active backedup downloaded enabled installable installed missing signed upgradable)
	r_qpkg_is_groups=(all canbackup canclean canrestarttoupdate dependent hasdependents independent)
	r_qpkg_isnt_groups=(canclean)
	r_qpkg_states_transient=(restarting slow starting stopping unknown)
	r_qpkg_service_results=(failed ok)

	# ordered

	r_qpkg_actions=(status list rebuild reassign download backup deactivate disable uninstall upgrade reinstall install enableau disableau sign restore clean enable activate reactivate)
	r_ipk_actions=(downgrade download uninstall upgrade install)
	r_pip_actions=(uninstall upgrade install)

	# These actions may be specified by the user.
	# sorted

	r_user_qpkg_actions=(activate backup clean deactivate disable disableau enable enableau install list reactivate reassign rebuild reinstall restore sign status uninstall upgrade)

	# KLUDGE: for some reason, setting `readonly` while populating arrays causes their scope to become local, so need to set as `readonly` afterward to ensure global scope. GNU Bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)

	readonly r_package_tiers

	readonly r_qpkg_is_states
	readonly r_qpkg_isnt_states
	readonly r_qpkg_is_groups
	readonly r_qpkg_isnt_groups
	readonly r_qpkg_states_transient
	readonly r_qpkg_service_results

	readonly r_qpkg_actions
	readonly r_ipk_actions
	readonly r_pip_actions

	readonly r_user_qpkg_actions

	local action=''

	for action in "${r_qpkg_actions[@]}" check debug downgrade update; do
		readonly r_"$(Lowercase "$action")"_log_file=$action.log
	done

	lists_loaded=true

	}

CreatePaths()
	{

	ClearPath "$r_cache_path" "$r_async_procs_path"
	ClearPath "$r_cache_path" "$r_ipk_cache_path"
	ClearPath "$r_cache_path" "$r_ipk_download_path"
	ClearPath "$r_cache_path" "$r_pip_cache_path"
	ClearPath /var/run/sherpa/report "$r_report_columns_path"
	ClearPath /var/run/sherpa/report "$r_report_flags_path"

	MakePath "$r_action_times_path" 'action times' || return
	MakePath "$r_async_procs_path" 'asynchronous process tracking' || return
	MakePath "$r_cache_path" cache || return
	MakePath "$r_ipk_cache_path" 'IPK cache' || return
	MakePath "$r_ipk_download_path" 'IPK download' || return
	MakePath "$r_ipk_downgrade_path" 'IPK downgrade' || return
	MakePath "$r_logs_path" logs || return
	MakePath "$r_pip_cache_path" 'PIP cache' || return
	MakePath "$r_report_columns_path" 'report columns' || return
	MakePath "$r_report_flags_path" 'report flags' || return
	MakePath "$r_reports_path" reports || return
	MakePath "$r_qpkg_bu_path" 'QPKG backup' || return
	MakePath "$r_qpkg_download_path" 'QPKG download' || return
	MakePath "$r_qpkg_states_path" states || return

	}

DebugLogEnv()
	{

	if [[ $useropt_show_about = false && $useropt_show_aboutall = false ]]; then
		[[ $run_package_actions = true ]] || return 0
		[[ $useropt_debug = true ]] || return 0
	fi

	FuncInit

	ShowAsProc 'log env'

	if [[ $useropt_show_about = true || $useropt_show_aboutall = true ]]; then
		useropt_debug=true
		useropt_verbose=true
	fi

	DebugInfoMinSepr
	DebugHardware ok 'NAS model' "$(get_display_name)"
	DebugHardware ok CPU "$(HardwareGetCPUInfo)"
	DebugHardware ok 'CPU cores' "$r_cpu_cores"
	DebugHardware ok 'CPU architecture' "$r_nas_arch"
	DebugHardware ok RAM "$(FormatAsThous "$r_nas_ram_kb")kiB"
	DebugKernel ok name "$(OsGetKernelName)"
	DebugKernel ok version "$(OsGetKernelVersion)"

	if OsIsStdKernelPageSize; then
		DebugKernel ok 'page size' "${r_kernel_page_size}B"
	else
		DebugKernel warning 'page size' "${r_kernel_page_size}B"
	fi

	DebugFirmware ok OS "$(OsGetQnapOS)"

	if OsIsSupported; then
		DebugFirmware ok version "$r_nas_firmware_version.$r_nas_firmware_build"
	else
		DebugFirmware warning version "$r_nas_firmware_version"
	fi

	if OsIsCompatibleWithSigned; then
		DebugFirmware ok 'build date' "$r_nas_firmware_date"
	else
		DebugFirmware warning 'build date' "$r_nas_firmware_date"
	fi

	DebugFirmware ok platform "$r_nas_platform"

	case $r_os_upstate in
		starting-up|shutting-down)
			DebugOS warning state "$r_os_upstate"
			;;
		*)
			DebugOS ok state "$r_os_upstate"
	esac

	DebugOS ok uptime "$(OsGetUptime)"

	if OsIsLoadAverageElevated; then
		DebugOS warning 'load averages' "$(OsGetSysLoadAverages)"
	else
		DebugOS ok 'load averages' "$(OsGetSysLoadAverages)"
	fi

	DebugUserspace ok libc "$(UserGetLIBC)"
	DebugUserspace ok 'libc copyright' "$(UserGetLIBCCopyright)"

	if OsIsSupportSudo; then
		DebugUserspace ok '$SUDO_UID' "$(UserGetSudoUID)"
	else
		DebugUserspace ok '$SUDO_UID' N/A
	fi

	DebugUserspace ok '$EUID' "$EUID"
	DebugUserspace ok 'default volume' "$(UserGetDefVol)"
	DebugUserspace ok '/opt' "$($READLINK_CMD /opt 2> /dev/null || printf 'not present')"

	local public_share=$(/sbin/getcfg SHARE_DEF defPublic -d Qpublic -f /etc/config/def_share.info)

	if [[ -L /share/$public_share ]]; then
		DebugUserspace ok "'$public_share' share" "/share/$public_share"
	else
		DebugUserspace warning "'$public_share' share" 'not present'
	fi

	DebugUserspace ok '$SHELL' "$(ShellGet)"
	DebugShell ok version "$(ShellGetVersion)"
	DebugShell ok copyright "$(ShellGetCopyright)"
	DebugShell ok options "$-"
	DebugShell ok 'time in shell' "$(ShellGetTimeIn)"

# 	if [[ ${#PATH} -le $r_debug_log_third_column_width ]]; then
# 		DebugUserspace ok '$PATH' "$PATH"
# 	else
# 		DebugUserspace ok '$PATH (LHS-only)' "${PATH:0:$((r_debug_log_third_column_width-${#r_chars_ellipsis}))}${r_chars_ellipsis}"
# 	fi

	DebugScript QPKG "${r_this_package_ver:-undefined}$([[ $r_this_package_ver != undefined ]] && printf '%s' " ($(ConvertDateCodeToExtendedDate "$r_this_package_ver"))")"
	DebugScript manager "${r_this_script_epoch:-undefined}$([[ ${#r_this_script_epoch} -eq 10 ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_this_script_epoch"))")"
	DebugScript 'git branch' "$useropt_branch"
	DebugScript loader "${LOADER_SCRIPT_VERSION:=undefined}$([[ $LOADER_SCRIPT_VERSION != undefined ]] && printf '%s' " ($(ConvertDateCodeToExtendedDate "$LOADER_SCRIPT_VERSION"))")"

	if [[ ${objects_loaded:=false} = true ]]; then
		DebugScript objects "${r_objects_epoch:-undefined}$([[ ${#r_objects_epoch} -eq 10 ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_objects_epoch"))")"
	else
		DebugScript objects 'not loaded'
	fi

	if [[ ${packages_loaded:=false} = true ]]; then
		DebugScript packages "${r_packages_epoch:-undefined}$([[ ${#r_packages_epoch} -eq 10 ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_packages_epoch"))")"
	else
		DebugScript packages 'not loaded'
	fi

	DebugScript 'logs path' "$r_logs_path"
	DebugScript 'action concurrency' "$r_concurrency"
	DebugScript "'sqlite3' binary" "$sqlite_cmd"

	if OsIsSupportUnofficialPackages; then
		if OsIsAllowUnofficialPackages; then
			DebugQpkg detect 'allow unofficial' yes
		else
			DebugQpkg warning 'allow unofficial' no
		fi
	else
		DebugQpkg detect 'allow unofficial' N/A
	fi

	if OsIsSupportSignedPackages; then
		if OsIsAllowUnsignedPackages; then
			DebugQpkg detect 'allow unsigned' yes
		else
			DebugQpkg detect 'allow unsigned' no
		fi
	else
		DebugQpkg detect 'allow unsigned' N/A
	fi

	DebugQpkg detect architecture "$r_nas_qpkg_arch"
	DebugQpkg detect "$(ShowAsPackageName Entware) type" "$r_entware_type"
	DebugQpkg detect "$(ShowAsPackageName Entware) install date" "$(QpkgGetInstalledDate Entware)"

	if QpkgIsReallyInstalled SortMyQPKGs; then
		DebugQpkg detect "$(ShowAsPackageName SortMyQPKGs)" installed
	else
		if [[ ${r_nas_firmware_version//.} -lt 400 || ${r_nas_firmware_version//.} -gt 518 ]]; then
			DebugQpkg detect "$(ShowAsPackageName SortMyQPKGs)" 'not installed'
		else
			DebugQpkg warning "$(ShowAsPackageName SortMyQPKGs)" 'not installed'
		fi
	fi

	if OsIsSupportQpkgTimeout; then
		if QpkgIsReallyInstalled IncreaseTimeouts; then
			if QPKGs.IsTimeoutsIncreased; then
				DebugQpkg detect "$(ShowAsPackageName IncreaseTimeouts)" active
			else
				DebugQpkg warning "$(ShowAsPackageName IncreaseTimeouts)" inactive
			fi
		else
			DebugQpkg warning "$(ShowAsPackageName IncreaseTimeouts)" 'not installed'
		fi
	else
		DebugQpkg detect "$(ShowAsPackageName IncreaseTimeouts)" N/A
	fi

	DebugInfoMinSepr

	if [[ $useropt_show_about = true ]]; then
		useropt_debug=false
		useropt_verbose=false
		return
	fi

	RunAndLog "$DF_CMD -h | $GREP_CMD '^Filesystem\|^none\|^tmpfs\|ram'" "$r_ramfs_freespace_pathfile"
	DebugInfoMinSepr
	RunAndLog "$SCREEN_CMD -ls" "$r_screen_sessions_pathfile" '' 1
	DebugInfoMinSepr
	RunAndLog '/usr/bin/free -m' "$r_ram_freeused_pathfile" '' 1
	DebugInfoMinSepr
	RunAndLog "$GREP_CMD -i 'out of memory\|oom-killer' /mnt/HDA_ROOT/.logs/kmsg" "$r_oom_log_pathfile" '' 1
	DebugInfoMinSepr

	if [[ $useropt_show_aboutall = true ]]; then
		useropt_debug=false
		useropt_verbose=false
		return
	fi

	FuncExit

	}

CheckTasks()
	{

	# Establish whether there's anything to-do.

	if [[ $arg_problem = true || $useropt_help_basic = true ]]; then
		show_action_results_report=false
		generate_help_report=false
		generate_list_report=false
		generate_show_report=false
		get_qpkg_active_status=false
		get_qpkg_states=false
		run_package_actions=false
	fi

	[[ $get_qpkg_states = true ]] || return 0

	FuncInit

	local action=''
	local build_states=false
	local group=''
	local state=''

	if [[ $useropt_check = true || $useropt_show_status = true ]]; then
		build_states=true
	elif [[ $useropt_help_abbreviations = true || $useropt_show_backups = true || $useropt_show_dependencies = true || $useropt_show_features = true || $useropt_show_packages = true || $useropt_show_repos = true ]]; then
		build_states=true
	elif [[ $useropt_help_actions = true || $useropt_help_actions_all = true || $useropt_help_basic = true || $useropt_help_groups = true || $useropt_help_lists = true || $useropt_help_options = true || $useropt_help_packages = true || $useropt_help_problems = true || $useropt_help_show = true || $useropt_help_tips = true || $useropt_help_upgrades = true || $useropt_list_versions = true || $useropt_paste_log_last = true || $useropt_paste_log_tail = true || $useropt_show_about = true || $useropt_show_about = true || $useropt_show_previous_action_results_report = true || $useropt_show_log_last = true || $useropt_show_log_tail = true || $switch_branch = true || $switch_colour = true || $switch_report_footer = true || $switch_terse = true ]]; then
		: # don't do anything
	else
		LoadPackages

		for action in "${r_user_qpkg_actions[@]}"; do
			if QPKGs-AC${action}-to.IsAny; then
				build_states=true
				break
			fi

			for group in "${r_qpkg_is_groups[@]}"; do
				if QPKGs.AC${action}.GR${group}.IsSet; then
					break 2
				fi
			done

			for group in "${r_qpkg_isnt_groups[@]}"; do
				if QPKGs.AC${action}.GRNT${group}.IsSet; then
					break 2
				fi
			done

			for state in "${r_qpkg_is_states[@]}"; do
				if QPKGs.AC${action}.IS${state}.IsSet; then
					build_states=true
					break 2
				fi
			done

			for state in "${r_qpkg_isnt_states[@]}"; do
				if QPKGs.AC${action}.ISNT${state}.IsSet; then
					build_states=true
					break 2
				fi
			done
		done
	fi

	[[ $build_states = true ]] && BuildQPKGsStates

	FuncExit

	}

CheckEnv()
	{

	[[ $run_package_actions = true ]] || return 0

	FuncInit

	ShowAsProc 'check env'

	local installed_version=''
	local target_packages=''

	if [[ $($GREP_CMD -i 'out of memory\|oom-killer' /mnt/HDA_ROOT/.logs/kmsg | $WC_CMD -l) -gt 0 ]]; then
		ShowAsWarn "the $(TextBrightRed 'Out-Of-Memory killer') has been triggered ... check for $(TextBrightRed inactive) QPKGs"
	fi

	if QpkgIsInstalled Entware; then
		if [[ $r_entware_type != none ]]; then
			_UpdateEntwarePackageList_ &			# Let's try launching this early.
		else
			DebugAsWarn "$(ShowAsPackageName Entware) appears to be installed but is inactive. Please consider starting the $(ShowAsPackageName Entware) QPKG."
		fi

		# Decide if specific IPKs and PIPs should be installed/upgraded.

		if [[ $useropt_check = true ]] || QPKGs-ACupgrade-to.Exist Entware; then
			ipks_install=true
			ipks_upgrade=true
			pips_install=true

			if Python3IsOutdated; then
				ShowAsNote "the $(TextBrightOrange Python) environment will be auto-upgraded"
				IPKs-ACuninstall-to:Add 'python*'
			fi

			if PerlIsOutdated; then
				ShowAsNote "the $(TextBrightOrange Perl) environment will be auto-upgraded"
				IPKs-ACuninstall-to:Add 'perl*'
			fi
		fi

		# Decide if specific IPKs should be uninstalled/downgraded.

		case $r_nas_qpkg_arch in
			a41)
				# These must be downgraded on armv7 when QTS has a non-standard kernel page size.
				# 	https://forum.qnap.com/viewtopic.php?p=850945#p850945

				if OsIsNonStdKernelPageSize; then
					target_packages='ar binutils libbfd libctf libopcodes objdump'

					# Assume first package version is same as remaining package versions.
					installed_version=$($OPKG_CMD list-installed | $GREP_CMD "^${target_packages%% *} *" | head -n1 | cut -d' ' -f3 | cut -d'-' -f1)

					if [[ ${installed_version//.} -gt 238 ]]; then
						ipks_downgrade=true
						ShowAsNote "various IPKs will be downgraded to suit ${r_kernel_page_size}B kernel page size"
						IPKs-ACdowngrade-to:Add "$target_packages"
					else
						IPKs-ACdowngrade-sk:Add "$target_packages"
					fi
				fi

				# These must be downgraded on armv7 as 2.45.2 versions can't clone a repo.
				# 	https://github.com/Entware/Entware/issues/1072
				# 	NOTE: this issue has been fixed.

# 				target_packages='git git-http'
#
# 				# Assume first package version is same as remaining package versions.
# 				installed_version=$($OPKG_CMD list-installed | $GREP_CMD "^${target_packages%% *} *" | head -n1 | cut -d' ' -f3 | cut -d'-' -f1)
#
# 				if [[ ${installed_version//.} -gt 2392 ]]; then
# 					ipks_downgrade=true
# 					ShowAsNote "git IPKs will be downgraded back to a working version"
# 					IPKs-ACdowngrade-to:Add "$target_packages"
# 				else
# 					IPKs-ACdowngrade-sk:Add "$target_packages"
# 				fi
		esac
	fi

	BuildQPKGsIsCanBackup
	BuildQPKGsIsCanRestartToUpdate
	BuildQPKGsIsCanClean
	AllocPackGroupsToAcs
	AllocPackStatesToAcs

	if QPKGs-ISupgradable.Exist sherpa; then
		ShowAsNote "the $(TextBrightOrange sherpa) QPKG will be auto-upgraded"
		QPKGs-ACupgrade-to:Add sherpa
	fi

	wait 2> /dev/null			# Ensure Entware package updater completes before continuing.

	FuncExit

	}

QPKGsAssignToActions()
	{

	# This function handles most of the high-level logic for package actions.
	# If a package isn't being processed by the correct action, odds-are it's due to a logic error in this function.

	[[ $run_package_actions = true ]] || return 0

	FuncInit

	ShowAsProc 'QPKG assignment'

	local action=''
	local prospect=''

	# KLUDGE: ensure Entware is reinstalled when IPKs are upgraded.

	if QpkgIsInstalled Entware; then
		local entware_install_date=$(QpkgGetInstalledDate Entware)

		if [[ $entware_install_date = undefined || ${entware_install_date//[!0-9]/} -le 20240809 ]] && [[ $r_nas_arch != armv5tel ]]; then
			ShowAsNote "the $(TextBrightOrange Entware) QPKG will be auto-reinstalled (Entware packages were updated early in August 2024)"
			QPKGs-ACreinstall-to:Add Entware
		fi
	fi

	# Meta-action pre-processing. Perform check for backup file here, to determine if QPKG should be downloaded, installed and restored.

	if QPKGs-ACrebuild-to.IsAny; then
		for qpkg_name in $(QPKGs-ACrebuild-to:Array); do
			QpkgSetIndex

			if QPKGs-ISNTinstalled.Exist "$qpkg_name" && QpkgIsBackupExist; then
				QPKGs-ACinstall-to:Add "$qpkg_name"
				QPKGs-ACrestore-to:Add "$qpkg_name"
			fi
		done
	fi

	# Install independents are installed when processing these specific actions:

	for qpkg_name in $(QPKGs-ACinstall-to:Array) $(QPKGs-ACreinstall-to:Array); do
		QpkgSetIndex

		for prospect in $(QpkgGetDatabaseDependencies); do
			QPKGs-ISNTinstalled.Exist "$prospect" && QPKGs-ACinstall-to:Add "$prospect"
		done
	done

	# Install independents for installed dependents.

	for qpkg_name in $(QPKGs-ISinstalled:Array); do
		if [[ $useropt_check = true ]] || QPKGs-ACactivate-to.Exist "$qpkg_name"; then
			QpkgSetIndex

			for prospect in $(QpkgGetDatabaseDependencies); do
				QPKGs-ISNTinstalled.Exist "$prospect" && QPKGs-ACinstall-to:Add "$prospect"
			done
		fi
	done

	# If an independent has been selected for `reinstall`/`reactivate`/`upgrade`, need to `deactivate` its dependents first, and `activate` them again later.

	for action in reinstall reactivate upgrade; do
		for qpkg_name in $(QPKGs-AC${action}-to:Array); do
			if QPKGs-GRindependent.Exist "$qpkg_name" && QPKGs-ISinstalled.Exist "$qpkg_name"; then
				QpkgSetIndex

				for prospect in $(QpkgGetDatabaseDependents); do
					if QPKGs-ISenabled.Exist "$prospect"; then
						QPKGs-ACdeactivate-to:Add "$prospect"
						! QPKGs-ACuninstall-to.Exist "$prospect" && ! QPKGs-ACinstall-to.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
					fi
				done
			fi
		done
	done

	# If an independent has been selected for `deactivate` or `uninstall`, need to `deactivate` its dependents first.

	for action in deactivate uninstall; do
		for qpkg_name in $(QPKGs-AC${action}-to:Array); do
			if QPKGs-GRindependent.Exist "$qpkg_name" && QPKGs-ISinstalled.Exist "$qpkg_name"; then
				QpkgSetIndex

				for prospect in $(QpkgGetDatabaseDependents); do
					QPKGs-ISinstalled.Exist "$prospect" && QPKGs-ACdeactivate-to:Add "$prospect"
				done
			fi
		done
	done

	# Special-case: perform complete removal and fresh install of Entware to clear all installed IPKs.

	if QPKGs-ACreinstall-to.Exist Entware; then
		QPKGs-ACreinstall-to:Remove Entware
		QPKGs-ACuninstall-to:Add Entware
		QPKGs-ACinstall-to:Add Entware
	fi

	# If an independent has been selected for `uninstall`, then `install`, need to `deactivate` its dependents first, and `activate` them again later.

	for qpkg_name in $(QPKGs-ACuninstall-to:Array); do
		if QPKGs-GRindependent.Exist "$qpkg_name" && QPKGs-ISinstalled.Exist "$qpkg_name" && QPKGs-ACinstall-to.Exist "$qpkg_name"; then
			QpkgSetIndex

			for prospect in $(QpkgGetDatabaseDependents); do
				if QPKGs-ISenabled.Exist "$prospect"; then
					QPKGs-ACdeactivate-to:Add "$prospect"
					! QPKGs-ACuninstall-to.Exist "$prospect" && ! QPKGs-ACinstall-to.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
				fi
			done
		fi
	done

	# If any QPKG has been selected for `backup`/`restore`/`upgrade`/`reinstall`, need to `deactivate` it first, and `activate` it again later.

	for action in backup restore upgrade reinstall; do
		for qpkg_name in $(QPKGs-AC${action}-to:Array); do
			if QPKGs-ISenabled.Exist "$qpkg_name"; then
				QPKGs-ACdeactivate-to:Add "$qpkg_name"
				! QPKGs-ACuninstall-to.Exist "$qpkg_name" && ! QPKGs-ACinstall-to.Exist "$qpkg_name" && QPKGs-ACactivate-to:Add "$qpkg_name"
			fi
		done
	done

	# If dependents have been selected for `reinstall`/`install`/`activate`/`reactivate`, need to `activate` their independent packages first.

	for action in reinstall install activate reactivate; do
		for qpkg_name in $(QPKGs-AC${action}-to:Array); do
			QpkgSetIndex

			for prospect in $(QpkgGetDatabaseDependencies); do
				QPKGs-ISinstalled.Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
			done
		done
	done

	# No-need to `reactivate` or `disable` packages that are to be uninstalled.

	if QPKGs.ACuninstall.GRall.IsSet; then
		QPKGs-ACreactivate-to:Init
		QPKGs-ACdisable-to:Init
	else
		QPKGs-ACreactivate-to:Remove "$(QPKGs-ACuninstall-to:Array)"
		QPKGs-ACdisable-to:Remove "$(QPKGs-ACuninstall-to:Array)"
	fi

	# No-need to `activate` packages that are to be reactivated.
	QPKGs-ACactivate-to:Remove "$(QPKGs-ACreactivate-to:Array)"

	# Build a list of original storage paths for packages to be uninstalled, then installed again later this session (a "complex reinstall").
	# This will ensure user-migrated packages end-up in the correct locations.
	QPKGs_were_installed_name=()
	QPKGs_were_installed_path=()

	if QPKGs-ACuninstall-to.IsAny; then
		for qpkg_name in $(QPKGs-ACuninstall-to:Array); do
			if QPKGs-ISinstalled.Exist "$qpkg_name" && QPKGs-ACinstall-to.Exist "$qpkg_name"; then
				QPKGs_were_installed_name+=("$qpkg_name")
				QpkgSetIndex
				QPKGs_were_installed_path+=("$($DIRNAME_CMD "$(QpkgGetInstalledPath)")")
			fi

			QPKGs-ACdeactivate-to:Add "$qpkg_name"
		done
	fi

	# Build list to download.

	QPKGs-ACdownload-to:Add "$(QPKGs-ACinstall-to:Array)"

	for qpkg_name in $(QPKGs-ACreinstall-to:Array); do
		QPKGs-ISinstalled.Exist "$qpkg_name" && QPKGs-ACdownload-to:Add "$qpkg_name"		# Only download files for reinstallable QPKGs.
	done

	for qpkg_name in $(QPKGs-ACupgrade-to:Array); do
		QPKGs-ISupgradable.Exist "$qpkg_name" && QPKGs-ACdownload-to:Add "$qpkg_name"		# Only download files for upgradable QPKGs.
	done

	# Check all packages.

	if [[ $useropt_check = true ]]; then
		OsIsSupportSignedPackages && QPKGs-ACsign-to:Add "$(QPKGs-ISinstalled:Array)"

		for qpkg_name in $(QPKGs-GRdependent:Array); do
			QPKGs-ISenabled.Exist "$qpkg_name" && QPKGs-ACreactivate-to:Add "$qpkg_name"
		done
	fi

	QPKGs-ACdeactivate-to:Remove sherpa
	QPKGs-ACuninstall-to:Remove sherpa

	if QPKGs-ACsign-to.IsAny || QPKGs-ACinstall-to.IsAny; then
		LoadQpkgSigning
	fi

	FuncExit

	}

# QPKG action processing shall-be conducted in this order:
#
#	1. status all
#	2. rebuild all				(meta-action: `download`, `install` & `restore` QPKG, but only if package has an existing backup file)
#	3. reassign all
#	4. download all
#
#	5. stop/deactivate dependents
#   6. disable-auto-update dependents
#	7. backup dependents
#	8. disable dependents
#   9. uninstall dependents
#
#  10. stop/deactivate independents
#  11. disable-auto-update independents
#  12. backup independents
#  13. disable independents
#  14. uninstall independents
#
#  15. upgrade independents
#  16. reinstall independents
#  17. install independents
#  18. restore independents
#  19. enable-auto-update independents
#  20. clean independents
#  21. enable independents
#  22. restart/reactivate independents
#  23. start/activate independents
#
#  24. auxiliary packages (IPKs and PIPs) are managed here.
#
#  25. "sign" independents
#
#  26. upgrade dependents
#  27. reinstall dependents
#  28. install dependents
#  29. restore dependents
#  30. enable-auto-update dependents
#  31. clean dependents
#  32. "sign" dependents
#  33. enable dependents
#  34. restart/reactivate dependents
#  35. start/activate dependents

ProcActions()
	{

	# Run all actions on selected packages in all tiers.

	[[ $run_package_actions = true ]] || return

	FuncInit

	ShowAsProc 'package actions'

	local action=''
	local state=''
	local tier=''
	local -i tier_index=0

	rm -f "$r_session_action_results_pathfile" 2> /dev/null

	# -> Package preparation phase <-

	ProcAction status all QPKG 'live status'

	if [[ $useropt_show_status = false ]]; then
		ShowAsProc 'assign QPKGs by state'				# Update action lists based-on QPKG `status`.

		for action in "${r_user_qpkg_actions[@]}"; do
			for state in "${r_qpkg_is_states[@]}"; do
				QPKGs.AC${action}.IS${state}.IsSet && QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
			done

			for state in "${r_qpkg_isnt_states[@]}"; do
				QPKGs.AC${action}.ISNT${state}.IsSet && QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
			done
		done
	fi

	ProcAction rebuild all QPKG meta-rebuild
	ProcAction reassign all QPKG reassign
	ProcAction download all QPKG download

	# If any QPKG download failed, don't attempt further actions.

	if QPKGs-ACdownload-er.IsNone && QPKGs-ACdownload-se.IsNone && QPKGs-ACdownload-sa.IsNone; then
		# -> Package removal phase <-

		for ((tier_index=${#r_package_tiers[@]}-1; tier_index>=0; tier_index--)); do		# Process tiers in-reverse.
			tier=${r_package_tiers[$tier_index]}

			case $tier in
				?(in)dependent)
					ProcAction deactivate $tier QPKG deactivate
					ProcAction disableau $tier QPKG 'disable auto-update'
					ProcAction backup $tier QPKG backup
					ProcAction disable $tier QPKG disable
					ProcAction uninstall $tier QPKG uninstall
					;;
				auxiliary)
					if QPKGs-ISenabled.Exist Entware; then
						ModPathToEntware
						PIPs:uninstall
						IPKs:uninstall
					fi
			esac
		done

		# -> Package installation phase <-

		for tier in "${r_package_tiers[@]}"; do
			case $tier in
				?(in)dependent)
					ProcAction upgrade $tier QPKG upgrade
					ProcAction reinstall $tier QPKG reinstall
					ProcAction install $tier QPKG install
					ProcAction restore $tier QPKG restore
					ProcAction enableau $tier QPKG 'enable auto-update'
					ProcAction clean $tier QPKG clean
					[[ $tier = dependent ]] && ProcAction sign $tier QPKG '"sign"'
					ProcAction enable $tier QPKG enable
					ProcAction reactivate $tier QPKG reactivate
					ProcAction activate $tier QPKG activate
					;;
				auxiliary)
					for action in status install reinstall upgrade activate; do
						if (QPKGs-ACinstall-ok.Exist Entware) || QPKGs-AC${action}-to.IsAny && QPKGs-ISenabled.Exist Entware; then
							ipks_downgrade=true
							ipks_install=true
							ipks_upgrade=true
							pips_install=true
							break
						fi
					done

					if QPKGs-ISenabled.Exist Entware; then
						ModPathToEntware
						IPKs:upgrade
						IPKs:install
						IPKs:downgrade
						PIPs:upgrade
						PIPs:install
					fi

					QPKGs-ACinstall-ok.Exist Entware && [[ $sqlite_pathfile = /opt/bin/sqlite3 && -e $sqlite_pathfile ]] && OsIsSupportSignedPackages && QPKGs-ACsign-to:Add "$(QPKGs-ISinstalled:Array)"

					ProcAction sign independent QPKG '"sign"'
			esac
		done
	fi

	if [[ $useropt_debug = true ]]; then
		ListQPKGsActions
		ListIPKsActions
		ListPIPsActions
	fi

	if [[ $title_shown = true ]]; then
		if ErrorIsNt; then
			ShowAsDone 'actions complete'
		else
			ShowAsFail 'actions complete with errors'
		fi
	fi

	show_action_results_report=true

	FuncExit

	}

ProcAction()
	{

	# Run a single action on an entire tier of packages, asynchronously where-possible.

	# Inputs: (local)
	#   $1 = an action to run 			e.g. `activate`, `reactivate` ...
	#   $2 = target tier 				e.g. `independent`, `dependent`, `auxiliary`, `all`
	#   $3 = package type to process 	e.g. `QPKG`, `IPK`, `PIP`
	#   $4 = action intransitive verb	e.g. `activate`

	# Inputs: (global)
	#	$r_action_abort_pathfile
	#	$r_async_procs_path
	#   $fail_count
	#	$ipks_downgrade
	#	$ipks_install
	#	$ipks_upgrade
	#   $ok_count
	#	$pips_install
	#   $skip_abort_count
	#   $skip_count
	#   $skip_error_count
	#   $skip_ok_count
	#	$useropt_terse
	#	$useropt_verbose

	# Outputs: (global)
	#   $fail_count
	#	$fork_progress_prefix
	#   $ok_count
	#   $pidfile
	#   $show_action_results_failed
	#   $show_action_results_ok
	#   $show_action_results_skipped
	#   $skip_abort_count
	#   $skip_count
	#   $skip_error_count
	#   $skip_ok_count
	#   $total_count
	#	$useropt_terse
	#	$useropt_verbose

	FuncInit

	local -r r_action=${1:?${FUNCNAME[0]}'()': undefined action}
	local -r r_action_intransitive_msg=${4:?${FUNCNAME[0]}'()': undefined action message}
	local group=''
	local msg1_key=''
	local msg1_value=''
	local msg2_key=''
	local msg2_value=''
	local package=''
	local -i package_index=0
	local -r r_package_type=${3:?${FUNCNAME[0]}'()': undefined package type}
	local re=''
	local state=''
	local target_object_name=''
	local -a target_packages=()
	local -r r_tier=${2:?${FUNCNAME[0]}'()': undefined tier}
	total_count=0

	DebugVar r_action
	DebugVar r_tier
	DebugVar r_package_type

	case $r_package_type in
		QPKG)
			target_object_name=AC${r_action}-to

			if [[ $r_tier = all ]]; then  # Process all tiers.
				target_packages=($(${r_package_type}s-$target_object_name:Array))
			else						# Process a single tier only.
				for package in $(${r_package_type}s-$target_object_name:Array); do
					${r_package_type}s-GR${r_tier}.Exist "$package" && target_packages+=("$package")
				done
			fi

			total_count=${#target_packages[@]}
			DebugVar total_count

			if [[ $total_count -eq 0 ]]; then
				DebugInfo 'nothing to process'

				FuncExit; return
			fi

			if [[ $total_count -eq 1 ]]; then
				fork_progress_prefix="$r_action_intransitive_msg $(TextBrightOrange "${target_packages[0]}") $r_package_type"
			else
				fork_progress_prefix="$r_action_intransitive_msg $([[ $r_tier != all ]] && echo "$r_tier ")$(Uppercase "$r_package_type")$(Pluralise "$total_count")"
			fi

			SetMaxForks "$r_action"
			InitForkCounts
			OpenActionMsgPipe

			re=\\bEntware\\b		# Bash 3.2 regex with word boundaries: https://stackoverflow.com/a/9793094

			if [[ $r_action = uninstall && ${target_packages[*]} =~ $re ]]; then
				ShowKeystrokes		# Enable this before removing Entware (& GNU `stty`).
			fi

			pidfile=$($MKTEMP_CMD "$r_async_procs_path"/bgproc_XXXXXX)		# Set $pidfile here, before launching async process so it's inherited by that process.

			_ExecOneActionWithManyForks_ "_${r_package_type}:${r_action}_" "${target_packages[@]}" &

			echo "$!" > "$pidfile"

			# Read message pipe and process QPKGs and actions as-per requests contained within.

			while [[ ${#target_packages[@]} -gt 0 && ! -e $r_action_abort_pathfile ]]; do
				ReadFromActionMsgPipe msg1_key msg1_value msg2_key msg2_value

				case $msg1_key in
					env)			# Change the state of the parent environment.
						eval "$msg1_value"	# Run this as executable.

						;;
					change)			# Change the state of a single QPKG in the parent shell.
						while true; do
							for state in "${r_qpkg_is_states[@]}" "${r_qpkg_states_transient[@]}"; do
								case $msg1_value in
									"IS${state}")
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Add "$msg2_value"
										break 2
								esac
							done

							for state in "${r_qpkg_isnt_states[@]}" "${r_qpkg_states_transient[@]}"; do
								case $msg1_value in
									"ISNT${state}")
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Add "$msg2_value"
										break 2
								esac
							done

							for group in "${r_qpkg_is_groups[@]}"; do
								case $msg1_value in
									"GR${group}")
										[[ $(type -t QPKGs-GRNT${group}:Init) = function ]] && QPKGs-GRNT${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-GR${group}:Init) = function ]] && QPKGs-GR${group}:Add "$msg2_value"
										break 2
								esac
							done

							for group in "${r_qpkg_isnt_groups[@]}"; do
								case $msg1_value in
									"GRNT${group}")
										[[ $(type -t QPKGs-GR${group}:Init) = function ]] && QPKGs-GR${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-GRNT${group}:Init) = function ]] && QPKGs-GRNT${group}:Add "$msg2_value"
										break 2
								esac
							done

							DebugAsWarn "unidentified change request in message queue: '$msg1_value'"
							break
						done

						;;
					status)			# Update the status of a single action fork in the parent shell.
						case $msg1_value in
							ok)		# Completed OK (wonderful!)
								[[ $r_action != status ]] && ((ok_count++))		# No-need to count result of `status` checks.
								;;
							so)		# Action was skipped, but this is normal (no-big-deal).
								((skip_ok_count++))
								;;
							sk)		# Action was skipped (and there's a good reason for it).
								((skip_count++))
								;;
							se)		# Action was skipped due to error prior to action being attempted (might be a big-deal).
								((skip_error_count++))
								;;
							sa)		# Action was skipped and must immediately abort (don't attempt this action again).
								((skip_abort_count++))
								/bin/touch "$r_action_abort_pathfile"
								;;
							er)		# Action failed (uh-oh).
								((fail_count++))
						esac

						case $msg1_value in
							ok|so|sk|se|sa|er)
								[[ $(type -t QPKGs-AC${r_action}-to:Init) = function ]] && QPKGs-AC${r_action}-to:Remove "$msg2_value"
								[[ $(type -t QPKGs-AC${r_action}-${msg1_value}:Init) = function ]] && QPKGs-AC${r_action}-${msg1_value}:Add "$msg2_value"

								# Also add to 'done' list.
								[[ $(type -t QPKGs-AC${r_action}-dn:Init) = function ]] && QPKGs-AC${r_action}-dn:Add "$msg2_value"
								;;
							ex)		# Action is about to exit.
								for package_index in "${!target_packages[@]}"; do
									if [[ ${target_packages[package_index]} = "$msg2_value" ]]; then
										unset 'target_packages[package_index]'
										break
									fi
								done
								;;
							*)
								DebugAsWarn "unidentified status in message queue: '$msg1_value'"
						esac

						;;
					*)
						DebugAsWarn "unidentified key in message queue: '$msg1_key'"
				esac

				[[ -e $r_action_abort_pathfile ]] && break
			done

			[[ $fail_count -gt 0 ]] && show_action_results_failed=true
			[[ $ok_count -gt 0 ]] && show_action_results_ok=true
			[[ $skip_count -gt 0 || $skip_ok_count -gt 0 || $skip_error_count -gt 0 || $skip_abort_count -gt 0 ]] && show_action_results_skipped=true

			[[ ${#target_packages[@]} -gt 0 ]] && KillPID "$(<$pidfile)"		# Only needed if an action fork didn't exit properly.
			wait 2> /dev/null
			CloseActionMsgPipe

			# TODO: Process unactioned QPKGs here (if-any), and mark them as aborted.

# 			for package in $(QPKGs-AC${r_action}-to:Array); do
# 				if ! QPKGs-AC${r_action}-dn.Exist "$package"; then
# 					QPKGs-AC${r_action}-sa:Add "$package"
# 					QPKGs-AC${r_action}-dn:Add "$package"
# 				fi
# 			done

			[[ ${useropt_terse:=true} = false && $useropt_verbose = false ]] && echo
			;;
		IPK|PIP)
			if [[ $ipks_downgrade = true || $ipks_install = true || $ipks_upgrade = true || $pips_install = true ]]; then
				InitForkCounts
				${r_package_type}s:${r_action}		# Only process these packages in groups, not individually.
			fi
	esac

	EraseForkCountPaths

	FuncExit

	ErrorIsNt

	}

OpenActionMsgPipe()
	{

	# Inputs: (global)
	#	$r_action_msg_pipe

	# Outputs: (global)
	#	$action_msg_pipe_fd
	#	$backup_stdin_fd

	# Create a message pipe, so action forks can send data back to parent.

	[[ -p $r_action_msg_pipe ]] && rm -f "$r_action_msg_pipe" 2> /dev/null
	[[ ! -d $($DIRNAME_CMD "$r_action_msg_pipe") ]] && mkdir -p "$($DIRNAME_CMD "$r_action_msg_pipe")"
	[[ ! -p $r_action_msg_pipe ]] && $MKNOD_CMD "$r_action_msg_pipe" p

	# Create a file descriptor to store original stdin FD.

	backup_stdin_fd=$(FindNextFD)
	DebugVar backup_stdin_fd

	# Backup original stdin file descriptor so it can be restored later.

	eval "exec $backup_stdin_fd>&0"

	# Create another file descriptor to use in message pipe.

	action_msg_pipe_fd=$(FindNextFD)
	DebugVar action_msg_pipe_fd

	# Open a 2-way channel to message pipe.

	[[ $action_msg_pipe_fd != none ]] && eval "exec $action_msg_pipe_fd<>$r_action_msg_pipe"

	}

CloseActionMsgPipe()
	{

	# Inputs: (global)
	#	$action_msg_pipe_fd
	#	$backup_stdin_fd
	#	$r_action_msg_pipe

	# Restore original file descriptors, and remove message pipe.

	if [[ -n ${backup_stdin_fd:-} ]]; then
		# Restore stdin FD.

		[[ $backup_stdin_fd != none ]] && eval "exec 0>&$backup_stdin_fd"

		# Release backup of stdin FD.

		[[ $backup_stdin_fd != none ]] && eval "exec $backup_stdin_fd>&-"
	fi

	# Release message pipe FD.

	[[ -n ${action_msg_pipe_fd:-} && $action_msg_pipe_fd != none ]] && eval "exec $action_msg_pipe_fd>&-"

	# Delete message pipe.

	[[ -n ${r_action_msg_pipe:-} && -p $r_action_msg_pipe ]] && rm -f "$r_action_msg_pipe" 2> /dev/null

	}

SetMaxForks()
	{

	# Inputs: (local)
	#   $1 = action

	# Inputs: (global)
	#   $r_concurrency
	#   $useropt_debug
	#   $useropt_verbose

	# Outputs: (global)
	#   $max_forks

	max_forks=$r_concurrency
	local reason=''

	if [[ $useropt_verbose = true ]]; then 					# No-point running async actions in verbose mode: stdout will be a confusing mess.
		max_forks=1
		reason='verbose mode is active'
	elif [[ $useropt_debug = true ]]; then 					# Same goes for debug mode: logs will be a mess.
		max_forks=1
		reason='debug mode is active'
	else
		case ${1:-} in
			?(re)install|upgrade)							# Don't execute these actions async: installer for each package eventually aborts (QPKGs can only be managed one-at-a-time, else packages overwrite each other, and package source files end-up in the wrong install paths).
				max_forks=1
				;;
			clean)											# Precautionary: don't make too-many calls to PyPI at the same time.
				max_forks=$(((r_concurrency+1)/2))
				;;
			backup|deactivate|download|uninstall)			# Low-resource actions, so allow multiple forks, even on ARMv5.
				max_forks=4
				;;
			@(dis|en)able?(au)|rebuild|sign|status)			# Really-low-resource actions.
				max_forks=8
		esac

		[[ $max_forks -ne $r_concurrency ]] && reason="'$1' was requested"
	fi

	[[ -n $reason ]] && DebugInfo "setting \$max_forks to $max_forks because $reason"
	DebugVar max_forks

	}

PrepareArgs()
	{

	# Process user arguments ready for parsing.

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Inputs: (global)
	#   $r_args_raw

	# Outputs: (global)
	#   $arg_problem
	#   $args[]
	#   $useropt_help_basic

	ShowAsProc args

	local a=$(Lowercase "${r_args_raw//,/ }")
	args=(${a/--/})
	arg_problem=false

	DebugArray args "${args[*]:-}"							#devdebug

	[[ -z $r_args_raw ]] && useropt_help_basic=true

	}

ParseManagementArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $args[]
	#   $args_incomplete[]
	#	$generate_show_report
	#	$get_qpkg_states
	#	$run_package_actions
	#	$switch_branch
	#	$switch_colour
	#	$switch_report_footer
	#	$switch_terse
	#	$user_branch_value
	#	$user_colourful_value
	#	$user_report_footer_value
	#	$user_terse_value
	#	$useropt_check
	#	$useropt_paste_log_last
	#	$useropt_paste_log_tail

	FuncInit

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				check)
					generate_show_report=true
					get_qpkg_states=true
					requires_group=false
					run_package_actions=true
					user_action=$arg
					useropt_check=true
					;;
				colo?(u)r?(ful)|follow|paste|report-footer|terse)
					requires_group=true
					user_action=$arg
					;;
				debug|verbose)
					requires_group=false
					user_action=$arg
					EnableVerbose
					EnableDebugToArchiveAndFile
					;;
				reset)
					DeleteSetting Colourful
					DeleteSetting Git_Branch
					DeleteSetting Terse

					Reset				# <-- Processing will terminate in this function (no-return).
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				colo?(u)r?(ful))
					case $group in
						true|false)
							action=''
							awaiting_group=false
							switch_colour=true
							user_colourful_value=$group
							UpdateColourful
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				follow)
					case $group in
						?(un)stable)
							action=''
							awaiting_group=false
							run_package_actions=false
							switch_branch=true
							user_branch_value=$group
							UpdateBranch
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				paste)
					case $group in
						last)
							action=''
							awaiting_group=false
							run_package_actions=false
							useropt_paste_log_last=true
							;;
						tail)
							action=''
							awaiting_group=false
							run_package_actions=false
							useropt_paste_log_tail=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				report-footer)
					case $group in
						true|false)
							action=''
							awaiting_group=false
							switch_report_footer=true
							user_report_footer_value=$group
							UpdateReportFooter
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				terse)
					case $group in
						true|false)
							action=''
							awaiting_group=false
							switch_terse=true
							user_terse_value=$group
							UpdateTerse
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"					#devdebug

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"											#devdebug

	FuncExit

	}

ParseHelpArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $args[]
	#   $args_incomplete[]

	FuncInit

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				help)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			abs|actions|all|all-actions|groups|lists|options|packages|problems|show|tips|upgrades)
				[[ -z $action ]] && action=help
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				help)
					case $group in
						abs)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_abbreviations=true
							;;
						actions)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_actions=true
							;;
						all|all-actions)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_actions_all=true
							;;
						groups)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_groups=true
							;;
						lists)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_lists=true
							;;
						options)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_options=true
							;;
						packages)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_packages=true
							;;
						problems)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_problems=true
							;;
						show)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_show=true
							;;
						tips)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_tips=true
							;;
						upgrades)
							action=''
							awaiting_group=false
							generate_help_report=true
							run_package_actions=false
							useropt_help_upgrades=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	for arg in "${args_incomplete[@]:-}"; do
		case $arg in
			help)							# If `help` is specified without a valid group, then show basic help.
				run_package_actions=false
				useropt_help_basic=true

				# Remove this arg from incomplete array.
				local a=''
				local tmp=()

				for a in "${args_incomplete[@]}"; do
					[[ $a != "$arg" ]] && tmp+=($a)
				done

				if [[ ${#tmp[@]:-} -eq 0 ]]; then
					args_incomplete=()
				else
					args_incomplete=("${tmp[@]}")
				fi

				unset tmp
		esac
	done

	DebugArray args_incomplete "${args_incomplete[*]:-}"					#devdebug

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"											#devdebug

	FuncExit

	}

ParseShowArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $args[]
	#   $args_incomplete[]

	FuncInit

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				show)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			about|about-all|abs|backups|dependent|features|last|packages|repositories|results|status|tail)
				[[ -z $action ]] && action=show
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				show)
					case $group in
						about)
							action=''
							awaiting_group=false
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_about=true
							;;
						about-all)
							action=''
							awaiting_group=false
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_aboutall=true
							;;
						abs)
							action=''
							awaiting_group=false
							generate_help_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_help_abbreviations=true
							;;
						backups)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_backups=true
							;;
						dependent)
							LoadPackages
							action=''
							awaiting_group=false
							generate_show_report=true
							run_package_actions=false
							useropt_show_dependencies=true
							;;
						features)
							LoadPackages
							action=''
							awaiting_group=false
							generate_show_report=true
							run_package_actions=false
							useropt_show_features=true
							;;
						last)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_log_last=true
							;;
						packages)
							LoadPackages
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_packages=true
							;;
						repositories)
							LoadPackages
							action=''
							awaiting_group=false
							generate_show_report=true
							run_package_actions=false
							useropt_show_repos=true
							;;
						results)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_previous_action_results_report=true
							show_action_results_report=true
							;;
						status)
							LoadObjects
							QPKGs.ACstatus.GRall:Set
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=true
							run_package_actions=true
							useropt_show_status=true
							;;
						tail)
							action=''
							awaiting_group=false
							generate_show_report=true
							get_qpkg_states=false
							run_package_actions=false
							useropt_show_log_tail=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"					#devdebug

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"											#devdebug

	FuncExit

	}

ParseListArgs()
	{

	# Basic argument syntax:
	#   scriptname [action] [groups] [options]

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $args[]
	#   $args_incomplete[]

	FuncInit

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				list)
					requires_group=true
					user_action=$arg
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg")
		DebugVar group

		# Include action assignment when action hasn't been previously specified.

		case $group in
			?(NT)installed|upgradable|versions)
				[[ -z $action ]] && action=list
		esac

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				list)
					case $group in
						all|?(in)dependent)
							LoadObjects
							QPKGs.AClist.GR${group}:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_states=true
							run_package_actions=false
							show_title=false
							;;
						?(NT)active)
							LoadObjects
							QPKGs.AClist.IS${group}:Set
							QPKGs.ACstatus.ISinstalled:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_active_status=true
							get_qpkg_states=true
							run_package_actions=true
							show_title=false
							;;
						?(NT)backedup|?(NT)enabled|?(NT)installable|?(NT)installed|?(NT)missing|?(NT)upgradable)
							LoadObjects
							QPKGs.AClist.IS${group}:Set
							action=''
							awaiting_group=false
							generate_list_report=true
							get_qpkg_states=true
							run_package_actions=false
							show_title=false
							;;
						versions)
							LoadPackages
							action=''
							awaiting_group=false
							generate_list_report=true
							show_title=false
							useropt_list_versions=true
							;;
						*)
							args_remaining+=("$action")
					esac
					;;
				*)
					args_remaining+=("$arg")
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"					#devdebug

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"											#devdebug

	FuncExit

	}

ParseActionArgs()
	{

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $args[]
	#   $args_incomplete[]

	FuncInit

	local action=''						# Internal, nice, simple, action name. Only one per-action.
	local arg=''
	local -a args_remaining=()
	local awaiting_group=false
	local current_action=''
	local group=''
	local potential_action=''			# A user arg that might be an action.
	local requires_group=false
	local user_action=''				# The original user argument, detected as an action. There may be many variants per-action.

	[[ -n ${args[*]:-} ]] && LoadPackages

	for arg in "${args[@]:-}"; do
		[[ -n $arg ]] || continue

		# Identify action.

		potential_action=$(MatchVerb "$arg"); DebugVar potential_action

		if [[ -n $potential_action ]]; then
			action=$potential_action; DebugVar action
			potential_action=''

			case $action in
				?(de|re)activate|backup|clean|@(dis|en)able?(au)|reassign|rebuild|?(re|un)install|restore|sign|upgrade)
					requires_group=true
					user_action=$arg
					;;
				status)
					generate_show_report=true
					get_qpkg_states=true
					requires_group=true
					user_action=$arg
					useropt_show_status=true
			esac

			if [[ -n $user_action && $user_action != "$current_action" ]]; then
				[[ $awaiting_group = true ]] && args_incomplete+=("$user_action")
				awaiting_group=$requires_group
				current_action=$user_action
				group=''	 			# When action changes, must clear group.
				continue
			fi
		fi

		# Identify group.

		group=$(MatchNoun "$arg"); DebugVar group

		# Pair action with group.

		if [[ -n $action && -n $group ]]; then
			case $action in
				?(de|re)activate|backup|clean|@(dis|en)able?(au)|reassign|@(re|un)install|restore|sign|upgrade)
					case $group in
						?(NT)active)
							LoadObjects
							QPKGs.AC${action}.IS${group}:Set
							QPKGs.ACstatus.ISinstalled:Set
							awaiting_group=false
							show_action_results_report=true
							get_qpkg_active_status=true
							get_qpkg_states=true
							run_package_actions=true
					esac
			esac

			case $group in
				all|canbackup|?(NT)canclean|canrestarttoupdate|?(in)dependent|hasdependents)
					LoadObjects
					QPKGs.AC${action}.GR${group}:Set
					awaiting_group=false
					show_action_results_report=true
					get_qpkg_active_status=false
					get_qpkg_states=true
					run_package_actions=true
					;;
				?(NT)backedup|?(NT)enabled|?(NT)installable|?(NT)installed|?(NT)missing|?(NT)upgradable)
					LoadObjects
					QPKGs.AC${action}.IS${group}:Set
					awaiting_group=false
					show_action_results_report=true
					get_qpkg_states=true
					run_package_actions=true
					;;
				*)
					[[ $action != show ]] || continue
					LoadObjects
					QPKGs-AC${action}-to:Add "$group"
					awaiting_group=false
					show_action_results_report=true
					get_qpkg_states=true
					run_package_actions=true
			esac
		else
			args_remaining+=("$arg")
		fi
	done

	if [[ $requires_group = true && $awaiting_group = true ]]; then			# Only if the last action specified was not followed by a group.
		args_incomplete+=("$user_action")									# Save the actual action word, phrase or char specified by the user.
	fi

	for arg in "${args_incomplete[@]:-}"; do
		action=$(MatchVerb "$arg")

		case $action in
			status)
				LoadObjects
				QPKGs.ACstatus.ISinstalled:Set								# If status is specified without a group, then group is `installed`.
				generate_show_report=true
				get_qpkg_states=true
				run_package_actions=true

				# Remove this arg from incomplete array.
				local a=''
				local tmp=()

				for a in "${args_incomplete[@]}"; do
					[[ $a != "$arg" ]] && tmp+=($a)
				done

				if [[ ${#tmp[@]:-} -eq 0 ]]; then
					args_incomplete=()
				else
					args_incomplete=("${tmp[@]}")
				fi

				unset tmp
		esac
	done

	DebugArray args_incomplete "${args_incomplete[*]:-}"					#devdebug

	args=(${args_remaining[@]:-})
	DebugArray args "${args[*]:-}"											#devdebug

	FuncExit

	}

MatchVerb()
	{

	# Identify variant action from $1 and output nice action.

	local a=${1:-}

	case $a in
		activate|start)
			printf activate
			;;
		add|install)
			printf install
			;;
		backup|clean|colo?(u)r?(ful)|@(dis|en)able|follow|help|list|paste|reassign|rebuild|reinstall|report-footer|reset|restore|sign|terse)
			printf '%s' "$a"
			;;
		c|check)
			printf check
			;;
		deactivate|stop)
			printf deactivate
			;;
		d?(e)bug)
			printf debug
			;;
		disable-auto-update)
			printf disableau
			;;
		enable-auto-update)
			printf enableau
			;;
		reactivate|restart)
			printf reactivate
			;;
		remove|rm|uninstall)
			printf uninstall
			;;
		s|status?(es))
			printf status
			;;
		show|view)
			printf show
			;;
		update|upgrade)
			printf upgrade
			;;
		v|verbose)
			printf verbose
	esac

	}

MatchNoun()
	{

	# Identify variant group from $1 and output nice group.

	local a=${1:-}

	case $a in
		a|abs|abbreviations)
			printf abs
			;;
		about|about-all|backedup|canbackup|enabled|installable|installed|missing|results|show|?(un)stable)
			printf '%s' "$a"
			;;
		action?(s))
			printf actions
			;;
		action?(s)-all|all-action?(s))
			printf all-actions
			;;
		active|no@(n|t)-inactive|no@(n|t)-stopped|started)
			printf active
			;;
		all|entire|everything)
			printf all
			;;
		b|backups)
			printf backups
			;;
		d|deps|dependencies|dependent?(s))
			printf dependent
			;;
		disable|false|no|off|unset)
			printf false
			;;
		disabled|no@(n|t)-enabled)
			printf NTenabled
			;;
		enable|on|set|true|yes)
			printf true
			;;
		f|features)
			printf features
			;;
		group?(s))
			printf groups
			;;
		inactive|no@(n|t)-active|no@(n|t)-started|stopped)
			printf NTactive
			;;
		indep?(endent)?(s))
			printf independent
			;;
		l|last)
			printf last
			;;
		list?(s))
			printf lists
			;;
		log|tail)
			printf tail
			;;
		me|problem?(s))
			printf problems
			;;
		new|updat?(e)able|upgrad@(a|e)ble)
			printf upgradable
			;;
		no@(n|t)-back?(ed)up)
			printf NTbackedup
			;;
		no@(n|t)-installable)
			printf NTinstallable
			;;
		no@(n|t)-installed)
			printf NTinstalled
			;;
		no@(n|t)-missing)
			printf NTmissing
			;;
		no@(n|t)-upgradable)
			printf NTupgradable
			;;
		o|option?(s))
			printf options
			;;
		p|package?(s)|qpkg?(s))
			printf packages
			;;
		r|repos|repositories)
			printf repositories
			;;
		s|status?(es))
			printf status
			;;
		tip?(s))
			printf tips
			;;
		upgrade?(s)|upgrading)
			printf upgrades
			;;
		version?(s))
			printf versions
			;;
		*)
			QpkgMatchAbbrv "$a"
	esac

	}

ShowArgSuggestions()
	{

	# Inputs: (global)
	#   $args[]
	#   $args_incomplete[]

	# Outputs: (global)
	#   $arg_problem
	#   $run_package_actions
	#   $useropt_help_basic

	FuncInit

	local arg=''
	local -a args_remaining=()

	if [[ ${#args_incomplete[@]:-} -gt 0 ]]; then
		run_package_actions=false

		for arg in "${args_incomplete[@]}"; do
			case $arg in
				?(de|re)activate|backup|clean|@(dis|en)able|@(dis|en)able-auto-update|reassign|@(re|un)install|?(re)start|restore|rm|sign|stop|upgrade)
					DisplayAsProjSynExam "please provide valid $(ShowAsPackages) or a $(ShowAsPackageGroup) after '$arg' like" "$arg installed"
					arg_problem=true
					useropt_help_basic=false
					;;
				colo?(u)r?(ful)|terse)
					DisplayAsProjSynExam "please provide a valid boolean after '$arg' like" "$arg true"
					DisplayAsProjSynIndentExam '' "$arg false"
					DisplayAsProjSynIndentExam '' "$arg on"
					DisplayAsProjSynIndentExam '' "$arg off"
					DisplayAsProjSynIndentExam '' "$arg yes"
					DisplayAsProjSynIndentExam '' "$arg no"
					DisplayAsProjSynIndentExam '' "$arg enable"
					DisplayAsProjSynIndentExam '' "$arg disable"
					arg_problem=true
					useropt_help_basic=false
					;;
				follow)
					DisplayAsProjSynExam "please provide a valid $(ShowAsTitleName) git branch to '$arg' like" "$arg stable"
					DisplayAsProjSynIndentExam '' "$arg unstable"
					arg_problem=true
					useropt_help_basic=false
					;;
				install|rebuild)
					DisplayAsProjSynExam "please provide valid $(ShowAsPackages) or a $(ShowAsPackageGroup) after '$arg' like" "$arg all"
					arg_problem=true
					useropt_help_basic=false
					;;
				list)
					DisplayAsProjSynExam "please provide a valid source to '$arg' like" "$arg installable"
					DisplayAsProjSynIndentExam '' "$arg new"
					arg_problem=true
					useropt_help_basic=false
					;;
				paste)
					DisplayAsProjSynExam "please provide a valid source to '$arg' online like" "$arg log"
					DisplayAsProjSynIndentExam '' "$arg last"
					arg_problem=true
					useropt_help_basic=false
					;;
				show)
					DisplayAsProjSynExam "please provide a valid source after '$arg' like" "$arg abs"
					DisplayAsProjSynIndentExam '' "$arg log"
					DisplayAsProjSynIndentExam '' "$arg packages"
					DisplayAsProjSynIndentExam '' "$arg results"
					arg_problem=true
					useropt_help_basic=false
					;;
				*)
					arg_problem=true
					args_remaining+=("$arg")
			esac
		done

		[[ $arg_problem = true ]] && Display

		if [[ ${#args_remaining[@]:-} -gt 0 ]]; then
			ShowAsError "incomplete argument$(Pluralise "${#args_remaining[@]}") \"${args_remaining[*]}\". Please check the arguments again"
			arg_problem=true
			args_remaining=()
		fi
	fi

	if [[ ${#args[@]:-} -gt 0 ]]; then
		run_package_actions=false

		for arg in "${args[@]}"; do
			case $arg in
				active|@(dis|en)abled|started)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "deactivate $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				all)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before 'all' like" 'activate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-activate|activate-all)
					DisplayAsProjSynExam 'to activate all QPKGs, use' 'activate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-backup|backup-all)
					DisplayAsProjSynExam 'to backup all installed QPKG configurations, use' 'backup all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-deactivate|deactivate-all)
					DisplayAsProjSynExam 'to deactivate all QPKGs, use' 'deactivate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-reactivate|reactivate-all)
					DisplayAsProjSynExam 'to reactivate all QPKGs, use' 'reactivate all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-restore|restore-all)
					DisplayAsProjSynExam 'to restore all installed QPKG configurations, use' 'restore all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-stop|stop-all)
					DisplayAsProjSynExam 'to stop all QPKGs, use' 'stop all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-uninstall|all-remove|uninstall-all|remove-all)
					DisplayAsProjSynExam 'to uninstall all QPKGs, use' 'uninstall all'
					arg_problem=true
					useropt_help_basic=false
					;;
				all-upgrade|upgrade-all)
					DisplayAsProjSynExam 'to upgrade all QPKGs, use' 'upgrade all'
					arg_problem=true
					useropt_help_basic=false
					;;
				@(dis|en)able|false|off|no|on|true|yes)
					DisplayAsProjSynExam "please provide a valid setting before '$arg' like" "colour $arg"
					DisplayAsProjSynIndentExam '' "terse $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				download)
					ShowAsError "'$arg' is not a manual action"
					arg_problem=true
					useropt_help_basic=false
					;;
				@(in|not-)active|?(in)dependent?(s)|stopped)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "activate $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				?(un)stable)
					DisplayAsProjSynExam "please provide a valid $(ShowAsAction) before '$arg' like" "follow $arg"
					arg_problem=true
					useropt_help_basic=false
					;;
				*)
					arg_problem=true
					args_remaining+=("$arg")
			esac
		done

		if [[ ${#args_remaining[@]:-} -gt 0 ]]; then
			ShowAsError "unknown argument$(Pluralise "${#args_remaining[@]}") \"${args_remaining[*]}\". Please check the arguments again"
			arg_problem=true
			useropt_help_basic=false
		elif [[ $arg_problem = true ]]; then
			Display
		fi
	fi

	DebugArray args_incomplete "${args_incomplete[*]:-}"
	DebugArray args_remaining "${args_remaining[*]:-}"

	FuncExit

	}

AllocPackGroupsToAcs()
	{

	# Inputs: (global)
	#	$r_qpkg_is_groups[]
	#	$r_qpkg_isnt_groups[]
	#	$r_user_qpkg_actions[]

	FuncInit

	ShowAsProc 'match QPKG groups to actions'

	local action=''
	local group=''

	for action in "${r_user_qpkg_actions[@]}"; do
		# Process group-based user-actions.

		# Positive groups.

		for group in "${r_qpkg_is_groups[@]}"; do
			if QPKGs.AC${action}.GR${group}.IsSet; then
				QPKGs-AC${action}-to:Add "$(QPKGs-GR${group}:Array)"

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', group: 'GR${group}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any 'GR$group' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done

		# Negative groups.

		for group in "${r_qpkg_isnt_groups[@]}"; do
			if QPKGs.AC${action}.GRNT${group}.IsSet; then
				QPKGs-AC${action}-to:Add "$(QPKGs-GRNT${group}:Array)"

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', group: 'GRNT${group}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any 'GRNT$group' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done
	done

	FuncExit

	}

AllocPackStatesToAcs()
	{

	# Inputs: (global)
	#	$r_qpkg_is_states[]
	#	$r_qpkg_isnt_states[]
	#	$r_user_qpkg_actions[]

	FuncInit

	ShowAsProc 'match QPKG states to actions'

	local action=''
	local check_later=false
	local state=''

	for action in "${r_user_qpkg_actions[@]}"; do
		# Process state-based user-actions.

		# Positive states.

		for state in "${r_qpkg_is_states[@]}"; do
			check_later=false

			if QPKGs.AC${action}.IS${state}.IsSet; then
				if [[ $state = active ]]; then
					check_later=true
				else
					QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
				fi

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', state: 'IS${state}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				elif [[ $check_later = true ]]; then
					DebugAsDone "action: '$action', state: 'IS${state}': will add filtered-QPKGs later after 'status' has been determined"
				else
					ShowAsWarn "unable to find any '$state' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done

		# Negative states.

		for state in "${r_qpkg_isnt_states[@]}"; do
			check_later=false

			if QPKGs.AC${action}.ISNT${state}.IsSet; then
				if [[ $state = active ]]; then
					check_later=true
				else
					QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
				fi

				if QPKGs-AC${action}-to.IsAny; then
					DebugAsDone "action: '$action', state: 'ISNT${state}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				elif [[ $check_later = true ]]; then
					DebugAsDone "action: '$action', state: 'ISNT${state}': will add filtered-QPKGs later after 'status' has been determined"
				else
					ShowAsWarn "unable to find any 'not $state' QPKGs to '$(Lowercase "$action")'"
				fi
			fi
		done
	done

	FuncExit

	}

ResetArchivedLogs()
	{

	# Inputs: (global)
	#	$r_logs_path
	#	$r_this_package_path
	#	$sess_active_pathfile

	if [[ -n $r_logs_path && -d $r_logs_path ]]; then
		ClearPath "$r_this_package_path" "$r_logs_path"
		echo 'log reset' > "$sess_active_pathfile"
		ShowAsDone 'logs cleared'
	fi

	return 0

	}

ResetCachePath()
	{

	# Inputs: (global)
	#	$r_cache_path
	#	$r_this_package_path

	if [[ -n $r_cache_path && -d $r_cache_path ]]; then
		ClearPath "$r_this_package_path" "$r_cache_path"
		ShowAsDone 'package cache cleared'
	fi

	return 0

	}

ResetReportsPath()
	{

	# Inputs: (global)
	#	$r_reports_path

	if [[ -n $r_reports_path && -d $r_reports_path ]]; then
		ClearPath /var/log/sherpa "$r_reports_path"
		ShowAsDone 'reports cleared'
	fi

	return 0

	}

Quiz()
	{

	# Inputs: (local)
	#   $1 = prompt/question

	# Outputs: (local)
	#   $? = 0 if "y", 1 if anything else

	local a=${1:?${FUNCNAME[0]}'()': undefined prompt}
	local b=''

	ShowAsQuiz "$a"
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD igncr	# Ignore CR to prevent an onscreen linefeed (which disrupts same-line rewrite used later, and looks bad).
	read -rn1 b
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD -igncr	# Re-allow CR.
	DebugVar b

	ShowAsQuizDone "$a: $b"

	case ${b:0:1} in
		y|Y)
			return 0
			;;
		*)
			return 1
	esac

	}

PatchEntwareService()
	{

	local -r r_tab_char=$'\t'
	local -r r_prefix='# the following line was inserted by sherpa: https://git.io/sherpa'
	local -r r_package_init_pathfile=$(QpkgGetInstalledServicePathFile Entware)
	local find=''
	local insert=''

	if $GREP_CMD -q 'opt.orig' "$r_package_init_pathfile"; then
		DebugInfo 'patch: do the "/opt shuffle" - already done'
	else
		# Ensure existing files are moved out of the way before creating /opt symlink.
		find='# sym-link $QPKG_DIR to /opt'
		insert='opt_path="/opt"; opt_backup_path="/opt.orig"; [[ -d "$opt_path" \&\& ! -L "$opt_path" \&\& ! -e "$opt_backup_path" ]] \&\& mv "$opt_path" "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${r_tab_char}${r_prefix}\n${r_tab_char}${insert}\n|" "$r_package_init_pathfile"

		# ... then restored after creating /opt symlink.
		find='/bin/ln -sf $QPKG_DIR /opt'
		insert='[[ -L "$opt_path" \&\& -d "$opt_backup_path" ]] \&\& cp "$opt_backup_path"/* --target-directory "$opt_path" \&\& rm -r "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${r_tab_char}${r_prefix}\n${r_tab_char}${insert}\n|" "$r_package_init_pathfile"

		DebugAsDone 'patch: do the "opt shuffle"'
	fi

	return 0

	}

_UpdateEntwarePackageList_()
	{

	# * This function runs asynchronously *

	if IsNtSysFileExist $OPKG_CMD; then
		DisplayAsProjSynExam 'try reactivating Entware' 'reactivate ew'

		return 1
	fi

	[[ ${r_entware_package_list_uptodate:-false} = false ]] || return

	local -i z=0

	# If Entware package list was recently updated, don't update again.

	if ! IsThisFileRecent "$r_external_packages_archive_pathfile" "$r_file_change_threshold_minutes" || [[ ! -f $r_external_packages_archive_pathfile || $useropt_check = true ]]; then
		DebugAsProc "updating $(ShowAsPackageName Entware) package list"

		RunAndLog "$OPKG_CMD update" "$r_logs_path/Entware.$r_update_log_file" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			DebugAsDone "updated $(ShowAsPackageName Entware) package list"
			CloseIpkArchive
		else
			DebugAsWarn "Unable to update $(ShowAsPackageName Entware) package list $(ShowAsExitcode "$z")"
			# no-big-deal
		fi
	else
		DebugInfo "$(ShowAsPackageName Entware) package list was updated less-than $r_file_change_threshold_minutes minutes ago: skipping update"
	fi

	[[ -f $r_external_packages_archive_pathfile && ! -f $r_external_packages_pathfile ]] && OpenIpkArchive
	readonly r_entware_package_list_uptodate=true

	return 0

	}

IsThisFileRecent()
	{

	# Inputs: (local)
	#   $1 = pathfilename: file to examine change time of.
	#   $2 = integer (optional): threshold in minutes - default is `1440` (1 day).

	# Outputs: (local)
	#   $? = true/false

	# Examine `change` time as this is updated even if file content isn't modified.

	# https://stackoverflow.com/a/55622661
	[[ -e ${1:-} && $((($(ConvertNowToSeconds)-$(/usr/bin/stat "$1" -c %Z))/60)) -le ${2:-1440} ]]

	}

SaveIpkAndPipList()
	{

	# Inputs: (global)
	#	$r_prev_ipk_list_pathfile
	#	$r_prev_pip_list_pathfile

	$PIP_CMD freeze | cut -d'=' -f1 > "$r_prev_pip_list_pathfile"
	[[ -e $r_prev_pip_list_pathfile ]] && DebugAsDone "saved current PIP list to $(ShowAsFileName "$r_prev_pip_list_pathfile")"

	$OPKG_CMD list-installed > "$r_prev_ipk_list_pathfile"
	[[ -e $r_prev_ipk_list_pathfile ]] && DebugAsDone "saved current $(ShowAsPackageName Entware) IPK list to $(ShowAsFileName "$r_prev_ipk_list_pathfile")"

	} 2> /dev/null

LoadIpkList()
	{

	# Inputs: (global)
	#	$r_prev_ipk_list_pathfile

	local name=''
	local separator=''
	local version=''

	if [[ -e $r_prev_ipk_list_pathfile ]]; then
		DebugInfo "IPKs are being loaded from $(ShowAsFileName "$r_prev_ipk_list_pathfile")"

		while read -r name separator version; do
			name=$(Lowercase "$name")

			IPKs-ACinstall-to:Add "$name"
		done < "$r_prev_ipk_list_pathfile"
	fi

	}

LoadPipList()
	{

	# Inputs: (global)
	#	$r_prev_pip_list_pathfile

	local name=''
	local re=''

	if [[ -e $r_prev_pip_list_pathfile ]]; then
		DebugInfo "PIPs are being loaded from $(ShowAsFileName "$r_prev_pip_list_pathfile")"

		while read -r name; do
			name=$(Lowercase "$name")
			re=\\b$name\\b

			[[ ${r_exclusion_pips[*]} =~ $re ]] || PIPs-ACinstall-to:Add "$name"
		done < "$r_prev_pip_list_pathfile"
	fi

	}

CalcIpkDepsToInstall()
	{

	# From a specified list of IPK names, find all dependent IPKs, exclude those already installed, then generate a list to download.

	# Inputs: (global)
	#	$r_external_packages_pathfile
	#	$useropt_terse
	#	$useropt_verbose

	# Outputs: (global)
	#	$show_suggest_raise_issue
	#	$useropt_terse
	#	$useropt_verbose

	IsSysFileExist $GNU_GREP_CMD || return

	FuncInit

	local complete=false
	local -a dep_acc=()
	local element=''
	local ipk_titles=''
	local -i iterations=0
	local -r r_iteration_limit=20
	local -i pre_exclude_count=0
	local pre_exclude_list=''
	local req_list=''
	local -i requested_count=0
	local -a this_list=()

	# Remove duplicate entries.
	req_list=$(DeDupeWords "$(IPKs-ACinstall-to:List)")
	dep_acc=($req_list)
	this_list=($req_list)
	requested_count=$($WC_CMD -w <<< "$req_list")

	if [[ $requested_count -eq 0 ]]; then
		DebugAsWarn 'no IPKs requested'

		FuncExit 1; return
	fi

	DebugInfo "$requested_count IPK$(Pluralise "$requested_count") requested" "'$req_list' "

	while [[ $iterations -le $r_iteration_limit ]]; do
		ShowAsIterativeProgress 'resolve IPK dependencies' "$iterations" iteration "${#dep_acc[@]}" 'unique IPK'

		((iterations++))
		printf -v ipk_titles '^Package: %s$\|' "${this_list[@]}"
		ipk_titles=${ipk_titles%??}		# Remove last 2 characters.

		this_list=($($GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator '^Package:\|^Depends:' "$r_external_packages_pathfile" | $GNU_GREP_CMD -vG '^Section:\|^Version:' | $GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator "$ipk_titles" | $GNU_GREP_CMD -vG "$ipk_titles" | $GNU_GREP_CMD -vG '^Package: ' | $SED_CMD 's|^Depends: ||;s|, |\n|g' | $SORT_CMD | $UNIQ_CMD))

		# Update progress twice per loop.
		ShowAsIterativeProgress 'resolve IPK dependencies' "$iterations" iteration "${#dep_acc[@]}" 'unique IPK'

		if [[ ${#this_list[@]} -eq 0 ]]; then
			complete=true
			break
		else
			dep_acc+=(${this_list[*]})
			dep_acc=($(DeDupeWords "${dep_acc[*]}"))
		fi
	done

	sleep .5

	[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo

	if [[ $complete = true ]]; then
		DebugAsDone "dependency calculation complete in $iterations iteration$(Pluralise "$iterations")"
	else
		DebugAsError "dependency calculation incomplete in $iterations iteration$(Pluralise "$iterations"), consider raising \$r_iteration_limit [$r_iteration_limit]"
		show_suggest_raise_issue=true
	fi

	# Exclude already installed IPKs.
	pre_exclude_list=${dep_acc[*]}
	pre_exclude_count=$($WC_CMD -w <<< "$pre_exclude_list")

	if [[ $pre_exclude_count -gt 0 ]]; then
		ShowAsProc 'exclude IPKs already installed'

		DebugInfo "$pre_exclude_count IPK$(Pluralise "$pre_exclude_count") required (including dependencies)" "'$pre_exclude_list' "

		for element in $pre_exclude_list; do
			# KLUDGE: silently exclude these packages from being installed:
			#   `ca-certs` appears to be a bogus meta-package.
			#   `python3-gdbm` is not available, but can be requested as per https://forum.qnap.com/viewtopic.php?p=806031#p806031 (don't know why).

			if [[ $element != 'ca-certs' && $element != 'python3-gdbm' ]]; then
				# KLUDGE: `libjpeg` appears to have been replaced by `libjpeg-turbo`, but many packages still have `libjpeg` as a dependency, so replace it with `libjpeg-turbo`.

				if [[ $element != 'libjpeg' ]]; then
					if ! $OPKG_CMD status "$element" | $GREP_CMD -q "Status:.*installed"; then
						IPKs-ACdownload-to:Add "$element"
					fi
				elif ! $OPKG_CMD status 'libjpeg-turbo' | $GREP_CMD -q "Status:.*installed"; then
					IPKs-ACdownload-to:Add 'libjpeg-turbo'
				fi
			fi
		done
	else
		DebugAsDone 'no IPKs to exclude'
	fi

	FuncExit

	}

CalcIpkDownloadSize()
	{

	# Calculate size of required IPKs.

	# Inputs: (global)
	#	$r_external_packages_pathfile

	FuncInit

	local -a size_array=()
	local -i size_count=0
	size_count=$(IPKs-ACdownload-to:Count)

	if [[ $size_count -gt 0 ]]; then
		ShowAsProc "calculate size of IPK$(Pluralise "$size_count") to download"

		DebugAsDone "$size_count IPK$(Pluralise "$size_count") to download: '$(IPKs-ACdownload-to:List)'"
		size_array=($($GNU_GREP_CMD -w '^Package:\|^Size:' "$r_external_packages_pathfile" | $GNU_GREP_CMD --after-context 1 --no-group-separator ": $($SED_CMD 's/ /$ /g;s/\$ /\$\\\|: /g' <<< "$(IPKs-ACdownload-to:List)")" | $GREP_CMD '^Size:' | $SED_CMD 's|^Size: ||'))

		# shellcheck disable=2283
		IPKs-ACdownload-to:Size = "$(IFS=+; echo "$((${size_array[*]:-}))")"		# nifty sizing shortcut found here https://stackoverflow.com/a/13635566/6182835
		DebugAsDone "$(FormatAsThous "$(IPKs-ACdownload-to:Size)") bytes ($(FormatAsIsoBytes "$(IPKs-ACdownload-to:Size)")) to download"
	else
		DebugAsDone 'no IPKs to size'
	fi

	FuncExit

	}

IPKs:upgrade()
	{

	# Upgrade all installed IPKs.

	# Inputs: (global)
	#	$r_ipk_cache_path
	#	$r_ipk_download_path
	#	$ipks_upgrade
	#	$r_logs_path
	#	$r_upgrade_log_file
	#	$useropt_terse
	#	$useropt_verbose

	# Outputs: (global)
	#	$useropt_terse
	#	$useropt_verbose

	[[ $ipks_upgrade = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	ErrorIsNt || return

	FuncInit

	local desc=''
	local fork_pid=''
	local -i total_count=0
	local -i z=0

	IPKs-ACupgrade-to:Init
	IPKs-ACdownload-to:Init

	IPKs-ACupgrade-to:Add "$($OPKG_CMD list-upgradable | cut -f1 -d' ')"

	# Don't upgrade IPKs that must remain downgraded.
	IPKs-ACupgrade-to:Remove "$(IPKs-ACdowngrade-to:Array)"
	IPKs-ACupgrade-to:Remove "$(IPKs-ACdowngrade-sk:Array)"

	IPKs-ACdownload-to:Add "$(IPKs-ACupgrade-to:Array)"

	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		desc="$total_count auxiliary IPK$(Pluralise "$total_count")"

		ShowAsProc "upgrade $desc"

		_DirSizeMonitor_ "$r_ipk_download_path" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD upgrade --force-overwrite $(IPKs-ACdownload-to:List) --cache $r_ipk_cache_path --tmp-dir $r_ipk_download_path" "$r_logs_path/ipks.$r_upgrade_log_file" log:failure-only
		z=$?

		KillPID "$fork_pid"

		if [[ $z -eq 0 ]]; then
			NoteIpkAcAsOk "$(IPKs-ACupgrade-to:Array)" upgrade
			DebugAsDone "upgraded $desc"
			SaveActionResultToLog IPK auxiliary upgrade "$total_count" ok
		else
			NoteIpkAcAsEr "$(IPKs-ACupgrade-to:Array)" upgrade
			SaveActionResultToLog IPK auxiliary upgrade "$total_count" failed "$z"
		fi

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	FuncExit $z

	}

IPKs:install()
	{

	# Install IPKs required to support QPKGs.

	# Inputs: (global)
	#	$r_essential_ipks
	#	$r_install_log_file
	#	$r_ipk_cache_path
	#	$r_ipk_download_path
	#	$r_logs_path
	#	$r_prev_ipk_list_pathfile
	#	$r_qpkg_name[]
	#	$useropt_check
	#	$useropt_terse
	#	$useropt_verbose

	# Outputs: (global)
	#	$useropt_terse
	#	$useropt_verbose

	[[ $ipks_install = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	ErrorIsNt || return

	FuncInit

	local desc=''
	local fork_pid=''
	local -i i=0
	local previous=''
	local -i total_count=0
	local -i z=0

	IPKs-ACinstall-to:Init
	IPKs-ACdownload-to:Init

	if QPKGs-ACinstall-ok.Exist Entware || ([[ $useropt_check = true ]] && QpkgIsInstalled Entware); then
		IPKs-ACinstall-to:Add "$r_essential_ipks"

		if [[ -e $r_prev_ipk_list_pathfile && $useropt_check = false ]]; then		# Don't load previous IPK list during 'check'.
			LoadIpkList
			mv -f "$r_prev_ipk_list_pathfile" "$r_prev_ipk_list_pathfile.installing"
		fi
	fi

	if QPKGs.ACinstall.GRall.IsSet; then
		for qpkg_name in "${r_qpkg_name[@]}"; do
			[[ $previous = "$qpkg_name" ]] && continue || previous=$qpkg_name
			QpkgSetIndex
			IPKs-ACinstall-to:Add "$(QpkgGetDatabaseIPKs)"
		done
	else
		for qpkg_name in "${r_qpkg_name[@]}"; do
			[[ $previous = "$qpkg_name" ]] && continue || previous=$qpkg_name

			if QPKGs-ACinstall-to.Exist "$qpkg_name" || QPKGs-ISinstalled.Exist "$qpkg_name" || (QPKGs-ACreinstall-to.Exist "$qpkg_name" && QPKGs-ISinstalled.Exist "$qpkg_name"); then
				QpkgSetIndex
				IPKs-ACinstall-to:Add "$(QpkgGetDatabaseIPKs)"
			fi
		done
	fi

	CalcIpkDepsToInstall
	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		desc="$total_count auxiliary IPK$(Pluralise "$total_count")"

		ShowAsProc "install $desc"

		_DirSizeMonitor_ "$r_ipk_download_path" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD install --force-overwrite $(IPKs-ACdownload-to:List) --cache $r_ipk_cache_path --tmp-dir $r_ipk_download_path" "$r_logs_path/ipks.$r_install_log_file" log:failure-only
		z=$?

		KillPID "$fork_pid"

		if [[ $z -eq 0 ]]; then
			NoteIpkAcAsOk "$(IPKs-ACdownload-to:Array)" install
			DebugAsDone "installed $desc"
			SaveActionResultToLog IPK auxiliary install "$total_count" ok
			HideKeystrokes
			UpdateCapabilities

			rm -f "$r_prev_ipk_list_pathfile.installing" 2> /dev/null
		else
			NoteIpkAcAsEr "$(IPKs-ACdownload-to:Array)" install
			SaveActionResultToLog IPK auxiliary install "$total_count" failed "$z"

			if [[ -e $r_prev_ipk_list_pathfile.installing ]]; then
				mv -f "$r_prev_ipk_list_pathfile.installing" "$r_prev_ipk_list_pathfile"
			fi
		fi

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	FuncExit $z

	}

IPKs:downgrade()
	{

	# Downgrade specific installed IPKs.

	[[ $ipks_downgrade = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	ErrorIsNt || return

	FuncInit

	local desc=''
	local -i fail_count=0
	local log_pathfile=''
	local name=''
	local -i ok_count=0
	local package_type=''
	local remote_url=''
	local -i total_count=0
	local url_prefix=''
	local url_suffix=''
	local -i z=0

	IPKs-ACdownload-to:Init
	total_count=$(IPKs-ACdowngrade-to:Count)

	if [[ $total_count -gt 0 ]]; then
		package_type=IPK
		desc="$total_count ${package_type}$(Pluralise "$total_count")"
		log_pathfile=$r_logs_path/ipks.$r_download_log_file

		ShowAsProc "download $desc"

		case $r_nas_qpkg_arch in
			a41)
				if OsIsNonStdKernelPageSize; then
					url_prefix=http://bin.entware.net/armv7sf-k3.2/archive/
					url_suffix=_2.38-1_armv7-3.2.ipk

					for name in $(IPKs-ACdowngrade-to:Array); do
						ShowAsPercentProgress "download $desc" '' "$ok_count" 0 0 "$total_count"
						((ok_count++))

						remote_url=${url_prefix}${name}${url_suffix}
						local_pathfile=$r_ipk_downgrade_path/$($BASENAME_CMD "$remote_url")
						RunAndLog "$CURL_CMD --location --output $local_pathfile $remote_url" "$log_pathfile" log:failure-only
					done

					ShowAsPercentProgress "download $desc" '' "$ok_count" 0 "$fail_count" "$total_count"
				fi

				url_prefix=http://bin.entware.net/armv7sf-k3.2/archive/
				url_suffix=_2.39.2-1_armv7-3.2.ipk

				for name in $(IPKs-ACdowngrade-to:Array); do
					ShowAsPercentProgress "download $desc" '' "$ok_count" 0 0 "$total_count"
					((ok_count++))

					remote_url=${url_prefix}${name}${url_suffix}
					local_pathfile=$r_ipk_downgrade_path/$($BASENAME_CMD "$remote_url")
					RunAndLog "$CURL_CMD --location --output $local_pathfile $remote_url" "$log_pathfile" log:failure-only
				done

				ShowAsPercentProgress "download $desc" '' "$ok_count" 0 "$fail_count" "$total_count"
		esac

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo

		total_count=1
		ok_count=0
		fail_count=0
		desc="$total_count auxiliary ${package_type}$(Pluralise "$total_count")"
		log_pathfile=$r_logs_path/ipks.$r_downgrade_log_file

		ShowAsProc "downgrade $desc"

		ShowAsPercentProgress "downgrade $desc" '' "$ok_count" 0 "$fail_count" "$total_count"
		RunAndLog "$OPKG_CMD install --force-downgrade --cache $r_ipk_cache_path --tmp-dir $r_ipk_downgrade_path $r_ipk_downgrade_path/*.ipk" "$log_pathfile" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			((ok_count++))
			NoteIpkAcAsOk "$(IPKs-ACdowngrade-to:Array)" downgrade
			DebugAsDone "downgraded $desc"
			SaveActionResultToLog IPK auxiliary downgrade "$ok_count" ok
		else
			((fail_count++))
			NoteIpkAcAsEr "$(IPKs-ACdowngrade-to:Array)" downgrade
			SaveActionResultToLog IPK auxiliary downgrade "$fail_count" failed "$z"
		fi

		ShowAsPercentProgress "downgrade $desc" '' "$ok_count" 0 "$fail_count" "$total_count"

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	FuncExit $z

	}

IPKs:uninstall()
	{

	:	# Placeholder function.

	}

PIPs:upgrade()
	{

	:	# Placeholder function.

	}

PIPs:install()
	{

	[[ $pips_install = true ]] || return
	QPKGs-ISenabled.Exist Entware || return
	$OPKG_CMD status python3-pip | $GREP_CMD -q "Status:.*installed" || return
	ErrorIsNt || return

	FuncInit

	local desc=''
	local exec_cmd=''
	local -i fail_count=0
	local log_pathfile=$r_logs_path/pips.$r_install_log_file
	local -i ok_count=0
	local package_type=PIP
	local -i total_count=0
	local -i z=0

	if [[ $useropt_check = true ]] || IPKs-ACinstall-ok.Exist python3-pip; then
		PIPs-ACinstall-to:Add "$r_essential_pips"

		if [[ -e $r_prev_pip_list_pathfile && $useropt_check = false ]]; then		# Don't load previous PIP list during 'check'.
			LoadPipList
			mv -f "$r_prev_pip_list_pathfile" "$r_prev_pip_list_pathfile.installing"
		fi

		((total_count++))

		exec_cmd="$PIP_CMD install --upgrade --no-input $(PIPs-ACinstall-to:List) --cache-dir $r_pip_cache_path --root-user-action=ignore"
		desc="$total_count auxiliary PIP$(Pluralise "$total_count")"

		ShowAsPercentProgress "install $desc" '' "$ok_count" 0 0 "$total_count"
		RunAndLog "$exec_cmd" "$log_pathfile" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			((ok_count++))
			DebugAsDone "installed $desc"
			SaveActionResultToLog PIP auxiliary install "$ok_count" ok

			rm -f "$r_prev_pip_list_pathfile.installing" 2> /dev/null
		else
			((fail_count++))
			SaveActionResultToLog PIP auxiliary install "$fail_count" failed "$z"

			if [[ -e $r_prev_pip_list_pathfile.installing ]]; then
				mv -f "$r_prev_pip_list_pathfile.installing" "$r_prev_pip_list_pathfile"
			fi
		fi

		ShowAsPercentProgress "install $desc" '' "$ok_count" 0 "$fail_count" "$total_count"

		[[ ${useropt_terse:=true} = false && ${useropt_verbose:=false} = false ]] && echo
	fi

	FuncExit $z

	}

PIPs:uninstall()
	{

	:	# Placeholder function.

	}

OpenIpkArchive()
	{

	# Unpack the package list file used by `opkg`.

	# Outputs: (local)
	#   $? = 0 if successful, 1 if failed

	if [[ ! -e $r_external_packages_archive_pathfile ]]; then
		ShowAsError 'unable to locate the IPK list file'

		return 1
	fi

	RunAndLog "/usr/local/sbin/7z e -o$($DIRNAME_CMD "$r_external_packages_pathfile") $r_external_packages_archive_pathfile" "$r_cache_path/ipk.archive.extract" log:failure-only

	if [[ ! -e $r_external_packages_pathfile ]]; then
		ShowAsError 'unable to open the IPK list file'

		return 1
	fi

	return 0

	}

CloseIpkArchive()
	{

	rm -f "$r_external_packages_pathfile" 2> /dev/null

	}

_ExecOneActionWithManyForks_()
	{

	# Execute actions concurrently, but only as many as $max_forks will allow given the circumstances.

	# * This function runs as an asynchronous process *

	# Inputs: (local)
	#   $1 = the target function action to be applied to each QPKG in $target_packages()
	#   $2 = an array of QPKG names to process with $1

	# Inputs: (global)
	#   $fork_count
	#   $max_forks
	#   $pidfile

	FuncForkInit

	local a=${1:-function null}

	shift   											# `shift` all arguments one position to the left.
	local -a c=("$@")
	fork_id=0

	# Launching loop.

	for qpkg_name in "${c[@]}"; do
		[[ ! -e $r_action_abort_pathfile ]] || break

		while [[ $fork_count -ge $max_forks ]]; do  	# Don't fork until an empty spot becomes available.
			[[ ! -e $r_action_abort_pathfile ]] || break 2
			sleep .2
			UpdateForkProgress
		done

		IncForkProgressIndex
		MarkThisAcForkAsStarted 						# Must create runfile here, as it takes too-long to happen in async function.
		QpkgSetIndex

		action_pidfile=$($MKTEMP_CMD "$r_async_procs_path"/bgproc_XXXXXX)		# Set $action_pidfile here, before launching async process so it's inherited by that process.

		$a &

		echo "$!" > "$action_pidfile"

		DebugAsDone "forked $a() instance for '$qpkg_name'"
		UpdateForkProgress
	done

	# Monitoring loop.
	# All action forks have launched, now wait for them to exit.

	while [[ $fork_count -gt 0 ]]; do
		[[ ! -e $r_action_abort_pathfile ]] || break
		sleep .2
		UpdateForkProgress								# Update display while running forks complete their tasks.
	done

	# All action forks have exited.

	FuncForkExit

	}

_DirSizeMonitor_()
	{

	# * This function runs asynchronously *

	# Inputs: (local)
	#   $1 = directory to monitor the size-of.
	#   $2 = total target bytes (100%) for specified path.

	# Inputs: (global)
	#   $r_display_inhibit_pathfile

	# Outputs: (local)
	#   stdout = formatted as: "percentage downloaded (downloaded bytes/total expected bytes)".

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined path} ]] || exit
	[[ -d $1 && ${2:-0} -gt 0 ]] || exit
	IsSysFileExist $GNU_FIND_CMD || exit

	local -i current_bytes=-1
	local -i last_bytes=0
	local perc_msg=''
	local progress_msg=''
	local stall_msg=''
	local -i stall_seconds=0
	local -i stall_seconds_threshold=4
	local -i total_bytes=${2:-0}

	InitProgress

	while [[ $current_bytes -lt $total_bytes ]]; do
		current_bytes=$($GNU_FIND_CMD "$1" -type f -name '*.ipk' -exec $DU_CMD --bytes --total --apparent-size {} + 2> /dev/null | $GREP_CMD total$ | cut -f1)
		[[ -z $current_bytes ]] && current_bytes=0

		if [[ $current_bytes -ne $last_bytes ]]; then
			stall_seconds=0
			last_bytes=$current_bytes
		else
			((stall_seconds++))
		fi

		perc_msg="$((200*(current_bytes)/(total_bytes)%2+100*(current_bytes)/(total_bytes)))%"
		[[ $current_bytes -lt $total_bytes && $perc_msg = '100%' ]] && perc_msg='99%'	# ensure we don't hit 100% until the last byte is downloaded
		progress_msg="$perc_msg ($(TextBrightWhite "$(FormatAsIsoBytes "$current_bytes")")/$(TextBrightWhite "$(FormatAsIsoBytes "$total_bytes")"))"

		if [[ $stall_seconds -ge $stall_seconds_threshold ]]; then
			# Append a message showing stalled time.
			stall_msg=' stalled for '

			if [[ $stall_seconds -lt 60 ]]; then
				stall_msg+="$stall_seconds seconds"
			else
				stall_msg+=$(ConvertSecondsToDuration "$stall_seconds")
			fi

			# Add a suggestion to cancel if download has stalled for too-long.

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg+=': cancel with CTRL+C and try again later'
			fi

			# Colourise as-required.

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg=$(TextBrightRed "$stall_msg")
			elif [[ $stall_seconds -ge 45 ]]; then
				stall_msg=$(TextBrightOrange "$stall_msg")
			elif [[ $stall_seconds -ge 20 ]]; then
				stall_msg=$(TextBrightYellow "$stall_msg")
			fi

			progress_msg+=$stall_msg
		fi

		[[ ! -e $r_display_inhibit_pathfile ]] || return
		WriteMsgInPlace "$progress_msg"
		sleep 1
	done

	[[ -n $progress_msg ]] && WriteMsgInPlace 'done!'

	}

WriteMsgInPlace()
	{

	# Inputs: (local)
	#   $1 = message to display.

	# Outputs: (local)
	#   stdout = $1 but with all whitespace squeezed.

	# Outputs: (global)
	#   $prev_clean_msg = the message provided in $1, but with all whitespace squeezed, and ANSI codes removed.

	local -i a=0		# Blanking length
	local b=$(tr -s ' ' <<< "${1:-}")
	local c=$(StripANSICodes "$b")

	if [[ $c != "$prev_clean_msg" ]]; then
		if [[ ${#c} -lt ${#prev_clean_msg} ]]; then
			a=$((${#c}-${#prev_clean_msg}))

			# Backspace to start of previous msg, print new msg, add additional spaces, then backspace to end of new msg.
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$b"; printf "%${a}s"; printf "%${a}s" | tr ' ' '\b'
		else
			# Backspace to start of previous msg, print new msg.
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$b"
		fi

		prev_clean_msg=$c
	fi

	}

KillPID()
	{

	# Inputs: (local)
	#   $1 = PID to kill.

	[[ -n ${1:-} && $1 -gt 0 && -d /proc/$1 ]] || return

	kill -9 "$1"
	wait

	} &> /dev/null

Reset()
	{

	ResetCachePath
	ResetReportsPath
	ResetArchivedLogs
	ArchiveActiveSessLog
	ResetActiveSessLog

	exit 0

	}

UpdateColourful()
	{

	# Inputs: (local)
	# 	$1 = 'silent' (optional): don't announce setting was saved.

	# Inputs: (global)
	#	$switch_colour
	#	$user_colourful_value
	#	$useropt_colourful

	# Outputs: (global)
	#	$run_package_actions
	#	$switch_colour
	#	$useropt_colourful

	local a=''

	if [[ $switch_colour = true && -n $user_colourful_value ]]; then
		# Validate before saving.

		for a in true false; do
			[[ $a != "$user_colourful_value" ]] && continue
			useropt_colourful=$user_colourful_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Colourful "$useropt_colourful"
			else
				SaveSetting Colourful "$useropt_colourful" announce
			fi

			switch_colour=false

			return
		done

		ShowAsAbort "user setting '$user_colourful_value' is not 'true' or 'false'"
		run_package_actions=false

		return 1
	fi

	}

UpdateBranch()
	{

	# Inputs: (local)
	# 	$1 = 'silent' (optional): don't announce setting was saved.

	# Inputs: (global)
	#	$switch_branch
	#	$user_branch_value
	#	$useropt_branch

	# Outputs: (global)
	#	$run_package_actions
	#	$switch_branch
	#	$useropt_branch

	local a=''

	if [[ $switch_branch = true && -n $user_branch_value ]]; then
		# Validate before saving.

		for a in unstable stable; do
			[[ $a != "$user_branch_value" ]] && continue
			useropt_branch=$user_branch_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Git_Branch "$useropt_branch"
			else
				SaveSetting Git_Branch "$useropt_branch" announce

				Reset					# <-- Processing will terminate in this function (no-return).
			fi

			switch_branch=false

			return
		done

		ShowAsAbort "user setting '$user_branch_value' is not 'unstable' or 'stable'"
		run_package_actions=false

		return 1
	fi

	}

UpdateReportFooter()
	{

	# Inputs: (local)
	# 	$1 = 'silent' (optional): don't announce setting was saved.

	# Inputs: (global)
	#	$switch_terse
	#	$user_report_footer_value
	#	$useropt_report_footer

	# Outputs: (global)
	#	$run_package_actions
	#	$switch_report_footer
	#	$useropt_report_footer

	local a=''

	if [[ $switch_report_footer = true && -n $user_report_footer_value ]]; then
		# Validate before saving.

		for a in true false; do
			[[ $a != "$user_report_footer_value" ]] && continue
			useropt_report_footer=$user_report_footer_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting ReportFooter "$useropt_report_footer"
			else
				SaveSetting ReportFooter "$useropt_report_footer" announce
			fi

			switch_report_footer=false

			return
		done

		ShowAsAbort "user setting '$user_report_footer_value' is not 'true' or 'false'"
		run_package_actions=false

		return 1
	fi

	}

UpdateTerse()
	{

	# Inputs: (local)
	# 	$1 = 'silent' (optional): don't announce setting was saved.

	# Inputs: (global)
	#	$switch_terse
	#	$user_terse_value
	#	$useropt_terse

	# Outputs: (global)
	#	$run_package_actions
	#	$switch_terse
	#	$useropt_terse

	local a=''

	if [[ $switch_terse = true && -n $user_terse_value ]]; then
		# Validate before saving.

		for a in true false; do
			[[ $a != "$user_terse_value" ]] && continue
			useropt_terse=$user_terse_value

			if [[ ${1:-} = silent ]]; then
				SaveSetting Terse "$useropt_terse"
			else
				SaveSetting Terse "$useropt_terse" announce
			fi

			switch_terse=false

			return
		done

		ShowAsAbort "user setting '$user_terse_value' is not 'true' or 'false'"
		run_package_actions=false

		return 1
	fi

	}

SaveSetting()
	{

	# Save a setting named as $1 with a value of $2 to persistent storage: /etc/config/qpkg.conf

	# Inputs: (local)
	#   $1 = name
	# 	$2 = value
	# 	$3 = 'announce' (optional): display on-screen when setting has been saved.

	local a=${1:?${FUNCNAME[0]}'()': undefined name}
	local b=$(Lowercase "${2:?${FUNCNAME[0]}'()': undefined value}")

	case $b in
		true|false)
			b=$(Uppercase "$b")		# Convert these to uppercase to match QNAP-convention.
	esac

	/sbin/setcfg sherpa "$a" "$b" -f /etc/config/qpkg.conf

	[[ ${3:-} = announce ]] && ShowAsDone "user setting '$a = $b' has been saved"

	}

LoadSetting()
	{

	# Load a setting named as $1 with a default value of $2 from persistent storage: /etc/config/qpkg.conf

	# Inputs: (local)
	#   $1 = setting name
	# 	$2 = default value

	# Outputs: (local)
	#   stdout = setting value

	local a=${1:?${FUNCNAME[0]}'()': undefined name}
	local b=$(Lowercase "${2:?${FUNCNAME[0]}'()': undefined default value}")

	Lowercase "$(/sbin/getcfg sherpa "$a" -d "$b" -f /etc/config/qpkg.conf)"

	}

DeleteSetting()
	{

	# Remove a setting named as $1 from persistent storage: /etc/config/qpkg.conf

	# Inputs: (local)
	#   $1 = name

	local a=${1:?${FUNCNAME[0]}'()': undefined name}

	/sbin/setcfg -e sherpa "$a" -f /etc/config/qpkg.conf

	}

UserIsOk()
	{

	if ! UserIsSU; then
		if OsIsSupportSudo; then
			ShowAsError 'this utility must be run with superuser privileges. Try again as:'
			echo "${r_chars_sudo_prompt}sherpa $r_args_raw" >&2
		else
			ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
		fi

		return 1
	fi

	return 0

	}

UserIsSU()
	{

	[[ $EUID -eq 0 ]]

	}

#DebugBinPathVerAndMinVer()
# 	{
#
# 	# Inputs:
# 	#	$1 = binary filename
# 	#	$2 = current version found
# 	#	$3 = minimum version required
#
# 	[[ -n ${1:?${FUNCNAME[0]}'()': undefined filename} ]] || return
#
# 	local a=$(GetThisBinPath "$1")
#
# 	if [[ -n $a ]]; then
# 		DebugUserspace ok "'$1' path" "$a"
# 	else
# 		DebugUserspace warning "'$1' path" 'not present'
# 	fi
#
# 	if [[ -n ${2:-} && ${2:-undefined} != undefined ]]; then
# 		[[ -n ${3:-} && ${3:-undefined} != undefined ]] || return
#
# 		if [[ ${2//./} -ge ${3//./} ]]; then
# 			DebugUserspace ok "'$1' version" "$2"
# 		else
# 			DebugUserspace warning "'$1' version" "$2"
# 		fi
# 	else
# 		DebugUserspace warning "'$1' version" 'undefined'
# 	fi
#
# 	return 0
#
# 	}

IsSysFileExist()
	{

	# Inputs: (local)
	#   $1 = pathfile to check

	# Outputs: (local)
	#   $? = 0 (exists) or 1 (not exists)

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined pathfile} ]] || exit

	local a=${1%% *}		# Extract first word-group.

	if ! [[ -f $a || -L $a ]]; then
		ShowAsAbort "a required NAS system file $(ShowAsFileName "$a") is missing"

		return 1
	fi

	return 0

	}

IsNtSysFileExist()
	{

	# Inputs: (local)
	#   $1 = pathfile to check

	# Outputs: (local)
	#   $? = 0 (not exists) or 1 (exists)

	! IsSysFileExist "${1:?${FUNCNAME[0]}'()': undefined pathfile}"

	}

LenANSIDiff()
	{

	# Inputs: (local)
	#   $1 = (optional) text to find length-of.

	local a=${1:-}
	local b=$(StripANSICodes "$a")

	printf '%s' "$((${#a}-${#b}))"

	return 0

	}

AddSeparators()
	{

	# Inputs: (local)
	# 	$1 = list of abbreviations to format with commas.

	# Outputs: (local)
	# 	stdout = $1 formatted with commas.

	[[ -z ${1:-} ]] && return

	local a=''

	a=$(Trim "$1")
	a=${a// /, }	# Replace whitespace with separators.
	a=${a//!/ }		# Convert '!' to whitespace.

	printf '%s' "$a"

	}

DisplayAsProjSynExam()
	{

	# Display as project syntax example.

	# Inputs: (local)
	#	$1 = description
	#	$2 = example syntax

	# Inputs: (global)
	#	$r_chars_bullet
	#	$r_help_syntax_indent
	#	$r_help_syntax_sudo_prefix

	# Outputs: (local)
	# 	stdout = $1 & $2 formatted.

	printf "\n${r_chars_bullet}%s" "$(Capitalise "${1:-}")"
	[[ ${1: -1} != '!' ]] && printf ':'

	printf "\n%${r_help_syntax_indent}s${r_help_syntax_sudo_prefix}sherpa %s\n" '' "${2:-}"

	}

DisplayAsProjSynIndentExam()
	{

	# Display as project syntax indented example.

	# Inputs: (local)
	#	$1 = description (optional)
	#	$2 = example syntax

	if [[ -n $1	]]; then
		printf "\n%${r_help_desc_indent}s%s" '' "$(Capitalise "${1:-}")"
		[[ ${1: -1} != '!' ]] && printf ':'
		printf '\n'
	fi

	printf "%${r_help_syntax_indent}s${r_help_syntax_sudo_prefix}sherpa %s\n" '' "${2:-}"

	}

DisplayAsSynExam()
	{

	# Display as syntax example.

	# Inputs: (local)
	#	$1 = description
	#	$2 = example syntax

	printf "\n${r_chars_bullet}%s:\n%${r_help_syntax_indent}s${r_help_syntax_prefix}%s\n" "$(Capitalise "${1:-}")" '' "${2:-}"

	}

DisplayAsIndentItem()
	{

	# Display as indented single field, bulleted.

	# Inputs: (local)
	#	$1 = item

	printf "%${r_help_desc_indent}s${r_chars_bullet}%s\n" '' "$(Capitalise "${1:-}")"

	}

DisplayAsIndentQuotedInfoItem()
	{

	# Display as indented two fields, first field quoted, second field hyphenated.

	# Example:
	# "  'inactive'     - application is dead or not-started. Try starting/activating it."

	# Inputs: (local)
	#	$1 = word
	#	$2 = description

	if OsIsSupportAutowidthTableColumns; then
		printf "%${r_help_desc_indent}s%s|%s\n" '' "'${1:-}'" "- $(AddPeriod "${2:-}")"
	else
		printf "%${r_help_desc_indent}s%-$((r_report_footer_name_column_width+2+$(LenANSIDiff "${1:-}")))s%s\n" '' "'${1:-}'" "- $(AddPeriod "${2:-}")"
	fi

	}

GeneratePacksReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a='QPKG name:'
	printf "%-$((r_report_qpkg_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: application version
	a='Appl. version:'
	printf "%-$((r_report_qpkg_appl_version_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: package description
	a='Description:'
	printf "%-$((r_report_qpkg_description_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GeneratePacksReportDataLine()
	{

	# Input (local):
	#   $1 = QPKG name (optional).

	# Inputs: (global)
	# 	$qpkg_name

	local app_ver=''
	local app_ver_msg=$r_chars_blank
# 	local author=$(QpkgGetDatabaseAuthor)
# 	local author_msg=$r_chars_blank
	local description_msg=$r_chars_blank
	local mode=''
	local name=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
		local description=$(QpkgGetDatabaseDesc "$name")
		local notes=$(QpkgGetDatabaseNote "$name")
		[[ $notes = none ]] && notes=''
	local name_msg=$r_chars_normal
	local notes_msg="${notes}."

	if QpkgIsInstalledMissing; then
		mode=highlight
		/bin/touch "$r_report_flags_path"/status-missing
	elif QpkgIsNtInstalled; then
		mode=mute
		/bin/touch "$r_report_flags_path"/state-notinstalled
	else
		mode=normal
		/bin/touch "$r_report_flags_path"/state-installed
	fi

	app_ver=$(QpkgGetDatabaseApplVer)

	case $app_ver in
		dynamic|final|static)
			/bin/touch "$r_report_flags_path"/app-$app_ver
	esac

	app_ver_msg+=$app_ver
# 	author_msg+=$author
	description_msg+="$(Capitalise "$description")."
	name_msg+=$qpkg_name

	case $mode in
		mute)
			app_ver_msg=$(TextDarkGrey "$app_ver_msg")
# 			author_msg=$(TextDarkGrey "$author_msg")
			description_msg=$(TextDarkGrey "$description_msg")
			name_msg=$(TextDarkGrey "$name_msg")
			;;
		highlight)
# 			[[ $author = missing ]] && author_msg=$(TextBrightRedBlink "${r_chars_alert}${author}")
			name_msg=$(TextBrightRed "$name_msg")
	esac

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$app_ver_msg|$description_msg"

		if [[ -n $notes ]]; then
			printf "%s|%s|%$((${#r_chars_blank}))s%s\n" '' '' '' "$(TextBrightOrange "${r_chars_dropend}${r_chars_note}") $notes_msg"
		fi
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: application version
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_appl_version_column_width+$(LenANSIDiff "$app_ver_msg")))s" "$app_ver_msg"

		# column 3: package description
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_description_column_width+$(LenANSIDiff "$description_msg")))s" "$description_msg"

		if [[ -n $notes ]]; then
			printf "\n%$((${#r_chars_blank}+r_report_qpkg_name_column_width+r_report_qpkg_appl_version_column_width+(r_report_column_spacing*2)))s$(TextBrightOrange "${r_chars_dropend}${r_chars_note}")%s" '' "$notes_msg"
		fi

		printf '\n'
	fi

	}

GenerateStatusReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a='QPKG name'
	printf "%-${r_report_qpkg_name_column_width}s" "$a:"

	# column 2: package statuses
	printf "%$((r_report_column_spacing))s"
	a='Status'
	printf "%-${r_report_qpkg_status_column_width}s" "$a:"

	# column 3: package action and result
	printf "%$((r_report_column_spacing))s"
	a='Previous action (result)'
	printf "%-${r_report_qpkg_action_column_width}s" "$a:"

	# column 4: package version
	printf "%$((r_report_column_spacing))s"
	a='QPKG version'
	QPKGs-ISupgradable.IsAny && a+=" ($(TextBrightOrange new))"
	printf "%-${r_report_qpkg_version_column_width}s" "$a:"

	# column 5: application version
	printf "%$((r_report_column_spacing))s"
	a='Appl. version'
	printf "%-${r_report_qpkg_appl_version_column_width}s" "$a:"

	# column 6: package installation path
	printf "%$((r_report_column_spacing))s"
	a='Location'
	printf "%-${r_report_qpkg_path_column_width}s" "$a:"

	printf '\n'

	}

GenerateStatusReportDataLine()
	{

	# * This function runs asynchronously *

	# Inputs: (global)
	# 	$qpkg_name

	local action=''
	local action_msg=$r_chars_blank
	local app_ver=$(QpkgGetDatabaseApplVer)
	local app_ver_msg=$r_chars_blank
	local mode=''
	local -i n=0
	local name_msg=$r_chars_blank
	local path=$(QpkgGetInstalledPath)
	local path_msg=$r_chars_blank
	local result=''
	local status=''
	local status_msg=$r_chars_normal
	local ver=$(QpkgGetInstalledVer)
	local ver_msg=$r_chars_blank

	if QpkgIsInstalledMissing; then
		mode=missing
	elif QpkgIsInstalled; then
		mode=normal
	else
		mode=mute
		QpkgIsReallyInstalled && QpkgIsNtInstalledAuthorOk && mode=author
	fi

	case $app_ver in
		dynamic|final|static)
			/bin/touch "$r_report_flags_path"/app-$app_ver
	esac

	case $mode in
		missing|normal)
			if QpkgIsDatabaseSherpaCompatible; then
				action=$(QpkgGetInstalledServiceAction)
				/bin/touch "$r_report_flags_path"/action-$action

				if [[ $action = not-found ]]; then
					if OsIsStarting && QpkgIsInstalledEnabled; then
						action_msg+=$(TextBrightOrange pending)
						/bin/touch "$r_report_flags_path"/action-pending
					else
						action_msg+=$(TextDarkGrey not-found)
					fi
				else
					action_msg+=$action
				fi

				result=$(QpkgGetInstalledServiceResult)
				/bin/touch "$r_report_flags_path"/result-$result

				case $result in
					aborted|failed)
						action_msg+=" ($(TextBrightRed "$result"))"
						;;
					in-progress)
						action_msg+=" ($(TextBrightOrange "$result"))"
						;;
					ok)
						action_msg+=" ($(TextBrightGreen "$(Uppercase "$result")"))"
				esac
			else
				action=unsupported
				/bin/touch "$r_report_flags_path"/action-unsupported

				action_msg+=$(TextDarkGrey "$action")
			fi
			;;
		*)
			action=N/A
			/bin/touch "$r_report_flags_path"/na
	esac

	case $mode in
		author)
			/bin/touch "$r_report_flags_path"/status-wrongauthor
			/bin/touch "$r_report_flags_path"/na

			# Set field values.
			app_ver=N/A
			status='incompatible author'
			ver=N/A

			# Assign field messages.
			action_msg+=$action
			app_ver_msg+=$app_ver
			name_msg+=$qpkg_name
			path_msg+=$path
			status_msg=${r_chars_attention}${status}
			ver_msg+=$ver

			# Highlight field messages.
			action_msg=$(TextBrightOrange "$action_msg")
			app_ver_msg=$(TextBrightOrange "$app_ver_msg")
			name_msg=$(TextBrightOrange "$name_msg")
			path_msg=$(TextBrightOrange "$path_msg")
			status_msg=$(TextBrightOrange "$status_msg")
			ver_msg=$(TextBrightOrange "$ver_msg")
			;;
		missing)
			/bin/touch "$r_report_flags_path"/status-missing

			# Set field values.
			status=missing

			# Assign field messages.
			app_ver_msg+=$app_ver
			name_msg+=$qpkg_name
			path_msg+=$path
			status_msg=${r_chars_alert}${status}
			ver_msg+=$ver

			# Highlight field messages.
			app_ver_msg=$(TextBrightRed "$app_ver_msg")
			name_msg=$(TextBrightRed "$name_msg")
			path_msg=$(TextBrightRedBlink "$path_msg")
			status_msg=$(TextBrightRedBlink "$status_msg")
			ver_msg=$(TextBrightRed "$ver_msg")
			;;
		mute)
			/bin/touch "$r_report_flags_path"/state-notinstalled
			/bin/touch "$r_report_flags_path"/na

			# Set field values.
			path=N/A

			if ! QpkgIsDatabaseArchOK; then
				status+='incompatible architecture'
			elif ! QpkgIsDatabaseMinOSVerOk || ! QpkgIsDatabaseMaxOSVerOk; then
				status+="incompatible $(OsGetQnapOS)"
			elif ! QpkgIsDatabaseMinRAMOk; then
				status+='insufficient RAM installed'
			else
				status+='not installed'
			fi

			ver=$(QpkgGetDatabaseVer "$qpkg_name")

			# Assign field messages.
			action_msg+=$action
			app_ver_msg+=$app_ver
			name_msg+=$qpkg_name
			path_msg+=$path
			status_msg+=$status
			ver_msg+=$ver

			# Highlight field messages.
			action_msg=$(TextDarkGrey "$action_msg")
			app_ver_msg=$(TextDarkGrey "$app_ver_msg")
			name_msg=$(TextDarkGrey "$name_msg")
			path_msg=$(TextDarkGrey "$path_msg")
			status_msg=$(TextDarkGrey "$status_msg")
			ver_msg=$(TextDarkGrey "$ver_msg")
			;;
		normal)
			/bin/touch "$r_report_flags_path"/state-installed

			# Set field values.

			# Assign highlighting earlier than-usual as each status can have a different highlight.

			if QPKGs-ISenabled.Exist "$qpkg_name"; then
				status+=" $(TextBrightGreen enabled)"
				/bin/touch "$r_report_flags_path"/state-enabled
			else
				status+=" $(TextBrightRed disabled)"
				/bin/touch "$r_report_flags_path"/state-disabled
			fi

			if QPKGs-ISactive.Exist "$qpkg_name"; then
				status+=" $(TextBrightGreen active)"
				/bin/touch "$r_report_flags_path"/status-active
			elif QPKGs-ISslow.Exist "$qpkg_name"; then
				status+=" $(TextBrightOrange slow)"
				/bin/touch "$r_report_flags_path"/status-slow
			elif QPKGs-ISNTactive.Exist "$qpkg_name"; then
				status+=" $(TextBrightRed inactive)"
				/bin/touch "$r_report_flags_path"/status-inactive
			else
				status+=" $(TextBrightOrange unknown)"
				/bin/touch "$r_report_flags_path"/status-unknown
			fi

			# Assign field messages.
			app_ver_msg+=$app_ver
			name_msg+=$qpkg_name
			path_msg+=$path
			status_msg+=$(AddSeparators "$status")
			ver_msg+=$ver
	esac

	if QPKGs-ISupgradable.Exist "$qpkg_name"; then
		ver_msg+=" ($(TextBrightOrange "$(QpkgGetDatabaseVer)"))"
		/bin/touch "$r_report_flags_path"/status-upgradable
	fi

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$status_msg|$action_msg|$ver_msg|$app_ver_msg|$path_msg"
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: package statuses
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$status_msg")))s" "$status_msg"

		# column 3: package action and result
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$action_msg")))s" "$action_msg"

		# column 4: package version
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$ver_msg")))s" "$ver_msg"

		# column 5: application version
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$app_ver_msg")))s" "$app_ver_msg"

		# column 6: package installation path
	 	printf "%$((r_report_column_spacing))s"
	 	printf "%-$((r_report_qpkg_path_column_width+$(LenANSIDiff "$path_msg")))s" "$path_msg"

	 	printf '\n'
	fi

	}

GenerateReposReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a="QPKG name:"
	printf "%-$((r_report_qpkg_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: package repository
	a="Repository:"
	printf "%-$((r_report_qpkg_repo_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: package installation date
	a="Install date:"
	printf "%-$((r_report_qpkg_install_date_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GenerateReposReportDataLine()
	{

	# Inputs: (global)
	# 	$qpkg_name

	# Outputs: (local)
	# 	stdout = single report line with data fields.

	local assigned_repo=''
	local assigned_repo_msg=$r_chars_normal
	local install_date=$(QpkgGetInstalledDate)
	local install_date_msg=$r_chars_blank
	local mode=''
	local name_msg=$r_chars_blank
	local store_id=$(QpkgGetInstalledStoreID)
	[[ $store_id = undefined ]] && store_id=sherpa

	if QpkgIsInstalledMissing; then
		mode=highlight
		/bin/touch "$r_report_flags_path"/status-missing
	elif QpkgIsInstalled; then
		mode=normal
		/bin/touch "$r_report_flags_path"/state-installed
	else
		mode=mute
		/bin/touch "$r_report_flags_path"/state-notinstalled
	fi

	if [[ $store_id = sherpa ]]; then
		assigned_repo=sherpa
		/bin/touch "$r_report_flags_path"/repo-sherpa
	else
		assigned_repo=$(GetRepoURLFromStoreID "$store_id")
	fi

	case $mode in
		highlight)
			install_date=missing

			case $assigned_repo in
				sherpa)
					assigned_repo_msg+=$(TextBrightGreen "$assigned_repo")
					;;
				unassigned)
					assigned_repo_msg+=$(TextBrightOrange "$assigned_repo")
					;;
				*)
					assigned_repo_msg+=$assigned_repo
					/bin/touch "$r_report_flags_path"/repo-other
			esac

			install_date_msg=$(TextBrightRedBlink "${r_chars_alert}${install_date}")
			name_msg=$(TextBrightRed "${name_msg}${qpkg_name}")
			;;
		normal)
			case $assigned_repo in
				sherpa)
					assigned_repo_msg+=$(TextBrightGreen "$assigned_repo")
					name_msg+=$qpkg_name
					;;
				undefined)
					assigned_repo_msg+=N/A
					name_msg+=$qpkg_name
					/bin/touch "$r_report_flags_path"/na
					;;
				*)
					assigned_repo_msg=$(TextBrightOrange "${r_chars_attention}${assigned_repo}")
					name_msg=$(TextBrightOrange "${name_msg}${qpkg_name}")
					/bin/touch "$r_report_flags_path"/repo-other
			esac

			install_date_msg+=$install_date
			;;
		mute)
			assigned_repo=N/A
			/bin/touch "$r_report_flags_path"/na

			if ! QpkgIsDatabaseArchOK; then
				install_date='incompatible architecture'
			elif ! QpkgIsDatabaseMinOSVerOk; then
				install_date="incompatible $(OsGetQnapOS)"
			elif ! QpkgIsDatabaseMinRAMOk; then
				install_date='insufficient RAM installed'
			else
				install_date='not installed'
			fi

			assigned_repo_msg=$(TextDarkGrey "${assigned_repo_msg}${assigned_repo}")
			install_date_msg=$(TextDarkGrey "${install_date_msg}${install_date}")
			name_msg=$(TextDarkGrey "${name_msg}${qpkg_name}")
	esac

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$assigned_repo_msg|$install_date_msg"
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: package repository
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_repo_column_width+$(LenANSIDiff "$assigned_repo_msg")))s" "$assigned_repo_msg"

		# column 3: package installation date
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_install_date_column_width+$(LenANSIDiff "$install_date_msg")))s" "$install_date_msg"

		printf '\n'
	fi

	}

GenerateAbsReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a='QPKG name:'
	printf "%-$((r_report_qpkg_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: QPKG is installed
	a='Installed?'
	printf "%-$((r_report_qpkg_is_installed_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: package abbreviations
	a='Acceptable QPKG name abbreviations and aliases:'
	printf "%-$((r_report_qpkg_abbreviations_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GenerateAbsReportDataLine()
	{

	# * This function runs asynchronously *

	# Inputs: (global)
	# 	$qpkg_name

	local abs_msg=''
	local installed_msg=$r_chars_blank
	local mode=''
	local name_msg=$r_chars_blank

	if QpkgIsInstalledMissing; then
		mode=highlight
		/bin/touch "$r_report_flags_path"/status-missing
	elif QpkgIsNtInstalled; then
		mode=mute
		/bin/touch "$r_report_flags_path"/state-notinstalled
	else
		mode=normal
		/bin/touch "$r_report_flags_path"/state-installed
	fi

	case $mode in
		normal)
			abs_msg=${r_chars_normal}$(AddSeparators "$(QpkgGetDatabaseAbbrvs)")
			installed_msg+=true
			name_msg+=$qpkg_name
			;;
		mute)
			if ! QpkgIsDatabaseArchOK "$qpkg_name"; then
				abs_msg="${r_chars_alert}incompatible architecture"
			elif ! QpkgIsDatabaseMinOSVerOk "$qpkg_name"; then
				abs_msg="${r_chars_alert}incompatible $(OsGetQnapOS) version"
			elif ! QpkgIsDatabaseMinRAMOk "$qpkg_name"; then
				abs_msg="${r_chars_alert}insufficient RAM installed"
			else
				abs_msg=${r_chars_normal}$(AddSeparators "$(QpkgGetDatabaseAbbrvs "$qpkg_name")")
			fi

			abs_msg=$(TextDarkGrey "$abs_msg")
			installed_msg+=$(TextDarkGrey false)
			name_msg+=$(TextDarkGrey "$qpkg_name")
			;;
		highlight)
			abs_msg=$(TextBrightRed "${r_chars_alert}$(AddSeparators "$(QpkgGetDatabaseAbbrvs)")")
			installed_msg=$(TextBrightRedBlink "${r_chars_alert}missing")
			name_msg+=$(TextBrightRed "$qpkg_name")
	esac

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$installed_msg|$abs_msg"
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: package is installed?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_is_installed_column_width+$(LenANSIDiff "$installed_msg")))s" "$installed_msg"

		# column 3: package abbreviations
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_abbreviations_column_width+$(LenANSIDiff "$abs_msg")))s" "$abs_msg"

		printf '\n'
	fi

	}

GenerateDepsReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a='QPKG name:'
	printf "%-$((r_report_qpkg_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: package dependencies.
	a='Dependencies:'
	printf "%-$((r_report_qpkg_dependencies_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: QPKG is installed?
	a='Installed?'
	printf "%-$((r_report_qpkg_is_installed_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 4: QPKG is enabled?
	a='Enabled?'
	printf "%-$((r_report_qpkg_is_enabled_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 5: QPKG is managed by sherpa?
	a='Managed?'
	printf "%-$((r_report_qpkg_is_managed_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 6: minimum NAS RAM required.
	a='Min. RAM:'
	printf "%-$((r_report_qpkg_min_ram_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 7: minimum OS fimware version supported.
	a='Min. OS:'
	printf "%-$((r_report_qpkg_min_os_version_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 8: maximum OS fimware version supported.
	a='Max. OS:'
	printf "%-$((r_report_qpkg_max_os_version_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 9: arch is compatible?
	a='Supported arch?'
	printf "%-$((r_report_qpkg_arch_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 10: installed QPKG author
	a='Installed QPKG author:'
	printf "%-$((r_report_lazy_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GenerateDepsReportDataLine()
	{

	# * This function runs asynchronously *

	# Inputs: (global)
	# 	$qpkg_name

	local author=$(QpkgGetInstalledAuthor)
	local author_ok=false
	local author_msg=$r_chars_blank
	local arch=false
	local arch_msg=$r_chars_blank
	local dep_name=''
	local deps=''
	local deps_msg=$r_chars_normal
	local deps_raw=$(QpkgGetDatabaseDependencies "$qpkg_name")
	local enabled=false
	local enabled_msg=$r_chars_blank
	local installed=false
	local installed_msg=$r_chars_blank
	local managed=false
	local managed_msg=$r_chars_blank
	local max_os=$(QpkgGetDatabaseMaxOSVer "$qpkg_name")
	local max_os_msg=$r_chars_blank
	local max_os_ok=false
	local min_os=$(QpkgGetDatabaseMinOSVer "$qpkg_name")
	local min_os_msg=$r_chars_blank
	local min_os_ok=false
	local min_ram=$(QpkgGetDatabaseMinRAM "$qpkg_name")
	local min_ram_msg=$r_chars_blank
	local min_ram_ok=false
	local mode=''
	local name_msg=$r_chars_blank
	local req_alert=false
	local req_attention=false

	/bin/touch "$r_report_flags_path"/deps

	if QpkgIsInstalledMissing; then
		mode=missing
	elif QpkgIsInstalled; then
		mode=normal
	else
		mode=mute
		QpkgIsReallyInstalled && QpkgIsNtInstalledAuthorOk && mode=author
	fi

	[[ -z $deps_raw ]] && deps_raw=none
	[[ -n $max_os && $max_os != none && ${#max_os} -eq 3 ]] && max_os=${max_os:0:1}.${max_os:1:1}.${max_os:2:1}
	[[ -n $min_os && $min_os != none && ${#min_os} -eq 3 ]] && min_os=${min_os:0:1}.${min_os:1:1}.${min_os:2:1}
	[[ $min_ram != none ]] && min_ram=$(FormatAsThous "$min_ram")kB

	case $mode in
		author)
			/bin/touch "$r_report_flags_path"/status-wrongauthor

			# Set field values.
			arch=N/A
			deps='incompatible author'
			enabled=N/A
			installed=true
			managed=N/A
			max_os=N/A
			min_os=N/A
			min_ram=N/A
			req_attention=true

			# Assign field messages.
			arch_msg+=$arch
			author_msg=${r_chars_attention}${author}
			deps_msg=${r_chars_attention}${deps}
			enabled_msg+=$enabled
			installed_msg+=$installed
			managed_msg+=$managed
			max_os_msg+=$max_os
			min_os_msg+=$min_os
			min_ram_msg+=$min_ram

			# Highlight field messages.
			arch_msg=$(TextBrightOrange "$arch_msg")
			author_msg=$(TextBrightOrange "$author_msg")
			deps_msg=$(TextBrightOrange "$deps_msg")
			enabled_msg=$(TextBrightOrange "$enabled_msg")
			installed_msg=$(TextBrightGreen "$installed_msg")
			managed_msg=$(TextBrightOrange "$managed_msg")
			max_os_msg=$(TextBrightOrange "$max_os_msg")
			min_os_msg=$(TextBrightOrange "$min_os_msg")
			min_ram_msg=$(TextBrightOrange "$min_ram_msg")
			;;
		missing)
			# Set field values.
			QpkgIsDatabaseArchOK && arch=true

			if [[ $deps_raw != none ]]; then
				for dep_name in $deps_raw; do
					[[ -n $deps ]] && deps+=' '

					# Assign highlighting earlier than-usual as each QPKG name can have a different highlight.

					if QpkgIsInstalled "$dep_name" && QpkgIsInstalledEnabled "$dep_name"; then
						deps+=$(TextBrightGreen "$dep_name")
					else
						deps+=$(TextBrightRed "$dep_name")
					fi
				done
			else
				deps+=$(TextBrightGreen "$deps_raw")
			fi

			QpkgIsInstalledEnabled && enabled=true
			installed=missing
			QpkgIsInstalledRepoSelfManaged && managed=true
			QpkgIsDatabaseMaxOSVerOk && max_os_ok=true
			QpkgIsDatabaseMinOSVerOk && min_os_ok=true
			QpkgIsDatabaseMinRAMOk && min_ram_ok=true
			req_alert=true

			# Assign field messages.

			if [[ $arch = true ]]; then
				arch_msg+=$arch
			else
				arch_msg=${r_chars_alert}${arch}
			fi

			author_msg+=$author
			deps_msg+=${deps// /, }

			if [[ $enabled = true ]]; then
				enabled_msg+=$enabled
			else
				enabled_msg=${r_chars_alert}${enabled}
			fi

			installed_msg=${r_chars_alert}${installed}
			managed_msg+=$managed

			if [[ $max_os_ok = true ]]; then
				max_os_msg+=$max_os
			else
				max_os_msg=${r_chars_alert}${max_os}
			fi

			if [[ $min_os_ok = true ]]; then
				min_os_msg+=$min_os
			else
				min_os_msg=${r_chars_alert}${min_os}
			fi

			if [[ $min_ram_ok = true ]]; then
				min_ram_msg+=$min_ram
			else
				min_ram_msg=${r_chars_alert}${min_ram}
			fi

			# Highlight field messages.

			if [[ $arch = true ]]; then
				arch_msg=$(TextBrightGreen "$arch_msg")
			else
				arch_msg=$(TextBrightRed "$arch_msg")
			fi

			author_msg=$(TextBrightGreen "$author_msg")

			if [[ $enabled = true ]]; then
				enabled_msg=$(TextBrightGreen "$enabled_msg")
			else
				enabled_msg=$(TextBrightRedBlink "$enabled_msg")
			fi

			installed_msg=$(TextBrightRedBlink "$installed_msg")

			if [[ $managed = true ]]; then
				managed_msg=$(TextBrightGreen "$managed_msg")
			else
				managed_msg=$(TextBrightOrange "$managed_msg")
			fi

			if [[ $max_os_ok = true ]]; then
				if [[ $max_os != none ]]; then
					max_os_msg=$(TextBrightGreen "$max_os_msg")
				fi
			else
				max_os_msg=$(TextBrightRed "$max_os_msg")
			fi

			if [[ $min_os_ok = true ]]; then
				if [[ $min_os != none ]]; then
					min_os_msg=$(TextBrightGreen "$min_os_msg")
				fi
			else
				min_os_msg=$(TextBrightRed "$min_os_msg")
			fi

			if [[ $min_ram_ok = true ]]; then
				if [[ $min_ram != none ]]; then
					min_ram_msg=$(TextBrightGreen "$min_ram_msg")
				fi
			else
				min_ram_msg=$(TextBrightRed "$min_ram_msg")
			fi
			;;
		mute)
			/bin/touch "$r_report_flags_path"/state-notinstalled

			# Set field values.
			QpkgIsDatabaseArchOK "$qpkg_name" && arch=true
			author=N/A

			if [[ $deps_raw != none ]]; then
				for dep_name in $deps_raw; do
					[[ -n $deps ]] && deps+=' '
					deps+=$dep_name
				done
			else
				deps+=$deps_raw
			fi

			enabled=N/A
			managed=N/A
			QpkgIsDatabaseMaxOSVerOk "$qpkg_name" && max_os_ok=true
			QpkgIsDatabaseMinOSVerOk "$qpkg_name" && min_os_ok=true
			QpkgIsDatabaseMinRAMOk "$qpkg_name" && min_ram_ok=true

			/bin/touch "$r_report_flags_path"/na

			# Assign field messages.

			if [[ $arch = true ]]; then
				arch_msg+=$arch
			else
				arch_msg=${r_chars_attention}${arch}
				req_attention=true
			fi

			author_msg+=$author
			deps_msg+=${deps// /, }
			enabled_msg+=$enabled
			installed_msg+=$installed
			managed_msg+=$managed

			if [[ $max_os_ok = true ]]; then
				max_os_msg+=$max_os
			else
				max_os_msg=${r_chars_attention}${max_os}
				req_attention=true
			fi

			if [[ $min_os_ok = true ]]; then
				min_os_msg+=$min_os
			else
				min_os_msg=${r_chars_attention}${min_os}
				req_attention=true
			fi

			if [[ $min_ram_ok = true ]]; then
				min_ram_msg+=$min_ram
			else
				min_ram_msg=${r_chars_attention}${min_ram}
				req_attention=true
			fi

			# Highlight field messages.

			if [[ $arch = true ]]; then
				arch_msg=$(TextDarkGrey "$arch_msg")
			else
				arch_msg=$(TextBrightOrange "$arch_msg")
			fi

			author_msg=$(TextDarkGrey "$author_msg")
			deps_msg=$(TextDarkGrey "$deps_msg")
			enabled_msg=$(TextDarkGrey "$enabled_msg")
			installed_msg=$(TextDarkGrey "$installed_msg")
			managed_msg=$(TextDarkGrey "$managed_msg")

			if [[ $max_os_ok = true ]]; then
				max_os_msg=$(TextDarkGrey "$max_os_msg")
			else
				max_os_msg=$(TextBrightOrange "$max_os_msg")
			fi

			if [[ $min_os_ok = true ]]; then
				min_os_msg=$(TextDarkGrey "$min_os_msg")
			else
				min_os_msg=$(TextBrightOrange "$min_os_msg")
			fi

			if [[ $min_ram_ok = true ]]; then
				min_ram_msg=$(TextDarkGrey "$min_ram_msg")
			else
				min_ram_msg=$(TextBrightOrange "$min_ram_msg")
			fi
			;;
		normal)
			# Set field values.

			QpkgIsDatabaseArchOK && arch=true
			author_ok=true
			QpkgIsInstalledEnabled && enabled=true
			installed=true
			QpkgIsInstalledRepoSelfManaged && managed=true
			QpkgIsDatabaseMaxOSVerOk && max_os_ok=true
			QpkgIsDatabaseMinOSVerOk && min_os_ok=true
			QpkgIsDatabaseMinRAMOk && min_ram_ok=true

			# Assign field messages.

			if [[ $arch = true ]]; then
				arch_msg+=$arch
			else
				arch_msg=${r_chars_alert}${arch}
				req_alert=true
			fi

			author_msg+=$author

			if [[ $deps_raw != none ]]; then
				for dep_name in $deps_raw; do
					[[ -n $deps ]] && deps+=' '

					if QpkgIsInstalled "$dep_name" && QpkgIsInstalledEnabled "$dep_name"; then
						deps+=$(TextBrightGreen "$dep_name")
					else
						deps+=$(TextBrightRed "$dep_name")
						deps_msg=$(TextBrightRed "$r_chars_alert")
						req_alert=true
					fi
				done
			else
				deps+=$deps_raw
			fi

			if [[ $enabled = true ]]; then
				enabled_msg+=$enabled
			else
				enabled_msg=${r_chars_alert}${enabled}
				req_alert=true
			fi

			installed_msg+=$installed
			managed_msg+=$managed

			if [[ $max_os_ok = true ]]; then
				max_os_msg+=$max_os
			else
				max_os_msg=${r_chars_alert}${max_os}
				req_alert=true
			fi

			if [[ $min_os_ok = true ]]; then
				min_os_msg+=$min_os
			else
				min_os_msg=${r_chars_alert}${min_os}
				req_alert=true
			fi

			if [[ $min_ram_ok = true ]]; then
				min_ram_msg+=$min_ram
			else
				min_ram_msg=${r_chars_alert}${min_ram}
				req_alert=true
			fi

			# Highlight field messages.

			if [[ $arch = true ]]; then
				arch_msg=$(TextBrightGreen "$arch_msg")
			else
				arch_msg=$(TextBrightRed "$arch_msg")
			fi

			author_msg=$(TextBrightGreen "$author_msg")
			deps_msg+=${deps// /, }

			if [[ $enabled = true ]]; then
				enabled_msg=$(TextBrightGreen "$enabled_msg")
			else
				enabled_msg=$(TextBrightRed "$enabled_msg")
			fi

			installed_msg=$(TextBrightGreen "$installed_msg")

			if [[ $managed = true ]]; then
				managed_msg=$(TextBrightGreen "$managed_msg")
			else
				managed_msg=$(TextBrightOrange "$managed_msg")
			fi

			if [[ $max_os_ok = true ]]; then
				if [[ $max_os != none ]]; then
					max_os_msg=$(TextBrightGreen "$max_os_msg")
				fi
			else
				max_os_msg=$(TextBrightRed "$max_os_msg")
			fi

			if [[ $min_os_ok = true ]]; then
				if [[ $min_os != none ]]; then
					min_os_msg=$(TextBrightGreen "$min_os_msg")
				fi
			else
				min_os_msg=$(TextBrightRed "$min_os_msg")
			fi

			if [[ $min_ram_ok = true ]]; then
				if [[ $min_ram != none ]]; then
					min_ram_msg=$(TextBrightGreen "$min_ram_msg")
				fi
			else
				min_ram_msg=$(TextBrightRed "$min_ram_msg")
			fi
	esac

	if [[ $req_alert = true ]]; then
		/bin/touch "$r_report_flags_path"/req-alert
		name_msg=${r_chars_blank}$(TextBrightRed "$qpkg_name")
	elif [[ $req_attention = true ]]; then
		/bin/touch "$r_report_flags_path"/req-attention
		name_msg=${r_chars_blank}$(TextBrightOrange "$qpkg_name")
	elif [[ $mode = mute ]]; then
		name_msg+=$(TextDarkGrey "$qpkg_name")
	else
		name_msg+=$qpkg_name
	fi

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$deps_msg|$installed_msg|$enabled_msg|$managed_msg|$min_ram_msg|$min_os_msg|$max_os_msg|$arch_msg|$author_msg"
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: package dependencies.
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_dependencies_column_width+$(LenANSIDiff "$deps_msg")))s" "$deps_msg"

		# column 3: package is installed?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_is_installed_column_width+$(LenANSIDiff "$installed_msg")))s" "$installed_msg"

		# column 4: package is enabled?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_is_enabled_column_width+$(LenANSIDiff "$enabled_msg")))s" "$enabled_msg"

		# column 5: package is managed by sherpa?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_is_managed_column_width+$(LenANSIDiff "$managed_msg")))s" "$managed_msg"

		# column 6: minimum NAS RAM required.
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_min_ram_column_width+$(LenANSIDiff "$min_ram_msg")))s" "$min_ram_msg"

		# column 7: minimum OS fimware version supported.
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_min_os_version_column_width+$(LenANSIDiff "$min_os_msg")))s" "$min_os_msg"

		# column 8: maximum OS fimware version supported.
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_max_os_version_column_width+$(LenANSIDiff "$max_os_msg")))s" "$max_os_msg"

		# column 9: NAS arch is compatible?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_arch_column_width+$(LenANSIDiff "$arch_msg")))s" "$arch_msg"

		# column 10: installed QPKG author.
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$author_msg")))s" "$author_msg"

		printf '\n'
	fi

	}

GenerateFeaturesReportTitleLine()
	{

	local a=''

	# column 1: package name.
	a='QPKG name:'
	printf "%-$((r_report_qpkg_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: package supports `backup` action?
	a='CanBack?'
	printf "%-$((r_report_qpkg_supports_backup_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: package supports `clean` action?
	a='CanClean?'
	printf "%-$((r_report_qpkg_supports_clean_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 4: package supports restart-to-update application action?
	a='StartUpd?'
	printf "%-$((r_report_qpkg_supports_start_to_update_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 5: package is set to auto-update on restart?
	a='AutoUpd?'
	printf "%-$((r_report_qpkg_auto_update_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 6: package active test is builtin?
	a='LiveTest?'
	printf "%-$((r_report_qpkg_active_test_builtin_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 7: package is independent?
	a='Indep?'
	printf "%-$((r_report_qpkg_tier_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 8: NAS arch is compatible?
	a='ArchCompat?'
	printf "%-$((r_report_qpkg_is_compatible_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 9: QPKG is sherpa-compatible?
	a='Enhanced?'
	printf "%-$((r_report_lazy_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 10: QPKG unpacks itself to unique path?
	a='UniqueUnpack?'
	printf "%-$((r_report_lazy_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GenerateFeaturesReportDataLine()
	{

	# * This function runs asynchronously *

	# Inputs: (global)
	# 	$qpkg_name
	#	$r_report_flags_path

	local active_test=false
	local active_test_msg=$r_chars_blank
	local autoupdate=false					# Tri-state: true, false, N/A
	local autoupdate_msg=$r_chars_blank
	local backup=false
	local backup_msg=$r_chars_blank
	local clean=false
	local clean_msg=$r_chars_blank
	local arch_compatible=false
	local arch_compatible_msg=$r_chars_blank
	local mode=''
	local name_msg=$r_chars_blank
	local req_alert=false
	local req_attention=false
	local restart_to_update=false
	local restart_to_update_msg=$r_chars_blank
	local sherpa_compatible=false
	local sherpa_compatible_msg=$r_chars_blank
	local tier=false
	local tier_msg=$r_chars_blank
	local uniqueunpack=false
	local uniqueunpack_msg=$r_chars_blank

	if QpkgIsInstalledMissing; then
		mode=missing
	elif QpkgIsInstalled; then
		mode=normal
	else
		mode=mute
		QpkgIsReallyInstalled && QpkgIsNtInstalledAuthorOk && mode=author
	fi

	case $mode in
		author)
			# Set field values.
			backup='incompatible author'
			req_attention=true

			# Assign field messages.
			backup_msg=${r_chars_attention}${backup}

			# Highlight field messages.
			backup_msg=$(TextBrightOrange "$backup_msg")
			;;
		missing)
			# Set field values.
			backup=missing
			req_alert=true

			# Assign field messages.
			backup_msg=${r_chars_alert}${backup}

			# Highlight field messages.
			backup_msg=$(TextBrightRedBlink "$backup_msg")
			;;
		mute)
			# Set field values.
			active_test=N/A
			autoupdate=N/A
			backup=N/A
			clean=N/A
			arch_compatible=N/A
			restart_to_update=N/A
			sherpa_compatible=N/A
			tier=N/A
			uniqueunpack=N/A

			# Assign field messages.
			active_test_msg+=$active_test
			autoupdate_msg+=$autoupdate
			backup_msg+=$backup
			clean_msg+=$clean
			arch_compatible_msg+=$arch_compatible
			restart_to_update_msg+=$restart_to_update
			sherpa_compatible_msg+=$sherpa_compatible
			tier_msg+=$tier
			uniqueunpack_msg+=$uniqueunpack

			# Highlight field messages.
			active_test_msg=$(TextDarkGrey "$active_test_msg")
			autoupdate_msg=$(TextDarkGrey "$autoupdate_msg")
			backup_msg=$(TextDarkGrey "$backup_msg")
			clean_msg=$(TextDarkGrey "$clean_msg")
			arch_compatible_msg=$(TextDarkGrey "$arch_compatible_msg")
			restart_to_update_msg=$(TextDarkGrey "$restart_to_update_msg")
			sherpa_compatible_msg=$(TextDarkGrey "$sherpa_compatible_msg")
			tier_msg=$(TextDarkGrey "$tier_msg")
			uniqueunpack_msg=$(TextDarkGrey "$uniqueunpack_msg")
			;;
		normal)
			# Set field values.
			[[ $(QpkgGetDatabaseActiveTest) = builtin ]] && active_test=true

			if QpkgIsInstalled && QpkgIsDatabaseCanRestartToUpdate; then
				if QpkgIsInstalledAutoUpdate; then
					autoupdate=true
				fi
			elif [[ $qpkg_name = sherpa ]]; then
				autoupdate=true					# sherpa always auto-updates and this can't be disabled.
			else
				autoupdate=N/A
				/bin/touch "$r_report_flags_path"/na
			fi

			QpkgIsDatabaseCanBackup && backup=true
			QpkgIsDatabaseCanClean && clean=true
			QpkgIsDatabaseArchOK && arch_compatible=true

			if QpkgIsDatabaseCanRestartToUpdate; then
				restart_to_update=true
			elif [[ $qpkg_name = sherpa ]]; then
				restart_to_update=true			# sherpa always auto-updates and this can't be disabled.
			fi

			QpkgIsDatabaseSherpaCompatible && sherpa_compatible=true
			QpkgIsDatabaseIndependent && tier=true
			QpkgIsDatabaseUniqueUnpack && uniqueunpack=true

			# Assign field messages.
			active_test_msg+=$active_test
			autoupdate_msg+=$autoupdate
			backup_msg+=$backup
			clean_msg+=$clean
			arch_compatible_msg+=$arch_compatible
			restart_to_update_msg+=$restart_to_update
			sherpa_compatible_msg+=$sherpa_compatible
			tier_msg+=$tier
			uniqueunpack_msg+=$uniqueunpack

			# Highlight field messages.

			if [[ $active_test = true ]]; then
				: #	active_test_msg=$(TextBrightGreen "$active_test_msg")
			else
				active_test_msg=$(TextBrightOrange "$active_test_msg")
			fi

			if [[ $autoupdate = true ]]; then			# Tri-state.
				: # autoupdate_msg=$(TextBrightGreen "$autoupdate_msg")
			elif [[ $autoupdate = false ]]; then
				autoupdate_msg=$(TextBrightOrange "$autoupdate_msg")
			fi

			if [[ $backup = true ]]; then
				: # backup_msg=$(TextBrightGreen "$backup_msg")
			else
				backup_msg=$(TextBrightOrange "$backup_msg")
			fi

			if [[ $clean = true ]]; then
				: # clean_msg=$(TextBrightGreen "$clean_msg")
			else
				clean_msg=$(TextBrightOrange "$clean_msg")
			fi

			if [[ $arch_compatible = true ]]; then
				: # arch_compatible_msg=$(TextBrightGreen "$arch_compatible_msg")
			else
				arch_compatible_msg=$(TextBrightRed "$arch_compatible_msg")
			fi

			if [[ $restart_to_update = true ]]; then
				: # restart_to_update_msg=$(TextBrightGreen "$restart_to_update_msg")
			else
				restart_to_update_msg=$(TextBrightOrange "$restart_to_update_msg")
			fi

			if [[ $sherpa_compatible = true ]]; then
				: # sherpa_compatible_msg=$(TextBrightGreen "$sherpa_compatible_msg")
			else
				sherpa_compatible_msg=$(TextBrightOrange "$sherpa_compatible_msg")
			fi

			if [[ $uniqueunpack = true ]]; then
				: # uniqueunpack_msg=$(TextBrightGreen "$uniqueunpack_msg")
			else
				uniqueunpack_msg=$(TextBrightOrange "$uniqueunpack_msg")
			fi
	esac

	if [[ $req_alert = true ]]; then
		/bin/touch "$r_report_flags_path"/req-alert
		name_msg=${r_chars_blank}$(TextBrightRed "$qpkg_name")
	elif [[ $req_attention = true ]]; then
		/bin/touch "$r_report_flags_path"/req-attention
		name_msg=${r_chars_blank}$(TextBrightOrange "$qpkg_name")
	elif [[ $mode = mute ]]; then
		name_msg+=$(TextDarkGrey "$qpkg_name")
	else
		name_msg+=$qpkg_name
	fi

	if OsIsSupportAutowidthTableColumns; then
		echo "$name_msg|$backup_msg|$clean_msg|$restart_to_update_msg|$autoupdate_msg|$active_test_msg|$tier_msg|$arch_compatible_msg|$sherpa_compatible_msg|$uniqueunpack_msg"
	else
		# column 1: package name.
		printf "%-$((r_report_qpkg_name_column_width+$(LenANSIDiff "$name_msg")))s" "$name_msg"

		# column 2: package supports `backup` action?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_supports_backup_column_width+$(LenANSIDiff "$backup_msg")))s" "$backup_msg"

		# column 3: package supports `clean` action?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_supports_clean_column_width+$(LenANSIDiff "$clean_msg")))s" "$clean_msg"

		# column 4: package supports restart-to-update application action?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_supports_start_to_update_column_width+$(LenANSIDiff "$restart_to_update_msg")))s" "$restart_to_update_msg"

		# column 5: package is set to auto-update on restart?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_auto_update_column_width+$(LenANSIDiff "$autoupdate_msg")))s" "$autoupdate_msg"

		# column 6: package active test is builtin?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_active_test_builtin_column_width+$(LenANSIDiff "$active_test_msg")))s" "$active_test_msg"

		# column 7: package is independent?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_tier_column_width+$(LenANSIDiff "$tier_msg")))s" "$tier_msg"

		# column 8: NAS arch is compatible?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_qpkg_is_compatible_column_width+$(LenANSIDiff "$arch_compatible_msg")))s" "$arch_compatible_msg"

		# column 9: QPKG is sherpa-compatible?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$sherpa_compatible_msg")))s" "$sherpa_compatible_msg"

		# column 10: QPKG will unpack to unique path?
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_lazy_column_width+$(LenANSIDiff "$uniqueunpack_msg")))s" "$uniqueunpack_msg"

		printf '\n'
	fi

	}

GenerateBacksReportTitleLine()
	{

	local a=''

	# column 1: backup filename
	a='Backup file:'
	printf "%-$((r_report_file_name_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 2: filesize in bytes
	a='Size in bytes:'
	printf "%-$((r_report_file_bytes_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	# column 3: last backup date
	a='Backup date:'
	printf "%-$((r_report_file_change_date_column_width+2+$(LenANSIDiff "$a")))s" "$a"

	printf '\n'

	}

GenerateBacksReportItemLine()
	{

	# Inputs:
	#	$1 = last backup date in epoch seconds
	#	$2 = backup filename
	#	$3 = filesize in bytes
	#	$4 = age threshold to highlight (optional) '1 week ago' (default)		e.g. '2 days ago', '2 weeks ago', etc ...

	local epoch_time=${1:-0}
	local epoch_time_msg=$r_chars_normal
	local file_bytes=${3:-0}
	local file_bytes_msg=$r_chars_blank
	local file_name=${2:-}
	local file_name_msg=$r_chars_blank
	local mode=''

	if [[ ${epoch_time%.*} -lt $(/bin/date --date="${4:-'1 week ago'}" +%s) ]]; then
		mode=highlight
	else
		mode=normal
	fi

	file_bytes=$(FormatAsThous "$file_bytes")

	case $mode in
		normal)
			epoch_time_msg+=$(ConvertSecondsToFullDate "$epoch_time")
			file_bytes_msg+=$file_bytes
			file_name_msg+=$file_name
			/bin/touch "$r_report_flags_path"/backup-file-ok
			;;
		highlight)
			epoch_time_msg=$(TextBrightRed "${r_chars_alert}$(ConvertSecondsToFullDate "$epoch_time")")
			file_bytes_msg+=$(TextBrightRed "$file_bytes")
			file_name_msg+=$(TextBrightRed "$file_name")
			/bin/touch "$r_report_flags_path"/backup-file-old
	esac

	if OsIsSupportAutowidthTableColumns; then
		echo "$file_name_msg|$file_bytes_msg|$epoch_time_msg"
	else
		# column 1: backup filename
		printf "%-$((r_report_file_name_column_width+$(LenANSIDiff "$file_name_msg")))s" "$file_name_msg"

		# column 2: filesize in bytes
		printf "%$((r_report_column_spacing))s"
		printf "%$((r_report_file_bytes_column_width+$(LenANSIDiff "$file_bytes_msg")))s" "$file_bytes_msg "	# append 1 x whitespace char to force right-justified numbers to the left a bit. Looks nicer.

		# column 3: last backup date
		printf "%$((r_report_column_spacing))s"
		printf "%-$((r_report_file_change_date_column_width+$(LenANSIDiff "$epoch_time_msg")))s" "$epoch_time_msg"

		printf '\n'
	fi

	}

DisplayAsHelpTitle()
	{

	# Inputs:
	#	$1 = text

	printf "\n${r_chars_bullet}%s\n" "$(Capitalise "${1:-}" | tr -s ' ')"

	}

DisplayAsHelpTitleHighlighted()
	{

	# Inputs:
	#	$1 = text

	# shellcheck disable=2059
	printf "\n$(TextBrightOrange "${r_chars_bullet}%s\n")" "$(Capitalise "${1:-}")"

	}

DisplayAsIndentActionResultDurationReason()
	{

	# Inputs:
	#	$1 = action
	#	$2 = result message
	#	$3 = duration in milliseconds (optional)
	#	$4 = reason message (optional)

	[[ -n ${1:-} && -n ${2:-} ]] || return

	local action=''
	local duration=''

	case $1 in
		disableau)
			action='disable auto-update'
			;;
		enableau)
			action='enable auto-update'
			;;
		*)
			action=$1
	esac

	[[ -n ${3:-} ]] && duration=$(ConvertMillisecondsToDuration "$3")

	printf "%${r_report_action_result_indent}s" ''

	if [[ -z ${4:-} ]]; then
		printf "%s %s%s" "$(Lowercase "$action")" "$2" "$([[ -n $duration ]] && printf ' in %s' "$duration")"
	else
		printf "%s %s%s (%s)" "$(Lowercase "$action")" "$2" "$([[ -n $duration ]] && printf ' in %s' "$duration")" "$4"
	fi

	printf '\n'

	}

EraseThisLine()
	{

	# Reset cursor to start-of-line, erasing entire line, and stay on this line.

	[[ ${useropt_verbose:=false} = false ]] && printf '\033[2K\r'

	} >&2

Display()
	{

	if [[ -z ${1:-} ]]; then
		printf '\n'
	else
		printf '%s\n' "$1"
	fi

	}

DisplayWait()
	{

	printf '%s' "${1:-}"

	}

ShowHelpActions()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport actions

		{

		ShowHelpBasic
		DisplayAsHelpTitle "$(ShowAsAction) usage examples:"
		DisplayAsProjSynIndentExam 'activate these packages (this will upgrade internal applications where-supported)' "activate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "start $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'backup these application configurations to the backup location' "backup $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'check all application dependencies are installed' check
		DisplayAsProjSynIndentExam '' c
		DisplayAsProjSynIndentExam 'clean local repository files from these packages (your config is safe, application files will be downloaded again)' "clean $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'deactivate these packages' "deactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "stop $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'generate QPKG dependencies report' dependencies
		DisplayAsProjSynIndentExam '' d
		DisplayAsProjSynIndentExam 'disable these packages. This will prevent them being activated' "disable $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'disable auto-updating the application on package activation (where-supported)' "disable-auto-update $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'enable these packages. Packages must be enabled before they can be activated' "enable $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'enable auto-updating the application on package activation (where-supported)' "enable-auto-update $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'install these packages' "install $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "add $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'show application backup files' 'show backups'
		DisplayAsProjSynIndentExam '' b
# 		DisplayAsProjSynIndentExam "list $(ShowAsTitleName) object version numbers" 'list versions'
		DisplayAsProjSynIndentExam 'reactivate these packages (this will upgrade internal applications where-supported)' "reactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "restart $(ShowAsPackages)"
		DisplayAsProjSynIndentExam "reassign packages to $(ShowAsTitleName). Detach packages previously installed via an online repository from further management by that repository" "reassign $(ShowAsPackages)"
		DisplayAsProjSynIndentExam "rebuild these packages ('install' packages, then 'restore' configuration backups)" "rebuild $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'reinstall these packages' "reinstall $(ShowAsPackages)"
# 		DisplayAsProjSynIndentExam 'generate QPKG repository assignments report' repos
# 		DisplayAsProjSynIndentExam '' r
		DisplayAsProjSynIndentExam 'restore these application configurations from the backup location' "restore $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'digitally "sign" these QPKGs' "sign $(ShowAsPackages)"
# 		DisplayAsProjSynIndentExam 'generate QPKG status report' status
# 		DisplayAsProjSynIndentExam '' s
		DisplayAsProjSynIndentExam 'uninstall these packages' "uninstall $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "remove $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "rm $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'upgrade these packages (this will upgrade internal applications where-supported)' "upgrade $(ShowAsPackages)"

		DisplayAsProjSynExam "$(ShowAsAction)s to affect all packages can be seen with" 'help all-actions'
		DisplayAsProjSynIndentExam '' 'help actions-all'
		DisplayAsProjSynExam "multiple $(ShowAsAction)s are supported like this" "$(ShowAsAction) $(ShowAsPackages) $(ShowAsAction) $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' 'install sabnzbd sickgear reactivate transmission uninstall lazy nzbget upgrade nzbtomedia'

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpActionsAll()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport 'all actions'

		{

		ShowHelpBasic
		DisplayAsHelpTitle "the 'all' group applies to all QPKGs. If $(ShowAsAction) is 'install all' then all available QPKGs will be installed."
		DisplayAsHelpTitle "$(ShowAsAction) $(ShowAsPackageGroup) usage examples:"
		DisplayAsProjSynIndentExam 'activate all QPKGs (this will upgrade internal applications where-supported)' 'activate all'
		DisplayAsProjSynIndentExam '' 'start all'
		DisplayAsProjSynIndentExam 'backup all application configurations to the backup location' 'backup all'
		DisplayAsProjSynIndentExam 'clean local repository files from all QPKGs (your configs are safe, application files will be downloaded again)' 'clean all'
		DisplayAsProjSynIndentExam 'deactivate all QPKGs' 'deactivate all'
		DisplayAsProjSynIndentExam '' 'stop all'
		DisplayAsProjSynIndentExam 'disable all QPKGs. This will prevent them being activated' 'disable all'
		DisplayAsProjSynIndentExam 'disable auto-updating all applications on QPKG activation (where-supported)' 'disable-auto-update all'
		DisplayAsProjSynIndentExam 'enable all QPKGs. QPKGs must be enabled before they can be started' 'enable all'
		DisplayAsProjSynIndentExam 'enable auto-updating all applications on QPKG activation (where-supported)' 'enable-auto-update all'
		DisplayAsProjSynIndentExam 'install everything!' 'install all'
		DisplayAsProjSynIndentExam 'reactivate installed QPKGs (this will upgrade internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam '' 'restart all'
		DisplayAsProjSynIndentExam "reassign all QPKGs to $(ShowAsTitleName). Detach QPKGs previously installed via an online repository from further management by that repository" 'reassign all'
		DisplayAsProjSynIndentExam "rebuild all QPKGs where backup files exist ('install' QPKGs and 'restore' backups)" 'rebuild all'
		DisplayAsProjSynIndentExam 'reinstall all QPKGs' 'reinstall all'
		DisplayAsProjSynIndentExam 'restore all application configurations from the backup location' 'restore all'
		DisplayAsProjSynIndentExam 'digitally "sign" all QPKGs' 'sign all'
		DisplayAsProjSynIndentExam 'find the live status of each application in all QPKGs' 'status all'
		DisplayAsProjSynIndentExam 'uninstall all QPKGs' 'uninstall all'
		DisplayAsProjSynIndentExam 'upgrade all QPKGs (and internal applications where-supported)' 'upgrade all'

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpBackupLocation()
	{

	DisplayAsSynExam 'the backup location can be accessed by running' "cd $r_qpkg_bu_path"

	return 0

	}

ShowHelpBasic()
	{

	DisplayAsHelpTitle "usage: sherpa $(ShowAsAction) $(ShowAsPackages) $(ShowAsPackageGroup) $(ShowAsOptions)"

	return 0

	}

ShowHelpBasicExamples()
	{

		{

		DisplayAsProjSynIndentExam "to see available $(ShowAsAction)s" 'help actions'
		DisplayAsProjSynIndentExam "to see available $(ShowAsPackages)" 'show packages'
		DisplayAsProjSynIndentExam '' p
		DisplayAsProjSynIndentExam "to see available $(ShowAsPackageGroup)s" 'help groups'
		DisplayAsProjSynIndentExam "or, for more $(ShowAsOptions)" 'help options'
		DisplayAsHelpTitle "more in the wiki: $(ShowAsURL 'https://github.com/OneCDOnly/sherpa/wiki')"

		} > "$r_report_output_pathfile"

	ShowReport

	return 0

	}

ShowHelpGroups()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport groups

		{

		ShowHelpBasic
		DisplayAsHelpTitle "$(ShowAsPackageGroup) usage examples:"
		DisplayAsProjSynIndentExam 'select every package' "$(ShowAsAction) all"
		DisplayAsProjSynIndentExam 'select only active QPKGs' "$(ShowAsAction) active"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) started"
		DisplayAsProjSynIndentExam 'select only disabled QPKGs' "$(ShowAsAction) disabled"
		DisplayAsProjSynIndentExam 'select only enabled QPKGs' "$(ShowAsAction) enabled"
		DisplayAsProjSynIndentExam 'select only inactive QPKGs' "$(ShowAsAction) inactive"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) stopped"
		DisplayAsProjSynIndentExam 'select only installable QPKGs' "$(ShowAsAction) installable"
		DisplayAsProjSynIndentExam 'select only installed QPKGs' "$(ShowAsAction) installed"
		DisplayAsProjSynIndentExam 'select only QPKGs that are not installed' "$(ShowAsAction) not-installed"
		DisplayAsProjSynIndentExam 'select only QPKGs that are backed-up' "$(ShowAsAction) backedup"
		DisplayAsProjSynIndentExam 'select only QPKGs that are not backed-up' "$(ShowAsAction) not-backedup"
		DisplayAsProjSynIndentExam 'select only QPKGs that are upgradable' "$(ShowAsAction) upgradable"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) new"
		DisplayAsProjSynIndentExam 'select only missing QPKGs (these are partly-installed and broken)' "$(ShowAsAction) missing"
		DisplayAsProjSynExam 'multiple groups are supported like this' "$(ShowAsAction) $(ShowAsPackageGroup) $(ShowAsPackageGroup)"

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpIssue()
	{

	DisplayAsHelpTitle "please consider creating a new issue for this on GitHub: $(ShowAsURL 'https://github.com/OneCDOnly/sherpa/issues')"
	DisplayAsHelpTitle "alternatively, post on the QNAP NAS Community Forum: $(ShowAsURL 'https://forum.qnap.com/viewtopic.php?f=320&t=132373')"
	DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
	DisplayAsProjSynIndentExam "view the entire $(ShowAsTitleName) session log" log
	DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$r_log_tail_lines") lines in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
	Display

	return 0

	}

ShowHelpLists()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport lists

		{

		ShowHelpBasic
		DisplayAsHelpTitle "'list' usage examples:"
		DisplayAsProjSynIndentExam 'list all available QPKGs' 'list all'
# 		DisplayAsProjSynIndentExam 'list package backup files' 'list backups'
# 		DisplayAsProjSynIndentExam '' b
		DisplayAsProjSynIndentExam 'list only QPKGs that can be installed' 'list installable'
		DisplayAsProjSynIndentExam '' installable
		DisplayAsProjSynIndentExam 'list only installed QPKGs' 'list installed'
		DisplayAsProjSynIndentExam '' installed
		DisplayAsProjSynIndentExam 'list only QPKGs that are not installed' 'list not-installed'
		DisplayAsProjSynIndentExam '' not-installed
		DisplayAsProjSynIndentExam 'list only upgradable QPKGs' 'list upgradable'
		DisplayAsProjSynIndentExam '' 'list new'
		DisplayAsProjSynIndentExam '' upgradable
		DisplayAsProjSynIndentExam '' new
		DisplayAsProjSynIndentExam "list $(ShowAsTitleName) object version numbers" 'list versions'
		DisplayAsProjSynIndentExam '' versions

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpShow()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport show

		{

		ShowHelpBasic
		DisplayAsHelpTitle "'show' usage examples:"
		DisplayAsProjSynIndentExam 'show QPKG abbreviations' 'show abbreviations'
		DisplayAsProjSynIndentExam '' 'show abs'
		DisplayAsProjSynIndentExam '' a
		DisplayAsProjSynIndentExam 'show application backup files' 'show backups'
		DisplayAsProjSynIndentExam '' b
		DisplayAsProjSynIndentExam 'show QPKG dependency report' 'show dependencies'
		DisplayAsProjSynIndentExam '' 'show deps'
		DisplayAsProjSynIndentExam '' d
		DisplayAsProjSynIndentExam 'show QPKG repository assignments report' 'show repositories'
		DisplayAsProjSynIndentExam '' 'show repos'
		DisplayAsProjSynIndentExam '' r
		DisplayAsProjSynIndentExam 'show last session action results' 'show results'
		DisplayAsProjSynIndentExam '' results

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpOptions()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport options

		{

		ShowHelpBasic
		DisplayAsHelpTitle "$(ShowAsOptions) usage examples:"
		DisplayAsProjSynIndentExam 'show debugging information, and record it to file' "$(ShowAsAction) $(ShowAsPackages) debug"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) $(ShowAsPackages) verbose"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) $(ShowAsPackages) v"

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpPackages()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport packages

		{

		ShowHelpBasic
		DisplayAsHelpTitle 'usage examples for QPKGs will go here:'

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpProblems()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport problems

		{

		ShowHelpBasic
		DisplayAsHelpTitle 'usage examples for dealing with problems:'
		DisplayAsProjSynIndentExam 'activate these QPKGs' "activate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'ensure all dependencies exist for installed QPKGs' check
		DisplayAsProjSynIndentExam '' c
		DisplayAsProjSynIndentExam 'clear local repository files from these QPKGs' "clean $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'deactivate these QPKGs' "deactivate $(ShowAsPackages)"
		DisplayAsProjSynIndentExam "increase the default 'qpkg_service' timeouts from 3 minutes to 30 minutes" 'install increasetimeouts'
		DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
		DisplayAsProjSynIndentExam '' l
		DisplayAsProjSynIndentExam "view the entire $(ShowAsTitleName) session log" log
		DisplayAsProjSynIndentExam "upload the most-recent session in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste last'
		DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$r_log_tail_lines") lines in your $(ShowAsTitleName) log to the $(ShowAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
		DisplayAsProjSynIndentExam 'reactivate installed QPKGs (upgrades internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam "remove all cached $(ShowAsTitleName) items and logs" reset
		DisplayAsProjSynIndentExam 'find the live status of each application in these QPKGs' "status $(ShowAsPackages)"
		DisplayAsProjSynIndentExam '' "s $(ShowAsPackages)"
		DisplayAsProjSynIndentExam 'show debugging information, and record it to file' "$(ShowAsAction) $(ShowAsPackages) debug"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) $(ShowAsPackages) verbose"
		DisplayAsProjSynIndentExam '' "$(ShowAsAction) $(ShowAsPackages) v"
		DisplayAsHelpTitleHighlighted "if you need help, please include a copy of your $(ShowAsTitleName) $(TextBrightOrange "log for analysis!")"

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpUpgrades()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport upgrades

		{

		ShowHelpBasic
		DisplayAsHelpTitle 'usage examples for upgrading your QPKGs:'
		DisplayAsProjSynIndentExam 'upgrade only the upgradable QPKGs' 'upgrade upgradable'
		DisplayAsProjSynIndentExam '' 'upgrade new'
		DisplayAsProjSynIndentExam 'show a list of upgradable QPKGs' 'list upgradable'
		DisplayAsProjSynIndentExam '' 'list new'
		DisplayAsProjSynIndentExam 'find the live application status of upgradable QPKGs' 'status upgradable'
		DisplayAsProjSynIndentExam '' 's upgradable'
		DisplayAsProjSynIndentExam '' 's new'

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ShowHelpTips()
	{

	DisableDebugToArchiveAndFile
	DisplayProcReport tips

		{

		ShowHelpBasic
		DisplayAsHelpTitle 'helpful tips and shortcuts:'
		DisplayAsProjSynIndentExam "install all available $(ShowAsTitleName) QPKGs" 'install all'
		DisplayAsProjSynIndentExam 'package abbreviations and aliases also work. To see these' 'help abs'
		DisplayAsProjSynIndentExam '' a
		DisplayAsProjSynIndentExam 'reactivate all QPKGs (upgrades internal applications where-supported)' 'reactivate all'
		DisplayAsProjSynIndentExam 'list only QPKGs that can be installed' 'list installable'
		DisplayAsProjSynIndentExam "view only the most recent $(ShowAsTitleName) session log" last
		DisplayAsProjSynIndentExam '' l
		DisplayAsProjSynIndentExam 'activate all inactive QPKGs' 'activate inactive'
		DisplayAsProjSynIndentExam 'upgrade the internal applications only' "reactivate $(ShowAsPackages)"
		ShowHelpBackupLocation

		} > "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	return 0

	}

ViewLogLast()
	{

	# View only the last session log.

	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail
	EraseThisLine

	if [[ -e $r_session_last_pathfile ]]; then
		DisplayFileInViewport "$r_session_last_pathfile" linenumbers
		Display
	else
		ShowAsError 'no last session log to display'
	fi

	return 0

	}

ViewLogTail()
	{

	# View only the last session log.

	DisableDebugToArchiveAndFile
	ExtractTailFromLog
	EraseThisLine

	if [[ -e $r_session_tail_pathfile ]]; then
		DisplayFileInViewport "$r_session_tail_pathfile" linenumbers
		Display
	else
		ShowAsError 'no session log tail to display'
	fi

	return 0

	}

DisplayFileInViewport()
	{

	# Inputs:
	# 	$1 = pathfile to display
	# 	$2/$3/$4 (optional, and in any order)
	#		= 'linenumbers' : display file contents with line numbers.
	#		= 'jumptoend'   : display file contents scrolled to the last line.
	#		= 'wrap'		: wrap lines of text to displayport.

	local filename=${1:-}
	local jumptoend=false
	local options=''
	local prompt=' use arrow-keys to scroll up-down & left-right, press Q to quit '
	local showlinenumbers=false
	local wraplines=false

	if [[ ! -e $filename ]]; then
		echo "filename $(ShowAsFileName "$filename") not found"

		return 1
	fi

	case 'linenumbers' in
		${2:-}|${3:-}|${4:-})
			showlinenumbers=true
	esac

	case 'jumptoend' in
		${2:-}|${3:-}|${4:-})
			jumptoend=true
	esac

	case 'wrap' in
		${2:-}|${3:-}|${4:-})
			wraplines=true
	esac

	if [[ $useropt_verbose = true ]]; then
		if [[ -e $CAT_CMD ]]; then
			$CAT_CMD "$filename"

			return
		else
			echo "$(<$1)"

			return
		fi
	fi

	if [[ $($WC_CMD -l < "$filename") -ge $r_sess_rows || $($WC_CMD -L < "$filename") -ge $r_sess_columns ]]; then
		if [[ -e $GNU_LESS_CMD ]]; then
			options=' --quit-on-intr --tilde --mouse --RAW-CONTROL-CHARS --shift=4 --redraw-on-quit --quit-if-one-screen'
			[[ $wraplines = false ]] && options+=' --chop-long-lines'
			[[ $showlinenumbers = true ]] && options+=' --LINE-NUMBERS'
			[[ $jumptoend = true ]] && options+=' +G'
			LESSSECURE=1 ${GNU_LESS_CMD}${options} --prompt "$prompt" "$filename"

			return
		fi

		if [[ -e $LESS_CMD ]]; then
			options=' -~'
			[[ $wraplines = false ]] && options+='S'
			[[ $showlinenumbers = true ]] && options+='N'
			${LESS_CMD}${options} "$filename"

			return
		fi
	fi

	if [[ -e $CAT_CMD ]]; then
		[[ $showlinenumbers = true ]] && options+=' --number'
		${CAT_CMD}${options} "$filename"

		return
	elif [[ -e $MORE_CMD ]]; then
		$MORE_CMD "$filename"

		return
	fi

	# and, when there's really no-better option ...

	echo "$(<$1)"

	}

PasteLogLast()
	{

	local link=''

	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail

	if [[ -e $r_session_last_pathfile ]]; then
		if Quiz "Press 'Y' to post the most-recent session in your $(ShowAsTitleName) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "upload $(ShowAsTitleName) log"

			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$r_session_last_pathfile" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(ShowAsTitleName) log is now online at $(ShowAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(ShowAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_action_results_zero=false

			return 1
		fi
	else
		ShowAsError 'no last session log found'
	fi

	return 0

	}

PasteLogTail()
	{

	local link=''

	DisableDebugToArchiveAndFile
	ExtractTailFromLog

	if [[ -e $r_session_tail_pathfile ]]; then
		if Quiz "Press 'Y' to post the most-recent $(FormatAsThous "$r_log_tail_lines") lines in your $(ShowAsTitleName) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "upload $(ShowAsTitleName) log"

			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$r_session_tail_pathfile" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(ShowAsTitleName) log is now online at $(ShowAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(ShowAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_action_results_zero=false

			return 1
		fi
	else
		ShowAsError 'no session log tail found'
	fi

	return 0

	}

GetLogSessStartLine()
	{

	# Inputs:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*started:' "$r_session_tail_pathfile" | $TAIL_CMD -n${1:-1} | head -n1 | cut -d':' -f1)-1))
	[[ $linenum -lt 1 ]] && linenum=1
	printf '%s' "$linenum"

	}

GetLogSessFinishLine()
	{

	# Inputs:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*finished:' "$r_session_tail_pathfile" | $TAIL_CMD -n${1:-1} | cut -d':' -f1)+2))
	[[ $linenum -eq 2 ]] && linenum=3
	printf '%s' "$linenum"

	}

ArchiveActiveSessLog()
	{

	[[ -n ${sess_active_pathfile:-} && -e $sess_active_pathfile ]] && $CAT_CMD "$sess_active_pathfile" >> "$r_session_archive_pathfile"

	}

ArchivePriorSessLogs()
	{

	# Check for incomplete previous session logs (crashed, interrupted?) and save to archive.

	local f=''

	for f in "$r_this_package_path"/session.*.active.log; do
		if [[ -f $f && $f != "$sess_active_pathfile" ]]; then
			$CAT_CMD "$f" >> "$r_session_archive_pathfile"
			rm -f "$f" 2> /dev/null
		fi
	done

	}

ResetActiveSessLog()
	{

	rm -f "$sess_active_pathfile" 2> /dev/null

	}

ExtractPrevSessFromTail()
	{

	local -i end_line=0
	local -i old_session=1
	local -i old_session_limit=12		# Don't try to find "started:" further back than this many sessions.
	local -i start_line=0

	ExtractTailFromLog

	if [[ -e $r_session_tail_pathfile ]]; then
		end_line=$(GetLogSessFinishLine "$old_session")
		start_line=$((end_line+1))		# Ensure an invalid condition, to be solved by the loop.

		while [[ $start_line -ge $end_line ]]; do
			start_line=$(GetLogSessStartLine "$old_session")

			((old_session++))
			[[ $old_session -gt $old_session_limit ]] && break
		done

		$SED_CMD "$start_line,$end_line!d" "$r_session_tail_pathfile" > "$r_session_last_pathfile"
	else
		rm -f "$r_session_last_pathfile" 2> /dev/null
	fi

	return 0

	}

ExtractTailFromLog()
	{

	if [[ -e $r_session_archive_pathfile ]]; then
		$TAIL_CMD -n${r_log_tail_lines} "$r_session_archive_pathfile" > "$r_session_tail_pathfile"	# Trim main log first so there's less to `grep`.
	else
		rm -f "$r_session_tail_pathfile" 2> /dev/null
	fi

	return 0

	}

InitForkCounts()
	{

	# Create directories so async processes can be monitored.

	MakePath "$r_action_forks_count" 'action forks'
	proc_counts_path=$($MKTEMP_CMD -d "$r_action_forks_count"/"${FUNCNAME[1]}"_XXXXXX)
	[[ -n ${proc_counts_path:?undefined proc counts path} ]] || return

	EraseForkCountPaths

	proc_fork_count_path=$proc_counts_path/fork.count
	proc_ok_count_path=$proc_counts_path/ok.count
	proc_skip_count_path=$proc_counts_path/skip.count
	proc_skip_ok_count_path=$proc_counts_path/skip.ok.count
	proc_skip_error_count_path=$proc_counts_path/skip.error.count
	proc_skip_abort_count_path=$proc_counts_path/skip.abort.count
	proc_fail_count_path=$proc_counts_path/fail.count

	mkdir -p "$proc_fork_count_path"
	mkdir -p "$proc_ok_count_path"
	mkdir -p "$proc_skip_count_path"
	mkdir -p "$proc_skip_ok_count_path"
	mkdir -p "$proc_skip_error_count_path"
	mkdir -p "$proc_skip_abort_count_path"
	mkdir -p "$proc_fail_count_path"

	InitProgress

	}

IncForkProgressIndex()
	{

	local a

	((progress_index++))
	printf -v a '%02d' "$progress_index"

	proc_fork_pathfile=$proc_fork_count_path/$a
	proc_ok_pathfile=$proc_ok_count_path/$a
	proc_skip_pathfile=$proc_skip_count_path/$a
	proc_skip_ok_pathfile=$proc_skip_ok_count_path/$a
	proc_skip_error_pathfile=$proc_skip_error_count_path/$a
	proc_skip_abort_pathfile=$proc_skip_abort_count_path/$a
	proc_fail_pathfile=$proc_fail_count_path/$a

	}

RefreshForkCounts()
	{

	fork_count=$(ls -A -1 "$proc_fork_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	ok_count=$(ls -A -1 "$proc_ok_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_count=$(ls -A -1 "$proc_skip_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_ok_count=$(ls -A -1 "$proc_skip_ok_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_error_count=$(ls -A -1 "$proc_skip_error_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	skip_abort_count=$(ls -A -1 "$proc_skip_abort_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')
	fail_count=$(ls -A -1 "$proc_fail_count_path" 2> /dev/null | $WC_CMD -l | $SED_CMD 's|^ *||')

	} &> /dev/null

EraseForkCountPaths()
	{

	ClearPath /var/run/sherpa/actions/forks "$proc_counts_path"
	[[ -e $r_action_abort_pathfile ]] && rm -f "$r_action_abort_pathfile"

	} &> /dev/null

InitProgress()
	{

	progress_index=0
	prev_clean_msg=''

	RefreshForkCounts

	}

UpdateForkProgress()
	{

	# All input vars are global.

	local a=''
	local b=''

	RefreshForkCounts
	[[ $useropt_verbose = false && ! -e $r_display_inhibit_pathfile ]] || return		# Don't display progress, it's difficult to read with so-many other writes to the screen.

	a=$((skip_count+skip_ok_count+skip_error_count+skip_abort_count))
	b=$(PercFrac "$ok_count" "$a" "$fail_count" "$total_count")

	if [[ $ok_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightGreen "$ok_count") OK"
	fi

	if [[ $a -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightOrange "$a") skipped"
	fi

	if [[ $fail_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightRed "$fail_count") failed"
	fi

	if [[ $fork_count -gt 0 ]]; then
		[[ -n $b ]] && b+=', '
		b+="$(TextBrightYellow "$fork_count") in-progress"
	fi

	[[ -n $b && ! -e $r_display_inhibit_pathfile ]] && ShowAsProc "${fork_progress_prefix:-}" "$b"

	return 0

	} >&2

ShowQPKGsMissing()
	{

	# Check installed QPKGs and check if they're missing. If so, advise on-screen.

	# Outputs:
	#	$? = 0 if no packages are missing
	#	$? = 1 if one-or-more packages are missing

	! QPKGs.AClist.ISmissing.IsSet || return 0
	! QPKGs.ACreinstall.ISmissing.IsSet || return 0

	local a=''
	local b=''
	local c=''
	local -i i=0
	local name_limit=2
	local -a packages=()

	if [[ $(QPKGs-ISmissing:Count) -eq 0 ]]; then
		return 0
	else
		packages+=($(QPKGs-ISmissing:Array))
	fi

	# shellcheck disable=2322
	for ((i=0; i<=((${#packages[@]}-1)); i++)); do
		a+=$(TextBrightRed "${packages[$i]}")

		if [[ $((i+1)) -ge $name_limit && $((${#packages[@]}-name_limit)) -gt 0 ]]; then
			a+=" & $(TextBrightRed "$((${#packages[@]}-name_limit))") other$(Pluralise "$((${#packages[@]}-name_limit))")"
			break
		elif [[ $((i+2)) -lt ${#packages[@]} ]]; then
			a+=', '
		elif [[ $((i+2)) -eq ${#packages[@]} ]]; then
			a+=' & '
		fi
	done

	if [[ ${#packages[@]} -eq 1 ]]; then
		b=' is'
		c='it'
	else
		b='s are'
		c='them'
	fi

	ShowAsNote "the $a QPKG${b} missing or broken. Please reinstall $c"

	return 1

	}

ShowQPKGsNewVers()
	{

	# Check installed QPKGs and compare versions against upgradable array. If new versions are available, advise on-screen.

	# Outputs:
	#	$? = 0 if all packages are up-to-date
	#	$? = 1 if one-or-more packages can be upgraded

	! QPKGs.AClist.ISupgradable.IsSet || return 0
	! QPKGs.ACupgrade.ISupgradable.IsSet || return 0

	local a=''
	local b=''
	local c=''
	local -i i=0
	local name_limit=2
	local -a packages=()

	if [[ $(QPKGs-ISupgradable:Count) -eq 0 ]]; then
		return 0
	else
		packages+=($(QPKGs-ISupgradable:Array))
	fi

	# shellcheck disable=2322
	for ((i=0; i<=((${#packages[@]}-1)); i++)); do
		a+=$(TextBrightOrange "${packages[$i]}")

		if [[ $((i+1)) -ge $name_limit && $((${#packages[@]}-name_limit)) -gt 0 ]]; then
			a+=" & $(TextBrightOrange "$((${#packages[@]}-name_limit))") other$(Pluralise "$((${#packages[@]}-name_limit))")"
			break
		elif [[ $((i+2)) -lt ${#packages[@]} ]]; then
			a+=', '
		elif [[ $((i+2)) -eq ${#packages[@]} ]]; then
			a+=' & '
		fi
	done

	if [[ ${#packages[@]} -eq 1 ]]; then
		b='a '
		c='version is'
	else
		c="version$(Pluralise "${#packages[@]}") are"
	fi

	ShowAsNote "${b}new QPKG $c available for $a"

	return 1

	}

CheckQPKGsConflicts()
	{

	[[ $run_package_actions = false ]] || return 0

	local a=''

	if [[ -n ${r_base_qpkg_conflicts_with:-} ]]; then
		# shellcheck disable=2068
		for a in "${r_base_qpkg_conflicts_with[@]}"; do
			if QpkgIsInstalledEnabled "$a"; then
				ShowAsError "the '$a' QPKG is enabled. $(ShowAsTitleName) is incompatible with this package. Please consider stopping this QPKG in your App Center"
				run_package_actions=false

				return 1
			fi
		done
	fi

	return 0

	}

CheckQPKGsWarnings()
	{

	local a=''

	if [[ -n ${r_base_qpkg_warnings:-} ]]; then
		# shellcheck disable=2068
		for a in "${r_base_qpkg_warnings[@]}"; do
			if QpkgIsInstalledEnabled "$a"; then
				ShowAsWarn "the '$a' QPKG is enabled. This may cause problems with $(ShowAsTitleName) applications. Please consider stopping this QPKG in your App Center"

				return 1
			fi
		done
	fi

	return 0

	}

ListQPKGsActions()
	{

	[[ $useropt_debug = true ]] || return

	FuncInit

	local a=''
	local b=''
	local border_shown=false

	for a in "${r_qpkg_actions[@]}"; do
		for b in ok er sk so se sa; do
			if QPKGs-AC${a}-${b}.IsAny; then
				if [[ $border_shown = false ]]; then
					DebugInfoMinSepr
					border_shown=true
				fi

				case $b in
					ok|sk|so)
						DebugQpkg info "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
						;;
					se|sa)
						DebugQpkg warning "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
						;;
					er)
						DebugQpkg error "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "
				esac
			fi
		done
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr

	FuncExit

	}

ListQPKGsActionsAll()																						#devdebug
	{																										#devdebug

	# Only used when debugging.																				#devdebug

	FuncInit																								#devdebug

	local a=''																								#devdebug
	local b=''																								#devdebug
	DebugInfoMinSepr																						#devdebug

	for a in "${r_qpkg_actions[@]}"; do																		#devdebug
		for b in to ok er sk so se sa; do																	#devdebug
			if QPKGs-AC${a}-${b}.IsAny; then																#devdebug
				DebugQpkg info "AC${a}-${b}" "($(QPKGs-AC${a}-${b}:Count)) $(QPKGs-AC${a}-${b}:ListCSV) "	#devdebug
			fi																								#devdebug
		done																								#devdebug
	done																									#devdebug

	DebugInfoMinSepr																						#devdebug

	FuncExit																								#devdebug

	}																										#devdebug

ListIPKsActions()
	{

	[[ $useropt_debug = true ]] || return

	FuncInit

	local a=''
	local border_shown=false

	for a in "${r_ipk_actions[@]}"; do
		if IPKs-AC${a}-ok.IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk info "AC${a}-ok" "($(IPKs-AC${a}-ok:Count)) $(IPKs-AC${a}-ok:ListCSV) "
		fi

		if IPKs-AC${a}-er.IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk error "AC${a}-er" "($(IPKs-AC${a}-er:Count)) $(IPKs-AC${a}-er:ListCSV) "
		fi
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr

	FuncExit

	}

ListPIPsActions()
	{

	[[ $useropt_debug = true ]] || return

	FuncInit

	local a=''
	DebugInfoMinSepr

	for a in "${r_pip_actions[@]}"; do
		PIPs-AC${a}-ok.IsAny && DebugPipInfo "AC${a}-ok" "($(PIPs-AC${a}-ok:Count)) $(PIPs-AC${a}-ok:ListCSV) "
		PIPs-AC${a}-er.IsAny && DebugPipError "AC${a}-er" "($(PIPs-AC${a}-er:Count)) $(PIPs-AC${a}-er:ListCSV) "
	done

	DebugInfoMinSepr

	FuncExit

	}

ListQPKGsStates()
	{

	[[ $useropt_debug = true ]] || return

	FuncInit

	local a=''

	BuildQPKGsStates
	DebugInfoMinSepr

	for a in "${r_qpkg_is_states[@]}" "${r_qpkg_service_results[@]}"; do
		[[ $a = installed ]] && continue

		if [[ $a = unknown ]]; then
			QPKGs-IS${a}.IsAny && DebugQpkg warning "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
		else
			QPKGs-IS${a}.IsAny && DebugQpkg info "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
		fi
	done

	for a in "${r_qpkg_isnt_states[@]}" "${r_qpkg_service_results[@]}"; do
		[[ $a = installed ]] && continue

		if [[ $a = ok ]]; then
			QPKGs-ISNT${a}.IsAny && DebugQpkg error "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		elif [[ $a = backedup ]]; then
			QPKGs-ISNT${a}.IsAny && DebugQpkg warning "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		else
			QPKGs-ISNT${a}.IsAny && DebugQpkg info "ISNT${a}" "($(QPKGs-ISNT${a}:Count)) $(QPKGs-ISNT${a}:ListCSV) "
		fi
	done

	for a in "${r_qpkg_states_transient[@]}"; do
		# shellcheck disable=2043
		QPKGs-IS${a}.IsAny && DebugQpkg info "IS${a}" "($(QPKGs-IS${a}:Count)) $(QPKGs-IS${a}:ListCSV) "
	done

	DebugInfoMinSepr

	FuncExit

	}

BuildQPKGsTiers()
	{

	FuncInit

	# There are three tiers of package: `independent`, `auxiliary` and `dependent`.
	# ... but only two tiers of QPKG: `independent` and `dependent`.

	# `independent` QPKGs don't depend-on other QPKGs, but may be required for other QPKGs. They should be installed/activated before any `dependent` QPKGs.
	# `dependent` QPKGs depend-on other QPKGs. They should be installed/activated after all `independent` QPKGs.

	if [[ ${qpkgs_tiers_built:=false} = true ]]; then
		DebugAsDone "don't build tiers: they're already built"

		FuncExit; return
	fi

	local previous=''

	if [[ ! -e $r_dependent_qpkgs_list_pathfile || ! -e $r_independent_qpkgs_list_pathfile ]]; then
		ShowAsProc tiers
		rm -f "$r_dependent_qpkgs_list_pathfile" "$r_independent_qpkgs_list_pathfile" 2> /dev/null

		for qpkg_name in "${r_qpkg_name[@]}"; do
			[[ $previous = "$qpkg_name" ]] && continue || previous=$qpkg_name
			QpkgSetIndex

			if QpkgIsDatabaseDependent; then
				echo "$qpkg_name" >> "$r_dependent_qpkgs_list_pathfile"
			else
				echo "$qpkg_name" >> "$r_independent_qpkgs_list_pathfile"
			fi
		done

		qpkgs_tiers_built=true
	fi

	[[ -e $r_dependent_qpkgs_list_pathfile ]] && QPKGs-GRdependent:Add "$(<$r_dependent_qpkgs_list_pathfile)"
	[[ -e $r_independent_qpkgs_list_pathfile ]] && QPKGs-GRindependent:Add "$(<$r_independent_qpkgs_list_pathfile)"

	FuncExit

	}

InitQPKGsTiers()
	{

	rm -f "$r_dependent_qpkgs_list_pathfile" "$r_independent_qpkgs_list_pathfile" 2> /dev/null
	qpkgs_tiers_built=false

	}

BuildQPKGsStates()
	{

	# Build several lists of QPKGs:
	#   - installed/not.
	#   - installable/not.
	#   - upgradable/not.
	#   - enabled/disabled.
	#   - have backup files in backup location/not.
	#   - have config blocks in [/etc/config/qpkg.conf], but no files on-disk (missing).
	#   - starting, stopping, or restarting.

	FuncInit

	local a=''
	local b=''

	if [[ ${qpkgs_states_built:=false} = true ]]; then
		DebugAsDone "don't build states: they're already built"

		FuncExit; return
	fi

	LoadPackages
	InitQPKGsStates

	OsIsStarting && ShowAsWarn "$(OsGetQnapOS) is starting all enabled QPKGs $r_chars_ellipsis check again in a few minutes"
	OsIsStopping && ShowAsWarn "$(OsGetQnapOS) is shutting-down and all QPKGs are stopping"

	if OsIsLoadAverageInsane; then
		ShowAsWarn 'the NAS has an exceptionally-high system-load, recommend aborting and trying again later'
	elif OsIsLoadAverageHigh; then
		ShowAsWarn 'the NAS has an unusually-high system-load, so this may take a while'
	elif OsIsLoadAverageElevated; then
		ShowAsNote 'the NAS has an elevated system-load, so this may take a little longer than usual'
	fi

	ShowAsProc 'QPKG states'

	# Faster to launch several concurrent loops async, than a single loop. Launch those requiring more processing-time first.

	# This one should only be run when actioning 'installable' QPKGs.

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsInstallable; then
			echo installable
		else
			echo notinstallable
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsInstalledMissing; then
			echo missing
		else
			echo notmissing
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsUpgradable; then
			echo upgradable
		else
			echo notupgradable
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsInstalled; then
			if QpkgIsInstalledEnabled; then
				echo enabled
			else
				echo notenabled
			fi
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsInstalled; then
			echo installed
		elif QpkgIsNtReallyInstalled; then
			echo notinstalled
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

	# This one should only be run when actioning 'rebuild' or 'restore'.

# 	time for qpkg_name in $(QPKGs-GRall:Array); do
	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgSetIndex

		if QpkgIsBackupExist; then
			echo backedup
		else
			echo notbackedup
		fi >> "$r_qpkg_states_path/$qpkg_name"
# 	done #&
	done &

	wait 2> /dev/null

	# Load status lines from individual files.

	for qpkg_name in $(QPKGs-GRall:Array); do
		a=/var/log/$qpkg_name.action
		b=/var/log/$qpkg_name.result

		if [[ -e $a && -e $b ]]; then
			case $(<$b) in
				in-progress)
					case $(<$a) in
						start)
							QPKGs-ISstarting:Add "$qpkg_name"
							;;
						restart)
							QPKGs-ISrestarting:Add "$qpkg_name"
							;;
						stop)
							QPKGs-ISstopping:Add "$qpkg_name"
					esac
					;;
				ok)
					QPKGs-ISok:Add "$qpkg_name"
					;;
				failed)
					QPKGs-ISNTok:Add "$qpkg_name"
			esac
		fi

		a=$r_qpkg_states_path/$qpkg_name
		[[ -e $a ]] || continue

		for b in $(<$a); do
			case $b in
				backedup)
					QPKGs-ISbackedup:Add "$qpkg_name"
					;;
				notbackedup)
					QPKGs-ISNTbackedup:Add "$qpkg_name"
					;;
				backupable)
					: # ignore for now.
					;;
				notbackupable)
					: # ignore for now.
					;;
				enabled)
					QPKGs-ISenabled:Add "$qpkg_name"
					;;
				notenabled)
					QPKGs-ISNTenabled:Add "$qpkg_name"
					;;
				installable)
					QPKGs-ISinstallable:Add "$qpkg_name"
					;;
				notinstallable)
					QPKGs-ISNTinstallable:Add "$qpkg_name"
					;;
				installed)
					QPKGs-ISinstalled:Add "$qpkg_name"
					;;
				notinstalled)
					QPKGs-ISNTinstalled:Add "$qpkg_name"
					;;
				missing)
					QPKGs-ISmissing:Add "$qpkg_name"

					# Also mark as not OK.
					QPKGs-ISok:Remove "$qpkg_name"
					QPKGs-ISNTok:Add "$qpkg_name"
					;;
				notmissing)
					QPKGs-ISNTmissing:Add "$qpkg_name"
					;;
				upgradable)
					QPKGs-ISupgradable:Add "$qpkg_name"
					;;
				notupgradable)
					QPKGs-ISNTupgradable:Add "$qpkg_name"
			esac
		done
	done

	qpkgs_states_built=true
	ShowQPKGsMissing
	ShowQPKGsNewVers

	FuncExit

	}

InitQPKGsStates()
	{

	# Clears in-memory state list objects

	LoadObjects || return

	FuncInit

	local a=''

	DebugAsProc 'initialising state lists'

	for a in "${r_qpkg_is_states[@]:-}" "${r_qpkg_states_transient[@]:-}"; do
		[[ $a = active ]] && continue		# don't reset.
		QPKGs-IS${a}:Init
	done

	for a in "${r_qpkg_isnt_states[@]:-}"; do
		[[ $a = active ]] && continue		# don't reset.
		QPKGs-ISNT${a}:Init
	done

	ClearPath /var/run/sherpa/packages "$r_qpkg_states_path"

	DebugAsDone 'initialised state lists'
	qpkgs_states_built=false

	FuncExit

	}

BuildQPKGsIsCanBackup()
	{

	# Build a list of QPKGs that support `backup` and `restore` actions.

	FuncInit

	local qpkg_name=''

	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgIsDatabaseCanBackup "$qpkg_name" && QPKGs-GRcanbackup:Add "$qpkg_name"
	done

	FuncExit

	}

BuildQPKGsIsCanRestartToUpdate()
	{

	# Build a list of QPKGs that support application update on QPKG restart.

	FuncInit

	local qpkg_name=''

	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgIsDatabaseCanRestartToUpdate "$qpkg_name" && QPKGs-GRcanrestarttoupdate:Add "$qpkg_name"
	done

	FuncExit

	}

BuildQPKGsIsCanClean()
	{

	# Build a list of QPKGs that support `clean` actions.

	FuncInit

	local qpkg_name=''

	for qpkg_name in $(QPKGs-GRall:Array); do
		QpkgIsDatabaseCanClean "$qpkg_name" && QPKGs-GRcanclean:Add "$qpkg_name"
	done

	FuncExit

	}

QPKGs.IsTimeoutsIncreased()
	{

	[[ -e /usr/local/sbin/qpkg_service.orig ]]

	}

HelpAbbreviations()
	{

	FuncInit

	local a=''
	local f=''
	local -i m=0
	local -i n=0

	LoadPackages
	DisableDebugToArchiveAndFile
	DisplayProcReport abbreviations
	ResetReportsPath &> /dev/null

		{

		ShowHelpBasic
		DisplayAsHelpTitle "$(ShowAsTitleName) can recognise various abbreviations and aliases as $(ShowAsPackages)."

		} > "$r_report_output_pathfile"

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'QPKG name:|Installed?|Acceptable QPKG name abbreviations and aliases:'
	else
		printf -v a '\n%s\n' "$(GenerateAbsReportTitleLine)"
	fi

	for qpkg_name in $(QPKGs-GRall:Array); do
		((n++))
		QpkgSetIndex
		GenerateAbsReportDataLine > "$r_reports_path/$n" &
	done

	m=$n
	wait 2> /dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi >> "$r_report_output_pathfile"

# 		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

	DisplayAsProjSynExam "example: to install $(ShowAsPackageName SABnzbd), $(ShowAsPackageName Mylar3) and $(ShowAsPackageName nzbToMedia) all-at-once" 'install sab my nzb2' >> "$r_report_output_pathfile"

	EraseThisLine
	ShowReport
	ListQPKGsStates

	FuncExit

	}

ShowReportBackups()
	{

	FuncInit

	local a=''
	local epoch_time=0		# Allow float as seconds have a fractional component.
	local -i file_bytes=0
	local file_date=''
	local file_name=''
	local file_time=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport backups
	ResetReportsPath &> /dev/null

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'Backup file:|Size in bytes:|Backup date:'
	else
		printf -v a '\n%s\n' "$(GenerateBacksReportTitleLine)"
	fi

	if [[ -e $GNU_FIND_CMD ]]; then				# Prefer GNU `find` for this.
		while read -r epoch_time file_name file_bytes; do
			[[ -z $epoch_time || -z $file_name ]] && break

			((n++))
			GenerateBacksReportItemLine "$epoch_time" "$file_name" "$file_bytes" "$r_report_highlight_backups_older_than" > "$r_reports_path/$n" &
		done <<< "$($GNU_FIND_CMD "$r_qpkg_bu_path"/*.config.tar.gz -maxdepth 1 -printf '%C@ %f %s\n' 2> /dev/null | $SORT_CMD)"
	else										# If GNU `find` isn't available, do-it the hard-way.
		while read -r file_date file_time file_name file_bytes; do
			[[ -z $file_date || -z $file_name ]] && break
			epoch_time=$(/bin/date -d "$file_date $file_time" +"%s")
			file_name=$($BASENAME_CMD "$file_name")

			((n++))
			GenerateBacksReportItemLine "$epoch_time" "$file_name" "$file_bytes" "$r_report_highlight_backups_older_than" > "$r_reports_path/$n" &
		done <<< "$(cd "$r_qpkg_bu_path" && ls -l1tr --time-style=+"%Y-%m-%d %H:%M:%S" ./*.config.tar.gz 2> /dev/null | $AWK_CMD '{print $6" "$7" "$8" "$5}')"
	fi

	m=$n
	wait 2> /dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi > "$r_report_output_pathfile"

		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

	EraseThisLine
	ShowReport

	FuncExit

	}

ShowReportDependencies()
	{

	FuncInit

	local a=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport dependency
	ResetReportsPath &> /dev/null

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'QPKG name:|Dependencies:|Installed?|Enabled?|Managed?|Min. RAM:|Min. OS:|Max. OS:|Supported arch?|Installed QPKG author:'
	else
		printf -v a '\n%s\n' "$(GenerateDepsReportTitleLine)"
	fi

	for qpkg_name in $(QPKGs-GRall:Array); do
		((n++))
		QpkgSetIndex
		GenerateDepsReportDataLine > "$r_reports_path/$n" &
	done

	m=$n
	wait 2> /dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi > "$r_report_output_pathfile"

		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

	EraseThisLine
	ShowReport
	ListQPKGsStates

	FuncExit

	}

ShowReportFeatures()
	{

	FuncInit

	local a=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport features
	ResetReportsPath &> /dev/null

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'QPKG name:|CanBack?|CanClean?|StartUpd?|AutoUpd?|LiveTest?|Indep?|ArchCompat?|Enhanced?|UniqueUnpack?'
	else
		printf -v a '\n%s\n' "$(GenerateFeaturesReportTitleLine)"
	fi

	for qpkg_name in $(QPKGs-GRall:Array); do
		((n++))
		QpkgSetIndex
		GenerateFeaturesReportDataLine > "$r_reports_path/$n" &
	done

	m=$n
	wait 2> /dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi > "$r_report_output_pathfile"

		GenerateReportHeadingsFooter >> "$r_report_output_pathfile"
	fi

	EraseThisLine
	ShowReport
	ListQPKGsStates

	FuncExit

	}

ShowReportPackages()
	{

	FuncInit

	local a=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport package

		{

		ShowHelpBasic
		DisplayAsHelpTitle "one-or-more $(ShowAsPackages) may be specified at-once."

		} > "$r_report_output_pathfile"

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'QPKG name:|Appl. version:|Description:'
	else
		printf -v a '\n%s\n' "$(GeneratePacksReportTitleLine)"
	fi

	for qpkg_name in $(QPKGs-GRall:Array); do
		((n++))
		QpkgSetIndex
		GeneratePacksReportDataLine "$qpkg_name" > "$r_reports_path/$n" &
	done

	m=$n

	# Load report data lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi >> "$r_report_output_pathfile"

		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

		{

		DisplayAsProjSynExam "abbreviations and aliases may also be used to specify $(ShowAsPackages). To list these" 'help abs'
		DisplayAsProjSynIndentExam '' a

		} >> "$r_report_output_pathfile"

	EraseThisLine
	ShowReport

	FuncExit

	}

ShowReportRepos()
	{

	FuncInit

	local a=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport repository
	ResetReportsPath &> /dev/null

	if OsIsSupportAutowidthTableColumns; then
		printf -v a '\n%s\n' 'QPKG name:|Repository:|Install date:'
	else
		printf -v a '\n%s\n' "$(GenerateReposReportTitleLine)"
	fi

	for qpkg_name in $(QPKGs-GRall:Array); do
		((n++))
		QpkgSetIndex
		GenerateReposReportDataLine > "$r_reports_path/$n" &
	done

	m=$n
	wait 2> /dev/null

	# Load report data lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		[[ -e $f ]] && printf -v a '%s\n' "$a$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s' "$a"
		fi > "$r_report_output_pathfile"

		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

	EraseThisLine
	ShowReport
	ListQPKGsStates

	FuncExit

	}

ShowReportStatuses()
	{

	FuncInit

	local a=false
	local b=''
	local c=''
	local f=''
	local -i m=0
	local -i n=0

	DisableDebugToArchiveAndFile
	DisplayProcReport status
	ResetReportsPath &> /dev/null

	for qpkg_name in $(QPKGs-GRall:Array); do
		QPKGs-ACstatus-dn.Exist "$qpkg_name" || continue
		((n++))
		QpkgSetIndex
		QPKGs-ISupgradable.Exist "$qpkg_name" && a=true
		GenerateStatusReportDataLine > "$r_reports_path/$n" &
	done

	if OsIsSupportAutowidthTableColumns; then
		[[ $a = true ]] && b=" ($(TextBrightOrange new))"
		printf -v c '\n%s\n' "QPKG name:|Status:|Previous action (result):|QPKG version${b}:|Appl. version:|Location:"
	else
		printf -v c '\n%s\n' "$(GenerateStatusReportTitleLine)"
	fi

	m=$n
	wait 2> /dev/null

	# Load report lines from individual files.

	for ((n=1; n<=m; n++)); do
		f="$r_reports_path/$n"
		# shellcheck disable=2179
		[[ -e $f ]] && printf -v c '%s\n' "$c$(<$f)"		# Add newline to each imported report line.
	done

	if [[ -n $c ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$c" | Tableise
		else
			printf '%s' "$c"
		fi > "$r_report_output_pathfile"

		GenerateReportFooter >> "$r_report_output_pathfile"
	fi

	EraseThisLine
	ShowReport
	ListQPKGsStates

	show_action_results_ok=false
	show_action_results_skipped=false
	show_action_results_failed=false

	FuncExit

	}

ShowReportAllActionResults()
	{

	local -i a=0
	local -i b=0
	local -i c=0
	local -i d=0
	local -i e=0
	local action=''
	local -i datetime=0
	local -i duration=0
	local package_name=''
	local package_type=''
	local -i quantity=0
	local reason=''
	local result=''

	if [[ $useropt_show_previous_action_results_report = true ]]; then
		show_action_results_failed=true
		show_action_results_ok=true
		show_action_results_skipped=true
	fi

	if [[ -e $r_session_action_results_pathfile ]]; then
		while IFS='|' read -r datetime action quantity package_name package_type result duration reason; do
			if [[ $datetime -gt 0 && $duration -gt 0 ]]; then
				[[ $a -eq 0 ]] && a=$datetime		# Only use first entry as start time.
				b=$datetime
				c=$duration
				((d++))
			fi
		done < "$r_session_action_results_pathfile"

		a=$(ConvertMillisecondsToSeconds "$a")
		b=$(ConvertMillisecondsToSeconds "$b")
		c=$(ConvertMillisecondsToSeconds "$c")

		[[ $b -gt 0 ]] && e=$((b+c+1))		# Use last non-zero iteration of $datetime as beginning of last action, then add duration to it.

		if [[ $show_action_results_ok = true || $show_action_results_skipped = true || $show_action_results_failed = true || $show_action_results_zero = true ]]; then
			{

			DisplayAsHelpTitle "package action$(Pluralise "$d") started @ $(ConvertSecondsToTime "$a"), ended @ $(ConvertSecondsToTime "$e"), elapsed = $(ConvertSecondsToDuration "$(CalcAmountDiff "$a" "$e")")"

			[[ $show_action_results_ok = true ]] && ShowReportActionResults ok
			[[ $show_action_results_skipped = true ]] && ShowReportActionResults skipped
			[[ $show_action_results_failed = true ]] && ShowReportActionResults failed
			[[ $show_action_results_zero = true ]] && ShowZeroQpkgs

			} > "$r_report_output_pathfile"

			ShowReport
		fi
	else
		ShowAsError 'previous report results not found'
	fi

	}

ShowReportActionResults()
	{

	# Inputs: (local)
	#	$1 = `ok`, `skipped`, `failed`

	# Inputs: (global)
	#	$r_session_action_results_pathfile

	local action=''
	local -i count=0
	local -i datetime=0
	local -i duration=0
	local package_name=''
	local package_type=''
	local -i quantity=0
	local reason=''
	local result=''

	if [[ -e $r_session_action_results_pathfile ]]; then
		# Obtain count of same results. Need to know if action applied to one QPKG or many.

		while IFS='|' read -r datetime action quantity package_name package_type result duration reason; do
			if [[ $result = "$1" ]] || [[ $1 = skipped && ($result = 'skipped-ok' || $result = 'skipped-error' || $result = 'skipped-abort') ]]; then
				[[ $action = status && $useropt_show_previous_action_results_report = false ]] && continue		# Don't need to see the result of `status` checks unless a 'results' report has been requested.
				((count++))
				[[ $count -gt 1 ]] && break			# Two-or-more of the same action so must pluralise messages.
			fi
		done < "$r_session_action_results_pathfile"

		# Display action titles and QPKGs.

		if [[ $count -eq 1 ]]; then
			case $1 in
				ok)
					DisplayAsHelpTitle "this package action completed $(TextBrightGreen OK):"
					;;
				skipped)
					DisplayAsHelpTitle "this package action was $(TextBrightOrange skipped) (and why):"
					;;
				failed)
					DisplayAsHelpTitle "this package action $(TextBrightRed failed) (and why):"
			esac
		elif [[ $count -gt 1 ]]; then
			case $1 in
				ok)
					DisplayAsHelpTitle "these package actions completed $(TextBrightGreen OK):"
					;;
				skipped)
					DisplayAsHelpTitle "these package actions were $(TextBrightOrange skipped) (and why):"
					;;
				failed)
					DisplayAsHelpTitle "these package actions $(TextBrightRed failed) (and why):"
			esac
		fi

		if [[ $count -ge 1 ]]; then
			while IFS='|' read -r datetime action quantity package_name package_type result duration reason; do
				if [[ $result = "$1" ]] || [[ $1 = skipped && ($result = 'skipped-ok' || $result = 'skipped-error' || $result = 'skipped-abort') ]]; then
					[[ $action = status && $useropt_show_previous_action_results_report = false ]] && continue		# Don't need to see the result of `status` checks unless a 'results' report has been requested.
					ShowAsActionLogDetail "$datetime" "$package_name" "$action" "$result" "$duration" "$reason" "$package_type" "$quantity"
				fi
			done < "$r_session_action_results_pathfile"
		fi
	fi

	if [[ $count -eq 0 ]]; then
		case $1 in
			ok)
				DisplayAsHelpTitle "no package actions completed $(TextBrightGreen OK)."
				;;
			skipped)
				DisplayAsHelpTitle "no package actions were $(TextBrightOrange skipped)."
				;;
			failed)
				DisplayAsHelpTitle "no package actions $(TextBrightRed failed)."
		esac
	fi

	return 0

	}

GenerateReportFooter()
	{

	[[ $useropt_report_footer = true ]] || return

	DisplayAsHelpTitle 'report information:'

	local a=''

	a=$({
		if [[ -e "$r_report_flags_path"/status-missing ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightRed missing)" 'QPKG is missing from its installation path. Please reinstall it'
		fi

		if [[ -e "$r_report_flags_path"/req-alert ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightRed '!')" 'QPKG is prevented from working correctly'
		fi

		if [[ -e "$r_report_flags_path"/state-disabled ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightRed disabled)" "QPKG won't start at bootup. Enable it first, then start it"
		fi

		if [[ -e "$r_report_flags_path"/result-aborted ]]; then
			DisplayAsIndentQuotedInfoItem "($(TextBrightRed aborted))" 'previous action was aborted'
		fi

		if [[ -e "$r_report_flags_path"/result-failed ]]; then
			DisplayAsIndentQuotedInfoItem "($(TextBrightRed failed))" 'previous action failed'
		fi

		if [[ -e "$r_report_flags_path"/status-inactive ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightRed inactive)" 'application process is dead or not-started. Try starting it'
		fi

		if [[ -e "$r_report_flags_path"/backup-file-old ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightRed '!')" "QPKG backup file was updated more-than $r_report_highlight_backups_older_than."
		fi

		if [[ -e "$r_report_flags_path"/status-upgradable ]]; then
			DisplayAsIndentQuotedInfoItem "($(TextBrightOrange new))" 'an upgraded QPKG version is available'
		fi

		if [[ -e "$r_report_flags_path"/status-wrongauthor ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange 'incompatible author')" "QPKG is a non-compatible, identically-named duplicate of a $(ShowAsTitleName) QPKG"
		fi

		if [[ -e "$r_report_flags_path"/req-attention ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange '*')" "QPKG cannot be managed with $(ShowAsTitleName)"
		fi

		if [[ -e "$r_report_flags_path"/action-pending ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange pending)" 'QPKG is waiting to run an action. Check again shortly'
		fi

		if [[ -e "$r_report_flags_path"/status-stopping ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange stopping)" 'QPKG is stopping. Check again shortly'
		fi

		if [[ -e "$r_report_flags_path"/status-slow ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange slow)" 'application is alive, but was slow to respond to the status request. Check again shortly' 		# More common on NAS with lower installed RAM, and usually because the application has been page-swapped to disk and must be reloaded into RAM.
		fi

		if [[ -e "$r_report_flags_path"/status-starting ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange starting)" 'QPKG is starting. Check again shortly'
		fi

		if [[ -e "$r_report_flags_path"/result-in-progress ]]; then
			DisplayAsIndentQuotedInfoItem "($(TextBrightOrange in-progress))" 'an action is in-progress. Check again shortly'
		fi

		if [[ -e "$r_report_flags_path"/status-unknown ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange unknown)" 'application status could not be determined'
		fi

		if [[ -e "$r_report_flags_path"/repo-other ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightOrange '* URL')" 'another repository is managing this QPKG'
		fi

		if [[ -e "$r_report_flags_path"/state-enabled ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightGreen enabled)" 'QPKG will be started at bootup'
		fi

		if [[ -e "$r_report_flags_path"/result-ok ]]; then
			DisplayAsIndentQuotedInfoItem "($(TextBrightGreen OK))" 'previous action was successful'
		fi

		if [[ -e "$r_report_flags_path"/status-active ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightGreen active)" 'application is alive (and responsive if a daemon)'
		fi

		if [[ -e "$r_report_flags_path"/repo-sherpa ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextBrightGreen sherpa)" "$(ShowAsTitleName) is managing this QPKG"
		fi

		if [[ -e "$r_report_flags_path"/app-dynamic ]]; then
			DisplayAsIndentQuotedInfoItem dynamic 'application version is the latest available'
		fi

		if [[ -e "$r_report_flags_path"/app-static ]]; then
			DisplayAsIndentQuotedInfoItem static 'application version auto-update is disabled or unsupported'
		fi

		if [[ -e "$r_report_flags_path"/app-final ]]; then
			DisplayAsIndentQuotedInfoItem final 'application version is the last available'
		fi

		if [[ -e "$r_report_flags_path"/na ]]; then
			DisplayAsIndentQuotedInfoItem N/A 'not applicable'
		fi

		if [[ -e "$r_report_flags_path"/action-not-found ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextDarkGrey not-found)" 'action tracking files were not found'
		fi

		if [[ -e "$r_report_flags_path"/action-unsupported ]]; then
			DisplayAsIndentQuotedInfoItem "$(TextDarkGrey unsupported)" 'action tracking is unsupported by this QPKG'
		fi
	})

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s\n' "$a"
		fi
	fi

	if [[ -e "$r_report_flags_path"/deps ]]; then
		DisplayAsHelpTitle "QPKG dependencies are automatically installed/started/stopped/restarted as-required by $(ShowAsTitleName)."
	fi

	if compgen -G "${r_report_flags_path}/backup-file-*" > /dev/null; then			# https://stackoverflow.com/a/6364244
		DisplayAsIndentItem "backups are listed oldest-first."
	fi

	if compgen -G "${r_report_flags_path}/backup-file-*" > /dev/null; then			# https://stackoverflow.com/a/6364244
		DisplayAsIndentItem "all $(ShowAsTitleName) backup files are stored here: $r_qpkg_bu_path"
	fi

	}

GenerateReportHeadingsFooter()
	{

	[[ $useropt_report_footer = true ]] || return

	DisplayAsHelpTitle 'column headings:'

	local a=''

	a=$({
		DisplayAsIndentQuotedInfoItem 'CanBack?' "application config 'backup' and 'restore' are supported"
		DisplayAsIndentQuotedInfoItem 'CanClean?' "application 'clean' is supported"
		DisplayAsIndentQuotedInfoItem 'StartUpd?' 'application restart-to-update is supported'
		DisplayAsIndentQuotedInfoItem 'AutoUpd?' 'application restart-to-update is enabled'
		DisplayAsIndentQuotedInfoItem 'LiveTest?' "has a built-in 'status' check, and can test for daemon live status"
		DisplayAsIndentQuotedInfoItem 'Indep?' 'is independent of other QPKGs'
		DisplayAsIndentQuotedInfoItem 'ArchCompat?' 'has a release compatible with this NAS architecture'
		DisplayAsIndentQuotedInfoItem 'Enhanced?' "$(ShowAsTitleName) enhanced service actions are supported"
		DisplayAsIndentQuotedInfoItem 'UniqueUnpack?' 'QPKG unpacks itself to a unique path'
	})

	if [[ -n $a ]]; then
		if OsIsSupportAutowidthTableColumns; then
			printf '%s' "$a" | Tableise
		else
			printf '%s\n' "$a"
		fi
	fi

	}

ShowReport()
	{

	# Inputs: (global)
	#	$r_report_output_pathfile

	if [[ -e $r_report_output_pathfile ]]; then
		DisplayFileInViewport "$r_report_output_pathfile"
		Display
	else
		ShowAsError 'report not found'
	fi

	}

ShowVersionsList()
	{

	DisableDebugToArchiveAndFile
	EraseThisLine

	Display "QPKG: ${r_this_package_ver:-undefined}$([[ $r_this_package_ver != undefined ]] && printf '%s' " ($(ConvertDateCodeToExtendedDate "$r_this_package_ver"))")"
	Display "manager: ${r_this_script_ver:-undefined}$([[ $r_this_script_ver != undefined ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_this_script_epoch"))")"
	Display "loader: ${LOADER_SCRIPT_VERSION:=undefined}$([[ $LOADER_SCRIPT_VERSION != undefined ]] && printf '%s' " ($(ConvertDateCodeToExtendedDate "$LOADER_SCRIPT_VERSION"))")"
	Display "objects: ${r_objects_epoch:-undefined}$([[ $r_objects_epoch != undefined ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_objects_epoch"))")"
	Display "packages: ${r_packages_epoch:-undefined}$([[ $r_packages_epoch != undefined ]] && printf '%s' " ($(ConvertSecondsToFullDate "$r_packages_epoch"))")"

	return 0

	}

ShowQPKGLists()
	{

	[[ ${packages_loaded:=false} = true ]] || return

	local a=''

	for a in "${r_qpkg_is_states[@]}"; do
		case $a in
			downloaded|signed)						# Never show these.
				: # Do nothing.
				;;
			*)
				if QPKGs.AClist.IS${a}.IsSet; then
					ShowQPKGList "IS${a}"
					return
				elif QPKGs.AClist.ISNT${a}.IsSet; then
					ShowQPKGList "ISNT${a}"
					return
				fi
		esac
	done

	for a in "${r_qpkg_is_groups[@]}"; do
		case $a in
			canbackup|canrestarttoupdate)			# Never show these.
				: # Do nothing.
				;;
			*)
				if QPKGs.AClist.GR${a}.IsSet; then
					ShowQPKGList "GR${a}"
					return
				fi
		esac
	done

	for a in "${r_qpkg_isnt_groups[@]}"; do
		case $a in
			all|canbackup|canrestarttoupdate)		# Never show these.
				: # Do nothing.
				;;
			*)
				if QPKGs.AClist.GRNT${a}.IsSet; then
					ShowQPKGList "GRNT${a}"
					return
				fi
		esac
	done

	}

ShowQPKGList()
	{

	# Inputs: (local)
	#	$1 = state or group list object name ('ISbackedup', 'ISNTbackedup', 'GRall', etc...)

	[[ -n $1 ]] || return

	local qpkg_name=''

	DisableDebugToArchiveAndFile
	EraseThisLine

	if [[ $(type -t QPKGs-$1.IsAny) = function ]] && QPKGs-$1.IsAny; then
		for qpkg_name in $(QPKGs-$1:Array); do
			Display "$qpkg_name"
		done
	else
		ShowAsError 'unable to find any matching QPKGs'
	fi

	return 0

	}

SendParentChangeEnv()
	{

	# Send a message into message stream to change a sherpa parent environment variable or variables.
	# This function is only called from within async functions.

	# Inputs: (local)
	#   $1 = action request

	WriteToActionMsgPipe env "$1" '' ''

	}

SendPackageStateChange()
	{

	# Send a message into message stream to change the state of this QPKG to $1 in sherpa parent environment.
	# This might be: `isinstalled`, `isntenabled`, `isstarted`, `scntupgradable`, etc ...
	# This function is only called from within async functions.

	# Inputs: (local)
	#   $1 = action request

	WriteToActionMsgPipe change "$1" package "$qpkg_name"

	}

SendActionStatus()
	{

	# Send a message into message stream to update sherpa parent environment with the status of this action for $qpkg_name.
	# This can be: `ok`, `so`, `sk`, `se`, `er`, `ex`. `ab`.
	# This function is only called from within async functions.

	# Inputs: (local)
	#   $1 = status update

	WriteToActionMsgPipe status "$1" package "$qpkg_name"

	}

WriteToActionMsgPipe()
	{

	# Send a message into message stream to update sherpa parent shell environment.

	# Inputs: (local)
	#	$1 = message 1 key
	#	$2 = message 1 value
	#	$3 = message 2 key
	#	$4 = message 2 value

	# Inputs: (global)
	#	$action_msg_pipe_fd

	[[ $action_msg_pipe_fd != none && -e /proc/$$/fd/$action_msg_pipe_fd ]] && echo "$1|$2|$3|$4" >&$action_msg_pipe_fd

	return 0

	}

ReadFromActionMsgPipe()
	{

	# Inputs: (local)
	#	$1 = message 1 key
	#	$2 = message 1 value
	#	$3 = message 2 key
	#	$4 = message 2 value

	# Inputs: (global)
	#	$action_msg_pipe_fd

	local _msg1_key
	local _msg1_value
	local _msg2_key
	local _msg2_value

	IFS='|' read -r _msg1_key _msg1_value _msg2_key _msg2_value <&$action_msg_pipe_fd

	eval "$1='$_msg1_key' $2='$_msg1_value' $3='$_msg2_key' $4='$_msg2_value'"

	return 0

	}

FindNextFD()
	{

	# Find next available file descriptor: https://stackoverflow.com/a/41603891

	local -i fd=-1

	for fd in {10..100}; do
		if [[ ! -e /proc/$$/fd/$fd ]]; then
			printf '%s' "$fd"

			return 0
		fi
	done

	return 1

	}

MarkThisAcForkAsStarted()
	{

	[[ -n $proc_fork_pathfile ]] && /bin/touch "$proc_fork_pathfile"

	}

MarkThisAcForkAsOk()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_ok_pathfile"
	SendActionStatus ok

	}

MarkThisAcForkAsSkippedOk()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_ok_pathfile"
	SendActionStatus so

	}

MarkThisAcForkAsSkipped()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_pathfile"
	SendActionStatus sk

	}

MarkThisAcForkAsSkippedError()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_error_pathfile"
	SendActionStatus se

	}

MarkThisAcForkAsSkippedAbort()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_abort_pathfile"
	SendActionStatus sa

	}

MarkThisAcForkAsError()
	{

	[[ -n $proc_fork_pathfile && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_fail_pathfile"
	SendActionStatus er

	}

NoteIpkAcAsOk()
	{

	# Move specified IPK name from `to` action array into associated `ok` array.

	# Inputs: (local)
	#   $1 = package name
	#   $2 = action

	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-ok:Add "$1"

	return 0

	}

NoteIpkAcAsEr()
	{

	# Move specified IPK name from `to` action array into associated `er` array.

	# Inputs: (local)
	#   $1 = package name
	#   $2 = action
	#   $3 = reason (optional)

	local a="failing request to $2 $(ShowAsPackageName "$1")"

	[[ -n ${3:-} ]] && a+=" as $3"
	DebugAsError "$a" >&2
	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-er:Add "$1"

	return 0

	}

ModPathToEntware()
	{

	local a=''
	local b=/opt/bin:/opt/sbin

	if QPKGs-ISenabled.Exist Entware; then
		! [[ $PATH =~ $b ]] || return
		a=$($SED_CMD "s|${b}:||" <<< "$PATH:")		# Append colon prior to searching, then remove existing Entware paths.
		export PATH=$b:${a%:}						# ... now prepend Entware paths and remove trailing colon
		DebugAsDone 'prepended Entware to $PATH'
	else
		[[ $PATH =~ $b ]] || return
		a=$($SED_CMD "s|${b}:||" <<< "$PATH:")		# Append colon prior to searching, then remove existing Entware paths.
		export PATH=${a%:}							# ... now remove trailing colon
		DebugAsDone 'removed Entware from $PATH'
	fi

	DebugVar PATH

	return 0

	}

HardwareGetCPUInfo()
	{

	# BusyBox 1.01 doesn't support `grep -m`, so extract first mention the hard-way with `head`.

	if $GREP_CMD -q '^model name' /proc/cpuinfo; then
		$GREP_CMD '^model name' /proc/cpuinfo | head -n1 | $SED_CMD 's|^.*: ||' | tr -s ' '
	elif $GREP_CMD -q '^Processor name' /proc/cpuinfo; then
		$GREP_CMD '^Processor name' /proc/cpuinfo | head -n1 | $SED_CMD 's|^.*: ||' | tr -s ' '
	else
		printf unknown

		return 1
	fi

	return 0

	}

OsGetArch()
	{

	$UNAME_CMD -m

	}

OsGetKernelName()
	{

	# BusyBox 1.01 doesn't support `uname -o` (operating system), so try with `-o` first, then fall-back to default if it fails.

	$UNAME_CMD -o || $UNAME_CMD

	} 2> /dev/null

OsGetKernelVersion()
	{

	$UNAME_CMD -r

	}

OsGetKernelPageSize()
	{

	if [[ -e /sbin/hal_app ]]; then
		/sbin/hal_app --get_pagesize
	else
		$GREP_CMD KernelPageSize /proc/1/smaps | head -n1 | cut -f2 -d':' | tr -d ' '
	fi

	}

HardwareGetPlatform()
	{

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg '' Platform -d undefined -f /etc/platform.conf

	}

UserGetDefVol()
	{

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg SHARE_DEF defVolMP -d undefined -f /etc/config/def_share.info

	}

Python3IsOutdated()
	{

	# Check if Python3 interpreter needs upgrading for this NAS arch.

	# Outputs: (local)
	#   $? = 0 if outdated, !0 if not

	[[ -e $PYTHON3_CMD ]] || return
	installed_ver=$(Python3GetVer "$PYTHON3_CMD")

	[[ $r_nas_arch = armv5tel && ${installed_ver//./} -lt 3114 ]] || [[ $r_nas_arch != armv5tel && ${installed_ver//./} -lt $r_min_python_version ]]

	}

Python3GetVer()
	{

	PythonGetVer "${1:-python3}"

	}

PythonGetVer()
	{

	GetThisBinPath ${1:-python} &> /dev/null && ${1:-python} -V 2>&1 | $SED_CMD 's|^Python ||'

	}

PerlIsOutdated()
	{

	# Check if Perl interpreter needs upgrading for this NAS arch.

	# Outputs: (local)
	#   $? = 0 if outdated, !0 if not

	[[ -e $PERL_CMD ]] || return
	installed_ver=$(PerlGetVer "$PERL_CMD")

	[[ $r_nas_arch = armv5tel && ${installed_ver//./} -lt 5281 ]] || [[ $r_nas_arch != armv5tel && ${installed_ver//./} -lt $r_min_perl_version ]]

	}

PerlGetVer()
	{

	GetThisBinPath ${1:-perl} &> /dev/null && ${1:-perl} -e 'print "$^V\n"' 2> /dev/null | $SED_CMD 's|v||'

	}

GetThisBinPath()
	{

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined binary} ]] && command -v "$1" 2>&1

	}

GetRepoURLFromStoreID()
	{

	# Inputs: (local)
	#	$1 = store ID to lookup repo URL for

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	[[ -n ${1:-} ]] || return

	/sbin/getcfg "$1" u -d undefined -f /etc/config/3rd_pkg_v2.conf

	}

OsGetUptime()
	{

	local n=$(< /proc/uptime)

	ConvertSecondsToDuration "${n%%.*}"

	}

UserGetLIBC()
	{

	local a=$(/sbin/ldd --version | head -n1)
	printf '%s' "${a:4}"			# Trim 'ldd ' from front of string

	}

UserGetLIBCCopyright()
	{

	/sbin/ldd --version | $GREP_CMD -i copyright | $SED_CMD 's|\$||'

	}

ShellGet()
	{

	printf '%s' "${SHELL:-undefined}"

	}

ShellGetVersion()
	{

	[[ -n ${SHELL:-} ]] || printf undefined

	$SHELL --version | head -n1

	}

ShellGetCopyright()
	{

	[[ -n ${SHELL:-} ]] || printf undefined

	$SHELL --version | $GREP_CMD -i copyright | $SED_CMD 's|\$||'

	}

ShellGetTimeIn()
	{

	local n=''

	[[ -n ${LOADER_SCRIPT_PPID:-} ]] && n=$($PS_CMD -o pid,etime | $GREP_CMD $LOADER_SCRIPT_PPID | head -n1)
	FormatAsLongMinutesSecs "${n:6}"

	}

OsGetSysLoadAverages()
	{

	$UPTIME_CMD | $SED_CMD 's|.*load average: ||' | $AWK_CMD -F', ' '{print "1m:"$1", 5m:"$2", 15m:"$3}'

	}

OsGetSysLoad1MinAverage()
	{

	$UPTIME_CMD | $SED_CMD 's|.*load average: ||' | $AWK_CMD -F', ' '{print $1}'

	}

HardwareGetCPUCores()
	{

	local n=$($GREP_CMD -c '^processor' /proc/cpuinfo)

	[[ $n -eq 0 ]] && n=$($GREP_CMD -c '^Processor' /proc/cpuinfo)

	printf '%s' "$n"

	}

HardwareGetInstalledRAM()
	{

	$GREP_CMD MemTotal /proc/meminfo | $SED_CMD 's|.*: ||;s|kB||;s| ||g'

	}

OsGetFirmwareVer()
	{

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg System Version -d undefined -f /etc/config/uLinux.conf

	}

OsGetFirmwareBuild()
	{

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg System Number -d undefined -f /etc/config/uLinux.conf

	}

OsGetFirmwareDate()
	{

	# Outputs: (local)
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg System 'Build Number' -d undefined -f /etc/config/uLinux.conf

	}

OsGetQnapOS()
	{

	if $GREP_CMD -q zfs /proc/filesystems; then
		printf 'QuTS hero'
	else
		printf QTS
	fi

	}

QpkgGetArch()
	{

	# Translate arch from local NAS (QTS/QuTS) to sherpa notation.
	# sherpa arch for target NAS is a single 3 character-code.
	# 'a' for ARM, 'i' for Intel.

	if [[ $(get_display_name) = 'TS-269H' ]]; then
		printf i53
		return
	fi

	case $r_nas_arch in
		x86_64)
			[[ ${r_nas_firmware_version//.} -ge 430 ]] && printf i64 || printf i86
			;;
		i686|x86)
			printf i86
			;;
		armv5tel)
			printf a19
			;;
		armv7l)
			case $r_nas_platform in
				ARM_MS)
					printf a31
					;;
				ARM_AL)
					printf a41
					;;
				*)
					printf none
			esac
			;;
		aarch64)
			printf a64
			;;
		*)
			printf none
	esac

	}

QpkgGetEntwareType()
	{

	if QpkgIsReallyInstalled Entware; then
		if [[ -e /opt/etc/passwd ]]; then
			if [[ -L /opt/etc/passwd ]]; then
				printf std
			else
				printf alt
			fi
		else
			printf none
		fi
	else
		printf 'not-installed'
	fi

	} 2> /dev/null

UserGetSudoUID()
	{

	printf '%s' "${SUDO_UID:-undefined}"

	}

OsGetUpState()
	{

	if OsIsStarting; then
		printf 'starting-up'
	elif OsIsStopping; then
		printf 'shutting-down'
	else
		printf stable
	fi

	}

UserGetGitBranch()
	{

	/sbin/getcfg sherpa Git_Branch -d stable -f /etc/config/qpkg.conf

	}

OsIsOk()
	{

	if ! OsIsQNAP; then
		ShowAsAbort 'QNAP shell functions not found ... is this a QNAP NAS?'

		return 1
	fi

	return 0

	}

OsIsQNAP()
	{

	# Is this a QNAP NAS?

	[[ -e /etc/init.d/functions ]]

	}

OsIsSupported()
	{

	# Unable to test firmwares any earlier than 4.2.6 (but still have 4.2.0 available for TS-559Pro+):

	[[ ${r_nas_firmware_version//.} -ge 400 ]]

	}

OsIsSupportSecureDownload()
	{

	# `/sbin/curl` with SSL certificate verification enabled:
	#	fails in:
	# 		QTS 4.2.6
	# 		QTS 4.4.1
	# 		QTS 4.5.1
	# 		QTS 4.5.4.1715
	#	works in:
	# 		QTS 4.5.4.2627

	[[ ${r_nas_firmware_version//.} -ge 500 ]]

	}

OsIsSupportQpkgTimeout()
	{

	[[ ${r_nas_firmware_version//.} -ge 430 ]]

	}

OsIsSupportSignedPackages()
	{

# 	[[ ${r_nas_firmware_version//.} -ge 435 ]]

	# NOTE: signing failed on QTS 4.3.6 (x31). No cert database. So, let's go one-version-higher:

	[[ ${r_nas_firmware_version//.} -ge 440 ]]

	}

OsIsCompatibleWithSigned()
	{

	# QTS builds released over these 6 days don't allow unsigned QPKGs to run at-all:

	[[ $r_nas_firmware_date -lt 20201015 || $r_nas_firmware_date -gt 20201020 ]]

	}

OsIsSupportUnofficialPackages()
	{

	# Must check for "official QPKGs" on QTS 4.3.3 to QTS 4.3.6:

	[[ ${r_nas_firmware_version//.} -gt 426 && ${r_nas_firmware_version//.} -le 436 ]]

	}

OsIsSupportSudo()
	{

	[[ -e /usr/bin/sudo ]]

	}

OsIsSupportSedExtRegex()
	{

	# Test if QTS `/bin/sed` can handle extended regexes (early BusyBox versions cannot):

	[[ $(echo -en "\033[1;97ma" | /bin/sed -r 's/\x1b\[[0-9;]*m//g' | /usr/bin/wc -c) -eq 1 ]]

	}

OsIsSupportDecimalSleepSeconds()
	{

	# Test if QTS `/bin/sleep` can handle decimal seconds (early BusyBox versions cannot):

	/bin/sleep .01 &> /dev/null

	}

OsIsSupportAutowidthTableColumns()
	{

	[[ -e $GNU_AWK_CMD ]]

	}

OsIsAllowUnsignedPackages()
	{

	[[ $(/sbin/getcfg 'QPKG Management' Ignore_Cert -d FALSE) = TRUE ]]

	}

OsIsAllowUnofficialPackages()
	{

	[[ $(/sbin/getcfg 'QPKG Management' Check_Official -d TRUE) = FALSE ]]

	}

OsIsStarting()
	{

	$PS_CMD | $GREP_CMD '/bin/sh /etc/init.d/rcS' | $GREP_CMD -v grep

	} &> /dev/null

OsIsStopping()
	{

	$PS_CMD | $GREP_CMD '/bin/sh /etc/init.d/rcK' | $GREP_CMD -v grep

	} &> /dev/null

OsIsStdKernelPageSize()
	{

	# Standard kernel page size for most QNAP NAS is 4kiB. Non-standard size is 32kiB (confirmed on the TS-431XeU, TS-431X3 & TS-1635).
	# https://www.qnap.com/en-us/how-to/faq/article/why-do-the-installed-third-party-containers-not-run-successfully-on-specific-32-bit-arm-devices

	[[ ${r_kernel_page_size:=$(OsGetKernelPageSize)} = 4096 || $r_kernel_page_size = 4kB ]]

	}

OsIsNonStdKernelPageSize()
	{

	! OsIsStdKernelPageSize

	}

OsIsLoadAverageElevated()
	{

	local a=$(OsGetSysLoad1MinAverage); a=${a/./}
	local b=$((r_cpu_cores*2*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

OsIsLoadAverageHigh()
	{

	local a=$(OsGetSysLoad1MinAverage); a=${a/./}
	local b=$((r_cpu_cores*4*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

OsIsLoadAverageInsane()
	{

	local a=$(OsGetSysLoad1MinAverage); a=${a/./}
	local b=$((r_cpu_cores*8*100))

	[[ $((10#$a)) -ge $((10#$b)) ]]

	}

SetError()
	{

	run_package_actions=false
	ErrorIsSet && return
	_script_error_flag_=true
	DebugVar _script_error_flag_

	}

ErrorIsSet()
	{

	[[ ${_script_error_flag_:=false} = true ]]

	}

ErrorIsNt()
	{

	[[ ${_script_error_flag_:=false} != true ]]

	}

ShowZeroQpkgs()
	{

	[[ ${packages_loaded:=false} = true ]] || return

	local a=''
	local b=''

	for a in "${r_qpkg_is_states[@]:-}"; do
		for b in "${r_user_qpkg_actions[@]:-}"; do
			[[ $b = list ]] && continue			# Action results lists are unavailable for these.
			QPKGs.AC${b}.IS${a}.IsSet && QPKGs-AC${b}-ok.IsNone && ShowAsWarn "no QPKGs were able to $(Lowercase "$b")"
		done
	done

	return 0

	}

ClaimLockfile()
	{

	# Outputs: (global)
	#	$r_lock_pathfile

	local a=''
	readonly r_lock_pathfile=/var/run/sherpa.lock

	for a in sherpa-manager.sh sherpa-manager.source; do
		if [[ -e $r_lock_pathfile && -d /proc/$(<"$r_lock_pathfile") && $(< /proc/"$(<"$r_lock_pathfile")"/cmdline) =~ $a ]]; then
			ShowAsAbort "a running $(ShowAsTitleName) instance was found (PID:$(<"$r_lock_pathfile")), can't continue"

			return 1
		fi
	done

	echo "$$" > "$r_lock_pathfile"

	return 0

	}

ReleaseLockfile()
	{

	# Inputs: (global)
	#	$r_lock_pathfile

	[[ -n ${r_lock_pathfile:-} ]] && rm -f "$r_lock_pathfile" 2> /dev/null

	}

EnableVerbose()
	{

	useropt_verbose=true
	DebugVar useropt_verbose

	useropt_terse=false
	ShowKeystrokes
	ShowCursor

	}

EnableDebugToArchiveAndFile()
	{

	useropt_debug=true
	DebugVar useropt_debug

	ShowAsNote "debug mode activated, $(ShowAsTitleName) will run a little slower than usual"

	archive_debug_afterward=true
	DebugVar archive_debug_afterward

	}

DisableDebugToArchiveAndFile()
	{

	archive_debug_afterward=false
	useropt_debug=false

	}

SaveActionResultToLog()
	{

	# Write package type, package name, datetime in seconds, action, result, reason to actions logfile, and into actions durations file.

	# Inputs: (local)							Example:
	#   $1 = package type						`QPKG`, `IPK`, `PIP`
	#   $2 = package or group name				`SABnzbd`, `essential`
	#   $3 = action								`download`, `activate`
	#   $4 = quantity (optional, default 1)		number of packages affected
	#   $5 = result								`ok`, `skipped-ok`, `skipped`, `failed`
	#   $6 = reason (optional)					"file already exists in local cache"

	# Calculate duration here.

	local -r r_var_name=${FUNCNAME[1]}_STARTNANOSECONDS
		local var_safe_name=${r_var_name//[.-]/_}; var_safe_name=${var_safe_name//:/_}
	local -r r_package_type=${1:?${FUNCNAME[0]}'()': undefined package type}
	local -r r_name=${2:?${FUNCNAME[0]}'()': undefined package name}
	local -r r_action=${3:?${FUNCNAME[0]}'()': undefined action}
	local -r r_qty=${4:-1}
	local -r r_clean_action=${r_action//\"/}
	local -r r_result=${5:?${FUNCNAME[0]}'()': undefined result}
	local -r r_reason=${6:-}
	local -r r_starttime=$(ConvertNanosecondsToMilliseconds "${!var_safe_name}")
	local -r r_duration=$(CalcAmountDiff "$r_starttime" "$(ConvertNowToMilliseconds)")
	local -r r_action_times_pathfile=$r_action_times_path/$r_clean_action.milliseconds

	if [[ $2 = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$2"

		return 1
	fi

	# Add new action results entry.
	echo "$r_starttime|$r_action|$r_qty|$r_name|$r_package_type|$r_result|$r_duration|$r_reason" >> "$r_session_action_results_pathfile"

	# Remove previous action duration entry if one exists.

	if [[ -e $r_action_times_pathfile ]] && $GREP_CMD -q "^$r_name|" < "$r_action_times_pathfile"; then
		$SED_CMD -i "/^$r_name|/d" "$r_action_times_pathfile"
	fi

	# Add new action duration entry.
	echo "$r_name|$r_duration" >> "$r_action_times_pathfile"

	case $4 in
		ok|skipped-ok)
			DebugAsInfo "$r_reason"
			;;
		skipped)
			DebugAsWarn "$r_reason"
			;;
		failed|skipped-@(error|abort))
			DebugAsError "$r_reason"
	esac

	return 0

	}

# * Action return codes (only recorded in debug log).
# 	0 = ok
# 	1 = skipped
# 	2 = skipped-ok
# 	3 = skipped-abort
# 	4 = skipped-error

_QPKG:reassign_()
	{

	# * This function runs asynchronously *
	# Remove the `storeid` assignment for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$r_logs_path
	#	$qpkg_name
	#	$r_reassign_log_file
	#	$useropt_verbose

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" reassign '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" reassign '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif [[ $(QpkgGetInstalledStoreID) = sherpa || $(QpkgGetInstalledStoreID) = undefined ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" reassign '' skipped 'already assigned to sherpa'
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "reassigning $(ShowAsPackageName)"
	RunAndLog "/sbin/setcfg -e $qpkg_name store -f /etc/config/qpkg.conf" "$r_logs_path/$qpkg_name.$r_reassign_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" reassign '' ok
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" reassign '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:download_()
	{

	# * This function runs asynchronously *
	# Download the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$r_download_log_file
	#	$r_logs_path
	#	$r_qpkg_download_path
	#	$qpkg_name
	#	$r_remote_filename
	#	$useropt_verbose

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local -r r_remote_hash=$(QpkgGetDatabaseHash)
	local -r r_remote_url=$(QpkgGetDatabaseURL)
		local -r r_remote_filename=$($BASENAME_CMD "$r_remote_url")
			local -r r_local_pathfile=$r_qpkg_download_path/$r_remote_filename
				local -r r_local_filename=$($BASENAME_CMD "$r_local_pathfile")
					local -r r_log_pathfile=$r_logs_path/$r_local_filename.$r_download_log_file
	local -i z=0

	if [[ -z $r_remote_url || -z $r_remote_hash ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" download '' skipped 'NAS arch is incompatible'
		MarkThisAcForkAsSkipped
		z=1
	elif [[ -f $r_local_pathfile ]]; then
		if FileMatchesMD5 "$r_local_pathfile" "$r_remote_hash"; then
			SaveActionResultToLog QPKG "$qpkg_name" download '' skipped-ok "existing file $(ShowAsFileName "$r_local_filename") checksum is correct"
			MarkThisAcForkAsSkippedOk
			z=2
		else
			DebugInfo "deleting $(ShowAsFileName "$r_local_filename") as checksum is incorrect"
			rm -f "$r_local_pathfile" 2> /dev/null
		fi
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	if [[ ! -f $r_local_pathfile ]]; then
		DebugAsProc "downloading $(ShowAsFileName "$r_remote_filename")"

		rm -f "$r_log_pathfile" 2> /dev/null

		RunAndLog "$CURL_CMD --location --output $r_local_pathfile $r_remote_url" "$r_log_pathfile" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			if FileMatchesMD5 "$r_local_pathfile" "$r_remote_hash"; then
				[[ $(Lowercase "${r_local_pathfile##*.}") = zip ]] && $UNZIP_CMD -nq "$r_local_pathfile" -d "$r_qpkg_download_path"
				SaveActionResultToLog QPKG "$qpkg_name" download '' ok
				SendPackageStateChange ISdownloaded
				MarkThisAcForkAsOk
			else
				SaveActionResultToLog QPKG "$qpkg_name" download '' failed "cache file $(ShowAsFileName "$r_local_filename") has incorrect checksum"
				SendPackageStateChange ISNTdownloaded
				MarkThisAcForkAsError
				z=1
			fi
		else
			SaveActionResultToLog QPKG "$qpkg_name" download '' failed "$z"
			MarkThisAcForkAsError
			z=1   # Remap to 1 (last time I checked, 'curl' had 92 return codes).
		fi
	fi

	FuncForkExit $z

	}

_QPKG:install_()
	{

	# * This function runs asynchronously *
	# Install the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$r_install_log_file
	#	$r_logs_path
	#	$qpkg_name
	#	$QPKGs_were_installed_name[]
	#	$useropt_debug
	#	$useropt_verbose

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped 'already installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsReallyInstalled && QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseArchOK "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped 'NAS arch is incompatible'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseMinOSVerOk "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped "$(OsGetQnapOS) version is incompatible"
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseMinRAMOk "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped 'NAS has insufficient RAM installed'
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local local_pathfile=$(QpkgGetDatabasePathFilename)

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" install '' skipped-error 'no local file found for processing: please report this issue'
		MarkThisAcForkAsSkippedError
		z=4
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	if [[ $qpkg_name = Entware ]] && ! QPKGs-ISinstalled.Exist Entware && QPKGs-ACinstall-to.Exist Entware; then
		local -r r_opt_path=/opt
		local -r r_opt_bu_path=/opt.orig

		if [[ -d $r_opt_path && ! -L $r_opt_path && ! -e $r_opt_bu_path ]]; then
			DebugAsProc 'backup original /opt'
			mv "$r_opt_path" "$r_opt_bu_path"
			DebugAsDone complete
		fi
	fi

	DebugAsProc "installing $(ShowAsPackageName)"
	[[ ${QPKGs_were_installed_name[*]:-} = *"$qpkg_name"* ]] && a+="QINSTALL_PATH=$(QpkgGetInstalledOriginalPath "$qpkg_name") "

	RunAndLog "${a}${SH_CMD} $local_pathfile" "$r_logs_path/$($BASENAME_CMD "$local_pathfile").$r_install_log_file" log:failure-only 10
	z=$?

	LogQpkgServiceResult
	QpkgIsDatabaseWillLog && ! QpkgInstalledServiceResultWasOk && z=1

	[[ $qpkg_name = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1		# Entware installation has failed.

	if [[ $z -eq 0 || $z -eq 10 ]]; then	# '0' or '10' from a QPKG install/reinstall/upgrade is OK, but also includes user-aborts.
		SendPackageStateChange ISinstalled

		if QpkgIsInstalledEnabled "$qpkg_name"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		SaveActionResultToLog QPKG "$qpkg_name" install '' ok "v$(QpkgGetInstalledVer)"

		if [[ $qpkg_name = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			SendParentChangeEnv _UpdateEntwarePackageList_
			PatchEntwareService

			# Shift all files from original [/opt] into new [/opt]

			if [[ -L ${r_opt_path:-} && -d ${r_opt_bu_path:-} ]]; then
				DebugAsProc 'restoring original /opt'
				mv "$r_opt_bu_path"/* "$r_opt_path" && ClearPath / "$r_opt_bu_path"
				DebugAsDone complete
			fi
		fi

		OsIsSupportSignedPackages && SendParentChangeEnv "QPKGs-ACsign-to:Add $qpkg_name"
		MarkThisAcForkAsOk
		z=0   # Remap to zero.
	else
		SaveActionResultToLog QPKG "$qpkg_name" install '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:reinstall_()
	{

	# * This function runs asynchronously *
	# Reinstall the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a='REINSTALL_QPKG=true '
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' skipped "not installed, please use 'install' instead."
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local local_pathfile=$(QpkgGetDatabasePathFilename)

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' skipped-error 'no local file found for processing, please report this issue.'
		MarkThisAcForkAsSkippedError
		z=4
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "reinstalling $(ShowAsPackageName)"
	QpkgIsInstalled && a+="QINSTALL_PATH=$($DIRNAME_CMD "$(QpkgGetInstalledPath)") "

	RunAndLog "${a}${SH_CMD} $local_pathfile" "$r_logs_path/$($BASENAME_CMD "$local_pathfile").$r_reinstall_log_file" log:failure-only 10
	z=$?

	LogQpkgServiceResult
	QpkgIsDatabaseWillLog && ! QpkgInstalledServiceResultWasOk && z=1

	[[ $qpkg_name = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1

	if [[ $z -eq 0 || $z -eq 10 ]]; then		# '0' or '10' from a QPKG install/reinstall/upgrade is OK, but also includes aborts.
		if QpkgIsInstalledEnabled "$qpkg_name"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' ok "v$(QpkgGetInstalledVer)"
		MarkThisAcForkAsOk
		z=0   # Remap to zero.
	else
		SaveActionResultToLog QPKG "$qpkg_name" reinstall '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:rebuild_()
	{

	# * This function runs asynchronously *
	# Meta-action: rebuild the QPKG named in $qpkg_name. This is a `download`, `install` and `restore`, but only if a backup file exists for this QPKG.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local -i z=0

	if ! QpkgIsDatabaseCanBackup; then
		SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' skipped 'does not support rebuild'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsReallyInstalled && QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QPKGs-ISinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' skipped "already installed, please use 'restore' instead"
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsBackupExist; then
		SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' skipped 'backup file does not exist'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "meta-rebuilding $(ShowAsPackageName)"
	# Nothing-to-do here, real QPKG actions have already been assigned in CheckEnv().

	SaveActionResultToLog QPKG "$qpkg_name" meta-rebuild '' ok
	MarkThisAcForkAsOk
	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:upgrade_()
	{

	# * This function runs asynchronously *
	# Upgrade the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a='UPGRADE_QPKG=true '
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QPKGs-ISupgradable.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' skipped 'no new QPKG is available'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local local_pathfile=$(QpkgGetDatabasePathFilename)

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' skipped-error 'no local file found for processing, please report this issue'
		MarkThisAcForkAsSkippedError
		z=4
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local prev_ver=$(QpkgGetInstalledVer)

	DebugAsProc "upgrading $(ShowAsPackageName)"
	QpkgIsInstalled && a+="QINSTALL_PATH=$($DIRNAME_CMD "$(QpkgGetInstalledPath "$qpkg_name")") "

	RunAndLog "${a}${SH_CMD} $local_pathfile" "$r_logs_path/$($BASENAME_CMD "$local_pathfile").$r_upgrade_log_file" log:failure-only 10
	z=$?

	LogQpkgServiceResult
	QpkgIsDatabaseWillLog && ! QpkgInstalledServiceResultWasOk && z=1

	[[ $qpkg_name = Entware ]] && IsNtSysFileExist $OPKG_CMD && z=1

	if [[ $z -eq 0 || $z -eq 10 ]]; then	# '0' or '10' from a QPKG install/reinstall/upgrade is OK, but also includes aborts.
		SendPackageStateChange ISNTupgradable

		if QpkgIsInstalledEnabled "$qpkg_name"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		local current_ver=$(QpkgGetInstalledVer)

		if [[ $current_ver = "$prev_ver" ]]; then
			SaveActionResultToLog QPKG "$qpkg_name" upgrade '' ok "v${current_ver}"
		else
			SaveActionResultToLog QPKG "$qpkg_name" upgrade '' ok "v${prev_ver} -> v${current_ver}"
		fi

		MarkThisAcForkAsOk
		z=0   # Remap to zero.
	else
		SaveActionResultToLog QPKG "$qpkg_name" upgrade '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:uninstall_()
	{

	# * This function runs asynchronously *
	# Uninstall the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" uninstall '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" uninstall '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif [[ $qpkg_name = sherpa ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" uninstall '' skipped "it's needed here! 😉"
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" uninstall '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_qpkg_uninstaller_pathfile=$(QpkgGetInstalledPath)/.uninstall.sh

	[[ $qpkg_name = Entware ]] && SaveIpkAndPipList

	if [[ -e $r_qpkg_uninstaller_pathfile ]]; then
		DebugAsProc "uninstalling $(ShowAsPackageName)"

		RunAndLog "${a}${SH_CMD} $r_qpkg_uninstaller_pathfile" "$r_logs_path/$qpkg_name.$r_uninstall_log_file" log:failure-only
		z=$?

		if [[ $z -eq 0 ]]; then
			# WARNING: beware of `qpkg_cli --remove`, it removes the QPKG installation path around 10-20 seconds after execution. If sherpa has moved-on and starts an install, `qpkg_cli` will remove the newly created QPKG installation path partway through the installation. So, check if QPKG is to be installed: if this is the case, don't use `qpkg_cli --remove`.
			[[ -e /sbin/qpkg_cli ]] && ! QPKGs-ACinstall-to.Exist "$qpkg_name" && /sbin/qpkg_cli --remove "$qpkg_name" &> /dev/null
			SaveActionResultToLog QPKG "$qpkg_name" uninstall '' ok
			/sbin/rmcfg "$qpkg_name" -f /etc/config/qpkg.conf
			DebugAsDone 'removed icon information from App Center'

			if [[ $qpkg_name = Entware ]]; then
				SendParentChangeEnv ModPathToEntware
				UpdateParentCapabilities
				UpdateCapabilities
			fi

			SendPackageStateChange ISNTinstalled
			SendPackageStateChange ISNTactive
			SendPackageStateChange ISNTenabled
			MarkThisAcForkAsOk
		else
			SaveActionResultToLog QPKG "$qpkg_name" uninstall '' failed "$z"
			MarkThisAcForkAsError
			z=1   # Remap to 1.
		fi
	else
		# Standard QPKG `.uninstall.sh` was not found, so can't continue with uninstallation (maybe force this instead with `rm -r` ?).
		SaveActionResultToLog QPKG "$qpkg_name" uninstall '' failed "$(ShowAsFileName '.uninstall.sh') not found"
		MarkThisAcForkAsError
	fi

	FuncForkExit $z

	}

_QPKG:activate_()
	{

	# * This function runs asynchronously *
	# Activate/start the service-script for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" activate '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" activate '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" activate '' skipped "not enabled, please 'enable' it first"
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" activate '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_log_pathfile=$r_logs_path/$qpkg_name.$r_activate_log_file
	local timeout=''
	OsIsSupportQpkgTimeout && timeout=" -t $r_qpkg_start_timeout_seconds"
	local service_pathfile=$(QpkgGetInstalledServicePathFile)

	DebugAsProc "activating $(ShowAsPackageName)"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" activate '' skipped-error 'QPKG service-script file undefined'
		MarkThisAcForkAsSkippedError

		FuncForkExit 4
	elif [[ $useropt_debug = true ]]; then
		RunAndLog "${a}${service_pathfile} start" "$r_log_pathfile" log:failure-only
		z=$?
	elif QpkgIsDatabaseWillLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} start $qpkg_name" "$r_log_pathfile" log:failure-only
		QpkgInstalledServiceResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile start" "$r_log_pathfile" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" activate '' ok

		if [[ $qpkg_name = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			UpdateParentCapabilities
			UpdateCapabilities
		fi

		SendPackageStateChange ISactive
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" activate '' failed "$z"
		SendPackageStateChange ISNTactive
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:reactivate_()
	{

	# * This function runs asynchronously *
	# Reactivate/restart the service-script for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' skipped "not enabled, please 'enable' it first"
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_log_pathfile=$r_logs_path/$qpkg_name.$r_reactivate_log_file
	local timeout=''
	OsIsSupportQpkgTimeout && timeout=" -t $r_qpkg_restart_timeout_seconds"
	local service_pathfile=$(QpkgGetInstalledServicePathFile)

	DebugAsProc "reactivating $(ShowAsPackageName)"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' skipped-error 'QPKG service-script file undefined'
		MarkThisAcForkAsSkippedError

		FuncForkExit 4
	elif [[ $useropt_debug = true ]]; then
		RunAndLog "${a}${service_pathfile} restart" "$r_log_pathfile" log:failure-only
		z=$?
	elif QpkgIsDatabaseWillLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} restart $qpkg_name" "$r_log_pathfile" log:failure-only
		QpkgInstalledServiceResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile restart" "$r_log_pathfile" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' ok
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" reactivate '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:deactivate_()
	{

	# * This function runs asynchronously *
	# Deactivate/stop the service-script for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]]	&& a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
# 	elif [[ $qpkg_name = sherpa ]]; then
# 		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' skipped "it's needed here! 😉"
# 		MarkThisAcForkAsSkipped
# 		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_log_pathfile=$r_logs_path/$qpkg_name.$r_deactivate_log_file
	local timeout=''
	OsIsSupportQpkgTimeout && timeout=" -t $r_qpkg_stop_timeout_seconds"
	local service_pathfile=$(QpkgGetInstalledServicePathFile)

	DebugAsProc "deactivating $(ShowAsPackageName)"

	if [[ $service_pathfile = undefined ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' skipped-error 'QPKG service-script file undefined'
		MarkThisAcForkAsSkippedError

		FuncForkExit 4
	elif [[ $useropt_debug = true ]]; then
		RunAndLog "${a}${service_pathfile} stop" "$r_log_pathfile" log:failure-only
		z=$?
	elif QpkgIsDatabaseWillLog; then		# Use `qpkg_service` if-possible, so package icon in App Center will dynamically update.
		RunAndLog "/sbin/qpkg_service${timeout} stop $qpkg_name" "$r_log_pathfile" log:failure-only
		QpkgInstalledServiceResultWasOk && z=0 || z=1
	else
		RunAndLog "$service_pathfile stop" "$r_log_pathfile" log:failure-only
		z=$?
	fi

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' ok

		if [[ $qpkg_name = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			UpdateParentCapabilities
			UpdateCapabilities
		fi

		SendPackageStateChange ISNTactive
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" deactivate '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	ClearQpkgInstalledAppCenterNotifier

	FuncForkExit $z

	}

_QPKG:enable_()
	{

	# * This function runs asynchronously *
	# Enable the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" enable '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" enable '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QPKGs-ISenabled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" enable '' skipped 'already enabled'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" enable '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_log_pathfile=$r_logs_path/$qpkg_name.$r_enable_log_file
	local timeout=''
	OsIsSupportQpkgTimeout && timeout=" -t $r_qpkg_enable_timeout_seconds"

	DebugAsProc "enabling $(ShowAsPackageName)"

	RunAndLog "/sbin/qpkg_service${timeout} enable $qpkg_name" "$r_log_pathfile" log:failure-only
	QpkgIsInstalledEnabled "$qpkg_name" && SendPackageStateChange ISenabled
	ClearQpkgInstalledAppCenterNotifier
	SaveActionResultToLog QPKG "$qpkg_name" enable '' ok
	MarkThisAcForkAsOk

	FuncForkExit $z

	}

_QPKG:disable_()
	{

	# * This function runs asynchronously *
	# Disable the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" disable '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" disable '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif QPKGs-ISNTenabled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" disable '' skipped 'already disabled'
		MarkThisAcForkAsSkipped
		z=1
# 	elif [[ $qpkg_name = sherpa ]]; then
# 		SaveActionResultToLog QPKG "$qpkg_name" disable '' skipped "it's needed here! 😉"
# 		MarkThisAcForkAsSkipped
# 		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" disable '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	local -r r_log_pathfile=$r_logs_path/$qpkg_name.$r_disable_log_file
	local timeout=''
	OsIsSupportQpkgTimeout && timeout=" -t $r_qpkg_disable_timeout_seconds"

	DebugAsProc "disabling $(ShowAsPackageName)"

	RunAndLog "/sbin/qpkg_service${timeout} disable $qpkg_name" "$r_log_pathfile" log:failure-only
	! QpkgIsInstalledEnabled "$qpkg_name" && SendPackageStateChange ISNTenabled

	ClearQpkgInstalledAppCenterNotifier
	SaveActionResultToLog QPKG "$qpkg_name" disable '' ok
	MarkThisAcForkAsOk

	FuncForkExit $z

	}

_QPKG:enableau_()
	{

	# * This function runs asynchronously *
	# Enable auto-updating of the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif [[ $qpkg_name = sherpa ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' skipped 'auto-update is always enabled'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseCanRestartToUpdate "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' skipped 'auto-update is unsupported'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "enabling auto-update $(ShowAsPackageName)"

	RunAndLog "${a}$(QpkgGetInstalledServicePathFile) enable-auto-update" "$r_logs_path/$qpkg_name.$r_enableau_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' ok
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" enableau '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:disableau_()
	{

	# * This function runs asynchronously *
	#  Disable auto-updating of the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif [[ $qpkg_name = sherpa ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' skipped 'auto-update cannot be disabled'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseCanRestartToUpdate "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' skipped 'auto-update is unsupported'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "disabling auto-update $(ShowAsPackageName)"

	RunAndLog "${a}$(QpkgGetInstalledServicePathFile) disable-auto-update" "$r_logs_path/$qpkg_name.$r_disableau_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' ok
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" disableau '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:backup_()
	{

	# * This function runs asynchronously *
	#  Run a `backup` action for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" backup '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" backup '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseCanBackup; then
		SaveActionResultToLog QPKG "$qpkg_name" backup '' skipped 'backup is unsupported'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" backup '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "backing-up $(ShowAsPackageName) configuration"

	RunAndLog "${a}$(QpkgGetInstalledServicePathFile) backup" "$r_logs_path/$qpkg_name.$r_backup_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" backup '' ok
		SendPackageStateChange ISbackedup
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" backup '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:restore_()
	{

	# * This function runs asynchronously *
	#  Run a `restore` action for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" restore '' skipped "not installed, try 'rebuild' instead"
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" restore '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseCanBackup; then
		SaveActionResultToLog QPKG "$qpkg_name" restore '' skipped 'restore is unsupported'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsBackupExist; then
		SaveActionResultToLog QPKG "$qpkg_name" restore '' skipped 'backup file does not exist'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" restore '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "restoring $(ShowAsPackageName) configuration"

	RunAndLog "${a}$(QpkgGetInstalledServicePathFile) restore" "$r_logs_path/$qpkg_name.$r_restore_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" restore '' ok
		SendPackageStateChange ISrestored
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" restore '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:clean_()
	{

	# * This function runs asynchronously *
	#  Run a `clean` action for the QPKG named in $qpkg_name.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	[[ $useropt_debug = true ]] && a+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" clean '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" clean '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! QpkgIsDatabaseCanClean; then
		SaveActionResultToLog QPKG "$qpkg_name" clean '' skipped 'clean is unsupported'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" clean '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "cleaning $(ShowAsPackageName)"

	RunAndLog "${a}$(QpkgGetInstalledServicePathFile) clean" "$r_logs_path/$qpkg_name.$r_clean_log_file" log:failure-only
	z=$?

	if [[ $z -eq 0 ]]; then
		LogQpkgServiceResult
		SaveActionResultToLog QPKG "$qpkg_name" clean '' ok
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" clean '' failed "$z"
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:sign_()
	{

	# * This function runs asynchronously *
	# Modify the QTS App Center certificate dB, and add an unsigned QPKG as-if it were signed. It adds a QNAP-generated certificate and digital signature to the certificate database for the unsigned QPKG.

	# Running the code below makes the target QPKG effectively "signed", and allows user to install and run this QPKG with the 'Allow installation of applications without a valid digital signature' App Center option unticked.

	# Should only be required for QTS 4.3.5-and-later firmwares.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs: (local)
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	local b=''
	local -i z=0

	if [[ -e $r_action_abort_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped-abort 'abort requested, unable to continue'
		MarkThisAcForkAsSkippedAbort
		z=3
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugVar sqlite_cmd

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledAuthorOk; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped 'incompatible author'
		MarkThisAcForkAsSkipped
		z=1
	elif ! OsIsSupportSignedPackages; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped 'not required: firmware < 4.3.5'
		MarkThisAcForkAsSkipped
		z=1
	elif QpkgIsNtInstalledRepoSelfManaged; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped "assigned to another repository, please 'reassign' it first"
		MarkThisAcForkAsSkipped
		z=1
	elif [[ ! -e $sqlite_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped-abort "$(ShowAsFileName sqlite3) binary not found"
		MarkThisAcForkAsSkippedAbort
		z=3
	elif [[ ! -e $r_cert_db_pathfile ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped-abort "$(OsGetQnapOS) QPKG certificate database not found"
		MarkThisAcForkAsSkippedAbort
		z=3
	else
		a="SELECT 1 FROM Certificate WHERE QpkgName = '$qpkg_name' LIMIT 1;"
		b=$(eval "$sqlite_cmd" "$r_cert_db_pathfile" \"$a\")

		if [[ $b = 1 ]]; then
# 			SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' skipped-ok 'already signed'
# 			MarkThisAcForkAsSkippedOk
# 			z=2

			# KLUDGE: replace db entries created prior to 2024-06-08 as $r_qpkg_signature quoting was incorrect.
			# So, remove existing entry now, and re-add it later in this function.
			# Keep this in-place until 2025-06-07.

			a="DELETE FROM Certificate WHERE QpkgName = '$qpkg_name';"
			b=$(eval "$sqlite_cmd" "$r_cert_db_pathfile" \"$a\")
			z=0		# Disregard errors generated while deleting record.
		fi
	fi

	[[ $z -eq 0 ]] || FuncForkExit $z

	DebugAsProc "\"signing\" $(ShowAsPackageName)"

# 	a="DELETE FROM Certificate WHERE QpkgName = '$qpkg_name'; INSERT INTO Certificate (Type,QpkgName,Cert,DigitalSignature) VALUES ('qpkg','$qpkg_name','$r_qpkg_certificate','$r_qpkg_signature');"

#	a="INSERT INTO Certificate (Type, QpkgName, Cert, DigitalSignature) SELECT 'qpkg','$qpkg_name','$r_qpkg_certificate','$r_qpkg_signature' WHERE NOT EXISTS (SELECT * FROM Certificate WHERE QpkgName = '$qpkg_name');"

	a="INSERT INTO Certificate (Type,QpkgName,Cert,DigitalSignature) VALUES ('qpkg','$qpkg_name','$r_qpkg_certificate','$r_qpkg_signature');"

	for ((retries=0; retries<10; retries++)); do
		eval "$sqlite_cmd" "$r_cert_db_pathfile" "\"$a\""
		z=$?

		case $z in
			5) 		# SQLITE_BUSY
				sleep 0.5
				;;
			*)
				break
		esac
	done

	if [[ $z -eq 0 ]]; then
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' ok
		SendPackageStateChange ISsigned
		MarkThisAcForkAsOk
	else
		SaveActionResultToLog QPKG "$qpkg_name" '"sign"' '' failed "($z) but don't know why. Please report this as a bug"
		SendParentChangeEnv 'show_suggest_raise_issue=true'
		MarkThisAcForkAsError
		z=1   # Remap to 1.
	fi

	FuncForkExit $z

	}

_QPKG:status_()
	{

	# * This function runs asynchronously *
	# Query a QPKG for its 'status'. Each compatible QPKG will return 0 if application process is active or ready-to-run, 0 if not.

	# Inputs: (global)
	#	$qpkg_name

	# Outputs:
	#   $? = none, this function executes asynchronously. But an exitcode is recorded in the debug log.

	[[ $useropt_verbose != true ]] && exec &> /dev/null

	FuncForkInit

	local a=''
	local b=''
	[[ $useropt_debug = true ]] && b+='DEBUG_QPKG=true '
	local -i z=0

	if QPKGs-ISNTinstalled.Exist "$qpkg_name"; then
		SaveActionResultToLog QPKG "$qpkg_name" status '' skipped 'not installed'
		MarkThisAcForkAsSkipped
		z=1
	fi

	[[ $z -eq 0 ]] || FuncForkExit

	DebugAsProc "status $(ShowAsPackageName)"

	a=$(QpkgGetDatabaseActiveTest)

	if [[ $a = builtin ]]; then
		# Run status query with GNU `timeout` if-possible.

		if [[ -e $GNU_TIMEOUT_CMD ]]; then
			$GNU_TIMEOUT_CMD "$r_qpkg_status_check_timeout_seconds" /bin/bash -c "${b}$(QpkgGetInstalledServicePathFile) status"
			z=$?
		else
			RunAndLog "${b}$(QpkgGetInstalledServicePathFile) status" "$r_logs_path/$qpkg_name.$r_status_log_file" log:failure-only
			z=$?
		fi
	elif [[ $a != none ]]; then
		eval "$a" &> /dev/null
		z=$?
	fi

	DebugVar z

	# returncodes 124 and-up are generated by GNU `timeout`.
	case $z in
		0)
			SendPackageStateChange ISactive
			;;
		1)
			SendPackageStateChange ISNTactive
			;;
		124)
			SendPackageStateChange ISslow
			;;
		*)
			SendPackageStateChange ISunknown
	esac

	SaveActionResultToLog QPKG "$qpkg_name" status '' ok
	MarkThisAcForkAsOk

	FuncForkExit

	}

ClearQpkgInstalledAppCenterNotifier()
	{

	# Clear QPKG name from notifier list.

	# Inputs: (global)
	#   $qpkg_name

	# KLUDGE: `clean` QTS 4.5.1+ App Center notifier status.
	[[ -e /sbin/qpkg_cli ]] && /sbin/qpkg_cli --cancel "$qpkg_name"

	QpkgIsNtInstalled && return

	# Must also do this when installing QPKGs at the CLI.
	/sbin/setcfg "$qpkg_name" Status complete -f /etc/config/qpkg.conf

	return 0

	} &> /dev/null

LogQpkgServiceResult()
	{

	# Inputs: (global)
	#   $qpkg_name

	if ! local a=$(QpkgGetInstalledServiceResult); then
		DebugAsWarn "unable to get status of $(ShowAsPackageName) service. It may be a non-sherpa package, or a sherpa package earlier than 200816c that doesn't support service results."

		return 1
	fi

	case $a in
		in-progress)
			DebugInfo "$(ShowAsPackageName) service action is in-progress"
			;;
		ok)
			DebugInfo "$(ShowAsPackageName) service action completed OK"
			;;
		failed)
			if [[ -e /var/log/$qpkg_name.log ]]; then
				DebugAsError "$(ShowAsPackageName) service action failed. Check $(ShowAsFileName "/var/log/$qpkg_name.log") for more information"
				AddExtLogToSessLog /var/log/$qpkg_name.log
			else
				DebugAsError "$(ShowAsPackageName) service action failed"
			fi
			;;
		*)
			DebugAsWarn "$(ShowAsPackageName) service status is unrecognised or unsupported"
	esac

	return 0

	}

QpkgGetInstalledPath()
	{

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs:
	#   stdout = package installation date.
	#   $? = 0 (found), 250 (not-found).

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" Install_Path -d undefined -f /etc/config/qpkg.conf

	}

QpkgGetInstalledServicePathFile()
	{

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = service-script pathfile
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" Shell -d undefined -f /etc/config/qpkg.conf

	}

QpkgGetDatabaseApplVer()
	{

	# Returns the version number of the application contained within a QPKG.

	# Inputs: (global)
	#	$r_qpkg_appl_version
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name
	#	$r_qpkg_name
	#	$r_qpkg_version

	# Outputs: (local)
	#   stdout = application version
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ $qpkg_index -gt 0 ]]; then
		a=${r_qpkg_appl_version[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_appl_version[$qpkg_default_index]}
		[[ $a = version ]] && a=${r_qpkg_version[$qpkg_default_index]}
		[[ $a != none ]] || return
	else
		for i in "${!r_qpkg_name[@]}"; do
			if [[ ${r_qpkg_name[$i]} = "$qpkg_name" ]]; then
				a=${r_qpkg_appl_version[$i]}
				[[ $a = version ]] && a=${r_qpkg_version[$qpkg_default_index]}
				[[ $a != none ]] || return
				break
			fi
		done
	fi

	[[ -n $a ]] || return
	[[ $a = dynamic ]] && QpkgIsInstalled && ! QpkgIsInstalledAutoUpdate && a=static

	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseVer()
	{

	# Returns the version number of an available (not-installed) QPKG.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = package version
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			if [[ ${r_qpkg_name[$i]} = "$1" ]]; then
				printf '%s' "${r_qpkg_version[$i]}"

				return 0
			fi
		done
	elif [[ $qpkg_index -gt 0 ]]; then
		a=${r_qpkg_version[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_version[$qpkg_default_index]}
		[[ $a != none ]] || return

		printf '%s' "$a"

		return 0
	fi

	return 1

	}

QpkgGetInstalledVer()
	{

	# Returns the version number of an installed QPKG.

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs:
	#   stdout = package version
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" Version -d undefined -f /etc/config/qpkg.conf

	}

QpkgGetInstalledStoreID()
	{

	# Returns the presently assigned repository store ID of an installed QPKG.

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = package store ID
	#   $? = 0 if found, 250 if not.

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" store -d undefined -f /etc/config/qpkg.conf

	}

QpkgGetInstalledDate()
	{

	# Returns the date specified QPKG was installed.

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = package installation date
	#   $? = 0 if found, 1 if QPKG name unspecified, 250 if not found

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" date -d undefined -f /etc/config/qpkg.conf

	}

QpkgGetInstalledOriginalPath()
	{

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = the original installation path of this QPKG (even if it was migrated to another volume).
	#   $? = 0 if successful, 1 if failed

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local -i i=0

	if [[ ${#QPKGs_were_installed_name[@]} -gt 0 ]]; then
		for i in "${!QPKGs_were_installed_name[@]}"; do
			[[ ${QPKGs_were_installed_name[$i]} = "$a" ]] || continue
			printf '%s' "${QPKGs_were_installed_path[$i]}"

			return 0
		done
	fi

	return 1

	}

QpkgGetDatabasePathFilename()
	{

	# Outputs: (local)
	#   stdout = pathfilename.
	#   $? = 0 if found, !0 if not

	local a=''

	a=$(QpkgGetDatabaseURL)
	[[ -n $a ]] || return

	[[ $(Lowercase "${a##*.}") != qpkg ]] && a=${a%.*}.qpkg		# Swap 'zip' for 'qpkg' here (only for compatibilty with 'QDK.zip').

	printf '%s' "$r_qpkg_download_path/$($BASENAME_CMD "$a")"

	return 0

	}

QpkgGetDatabaseHash()
	{

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = QPKG MD5
	#   $? = 0 if found, !0 if not

	[[ -n $qpkg_name && $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	local a=''

	a=${r_qpkg_hash[$qpkg_index]}
	[[ $a = default ]] && a=${r_qpkg_hash[$qpkg_default_index]}
	[[ $a != none ]] || return

	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseURL()
	{

	# Returns the URL of $qpkg_index.

	# Inputs: (local)
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = QPKG remote URL.
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			if [[ ${r_qpkg_name[$i]} = "$1" ]] && [[ ${r_qpkg_arch[$i]} = all || ${r_qpkg_arch[$i]} = "$r_nas_qpkg_arch" ]]; then
				printf '%s' "${r_qpkg_url[$i]}"

				return 0
			fi
		done

		return 1
	else
		a=${r_qpkg_url[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_url[$qpkg_default_index]}
		[[ -n $a ]] || a=none
		printf '%s' "$a"
	fi

	return 0

	}

QpkgGetDatabaseMinRAM()
	{

	# Inputs: (local)
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = minimum installed RAM required.
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_min_ram_kb[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_min_ram_kb[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_min_ram_kb[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseMinOSVer()
	{

	# Inputs: (local)
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = minimum QTS/QuTS version required by this QPKG.
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_min_os_version[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_min_os_version[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_min_os_version[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseMaxOSVer()
	{

	# Inputs: (local)
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name

	# Outputs: (local)
	#   stdout = maximum QTS/QuTS version required by this QPKG.
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_max_os_version[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_max_os_version[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_max_os_version[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseAuthor()
	{

	# Return the maintainer of the specified QPKG.

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = QPKG author (first package found).
	#   $? = 0 (found), !0 (not-found)

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local -i i=0

	for i in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$i]} = "$a" ]] || continue
		printf '%s' "${r_qpkg_author[$i]}"

		return 0
	done

	return 1

	}

QpkgGetInstalledAuthor()
	{

	# Return the maintainer of the specified installed QPKG.

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   stdout = installed QPKG author.

	/sbin/getcfg "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" Author -f /etc/config/qpkg.conf

	}

#QpkgGetAuthorEmail()
# 	{
#
# 	# Return the email address for the maintainer of the specified QPKG.
#
# 	# Inputs:
# 	#   $1 = QPKG name
#
# 	# Outputs:
# 	#   stdout = QPKG author (first package found).
# 	#   $? = 0 (found), !0 (not-found)
#
# 	local -i i=0
#
# 	for i in "${!r_qpkg_name[@]}"; do
# 		[[ ${r_qpkg_name[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		printf '%s' "${r_qpkg_author_email[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

#QpkgGetAppAuthor()
# 	{
#
# 	# Return the author of the application contained within the specified QPKG.
#
# 	# Inputs:
# 	#   $1 = QPKG name
#
# 	# Outputs:
# 	#   stdout = application author (first package found).
# 	#   $? = 0 (found), !0 (not-found)
#
# 	local -i i=0
#
# 	for i in "${!r_qpkg_name[@]}"; do
# 		[[ ${r_qpkg_name[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		printf '%s' "${r_qpkg_appl_author[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

#QpkgGetAppAuthorEmail()
# 	{
#
# 	# Return the email address for the author of the application contained within the specified QPKG.
#
# 	# Inputs:
# 	#   $1 = QPKG name
#
# 	# Outputs:
# 	#   stdout = application author (first package found).
# 	#   $? = 0 (found), !0 (not-found)
#
# 	local -i i=0
#
# 	for i in "${!r_qpkg_name[@]}"; do
# 		[[ ${r_qpkg_name[$i]} = "${1:?${FUNCNAME[0]}'()': undefined package name}" ]] || continue
# 		printf '%s' "${r_qpkg_appl_author_email[$i]}"
#
# 		return 0
# 	done
#
# 	return 1
#
# 	}

QpkgGetDatabaseDesc()
	{

	# Inputs:
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = QPKG description.
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_description[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_description[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_description[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseNote()
	{

	# Return any additional notes to be prominently displayed.

	# Inputs:
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = package note (first package found).
	#   $? = 0 (found), !0 (not-found)

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_note[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_note[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_note[$qpkg_default_index]}
		[[ $a = none ]] && return 1
	fi

	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseAbbrvs()
	{

	# Inputs:
	#   $1 = QPKG name (optional): if QPKG name is explicitly stated, then lookup QPKG name in package lists, ignoring current $qpkg_name and $qpkg_index.
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = list of abbreviations that may be used to specify this package
	#   $? = 0 if found, !0 if not

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_abbrvs[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_abbrvs[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_abbrvs[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseDependencies()
	{

	# Inputs:
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = list of QPKGs $qpkg_name depends-upon.
	#   $? = 0 (found), !0 (not-found)

	local alt=''
	local first=''
	local found=false
	local g=''
	local oldIFS=$IFS
	local out=''
	local x=''

	g=${r_qpkg_depends_on[$qpkg_index]}
	[[ $g = none ]] && return 1
	[[ $g = default ]] && g=${r_qpkg_depends_on[$qpkg_default_index]}

	if [[ $g != *'|'* ]]; then		# no alternatives were listed.
		printf '%s' "$g"

		return 0
	fi

	# If buffer contains a pipe character, then need to separately examine each name.
	# 	Read each name by word boundaries.
	# 	If name contains pipe, then read name with IFS as pipe.
	# 		Test each alternative name for compatibility with this NAS. Only output the compatible one.
	#		If none are compatible, then output the first name found.

	IFS=' '

	for x in $g; do
		found=false

		if [[ $x != *'|'* ]]; then
			out+=" $x"
			continue
		fi

		IFS='|'

		for alt in $x; do
			[[ -z $first && -n $alt ]] && first=$alt

			# Test alternative for compatibility

			if QpkgIsDatabaseArchOK "$alt"; then
				out+=" $alt"
				found=true
				break
			fi
		done

		[[ $IFS != "$oldIFS" ]] && IFS=$oldIFS

		if [[ $found = false ]]; then
			out+=" $first"
			first=''
		fi
	done

	printf '%s' "$out"

	return 0

	}

QpkgGetDatabaseDependents()
	{

	# Inputs:
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = list of QPKGs that depend-upon this QPKG.
	#   $? = 0 (found), !0 (not-found)

	[[ -n $qpkg_name && $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	local -a ar=()
	local -i i=-1			# default to not-found.
	local re=\\b${qpkg_name}\\b

	if QPKGs-GRindependent.Exist "$qpkg_name"; then
		for i in "${!r_qpkg_name[@]}"; do
			if [[ ${r_qpkg_depends_on[$i]} =~ $re ]]; then
				[[ ${ar[*]:-} != "${r_qpkg_name[$i]}" ]] && ar+=(${r_qpkg_name[$i]})
			fi
		done
	fi

	if [[ ${#ar[@]} -gt 0 ]]; then
		printf '%s' "${ar[*]}"

		return 0
	fi

	return 1

	}

QpkgGetDatabaseIPKs()
	{

	# Inputs:
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = list of IPKs $qpkg_index depends-upon.
	#   $? = 0 (found), !0 (not-found)

	[[ -n $qpkg_name && $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	local a=''

	a=${r_qpkg_requires_ipks[$qpkg_index]}
	[[ $a = default ]] && a=${r_qpkg_requires_ipks[$qpkg_default_index]}
	[[ $a = none ]] && return 1

	printf '%s' "$a"

	return 0

	}

QpkgGetDatabaseActiveTest()
	{

	# Return any custom commands required to determine if specified QPKG is active or not.

	# Inputs:
	#   $qpkg_default_index (global)
	#   $qpkg_index (global)
	#	$qpkg_name (global)

	# Outputs:
	#   stdout = Bash tests.
	#   $? = 0 (found), !0 (not-found)

	[[ -n $qpkg_name && $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	a=${r_qpkg_test_for_active[$qpkg_index]}
	[[ $a = default ]] && a=${r_qpkg_test_for_active[$qpkg_default_index]}
	[[ $a = none ]] && return 1

	printf '%s' "$a"

	return 0

	}

QpkgGetInstalledServiceAction()
	{

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $stdout = previous action requested.
	#   $? = 0 (found), !0 (not-found)

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local b=''
	[[ -e /var/log/$a.action ]] && b=$(</var/log/${a}.action)

	if [[ -n $b ]]; then
		printf '%s' "$b"
	else
		printf not-found
	fi

	}

QpkgGetInstalledServiceResult()
	{

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $stdout = last known package service status.
	#   $? = 0 (found), !0 (not-found)

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local b=''
	[[ -e /var/log/$a.result ]] && b=$(</var/log/${a}.result)

	if [[ -n $b ]]; then
		printf '%s' "$b"
	else
		printf not-found
	fi

	}

QpkgInstalledServiceResultWasOk()
	{

	# Returns true if previous action for this package is 'ok'.

	# Inputs: (global)
	#   $qpkg_name

	# Outputs: (local)
	#   $? = true/false

	[[ -n $qpkg_name ]] || return

	[[ $(QpkgGetInstalledServiceResult) = ok ]]

	}

QpkgMatchAbbrv()
	{

	# Inputs: (local)
	#   $1 (string) = a potential package abbreviation supplied by user.

	# Inputs: (global)
	#   $r_qpkg_abbrvs[]
	#   $r_qpkg_name[]

	# Outputs: (local)
	#   stdout = matched installable package name (empty if unmatched).
	#   $? = 0 (matched) / !0 (unmatched)

	local -a ar=()
	local -i i=0
	local -i j=0
	local -i z=1			# Default to 'unmatched'.

	for i in "${!r_qpkg_name[@]}"; do
		ar=(${r_qpkg_abbrvs[$i]})

		for j in "${!ar[@]}"; do
			[[ ${ar[$j]} = "$1" ]] || continue
			printf '%s' "${r_qpkg_name[$i]}"
			z=0
			break 2
		done
	done

	return $z

	}

QpkgSetIndex()
	{

	# Find and set the 1-based indexed reference of the named arch-specific QPKG in `packages` file.

	# Inputs: (global)
	#   $r_nas_qpkg_arch
	#   $r_qpkg_arch[]
	#   $qpkg_name
	#   $r_qpkg_name[]

	# Outputs: (local)
	#   $? = 0 (successful) / !0 (failed)

	# Outputs: (global)
	#   $qpkg_index ('0' if QPKG a compatible arch could not be found).

	[[ -n ${qpkg_name:-} ]] || return

	QpkgSetDefaultIndex

	for qpkg_index in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$qpkg_index]} = "$qpkg_name" ]] || continue
		[[ ${r_qpkg_arch[$qpkg_index]} = all || ${r_qpkg_arch[$qpkg_index]} = "$r_nas_qpkg_arch" ]] || continue

		return 0
	done

	qpkg_index=0

	return 1

	}

QpkgSetDefaultIndex()
	{

	# Find and set the 1-based indexed reference of the named QPKG in `packages` file.

	# Inputs: (global)
	#   $qpkg_name
	#   $r_qpkg_name[]

	# Outputs: (local)
	#   $? = 0 (successful) / !0 (failed)

	# Outputs: (global)
	#   $qpkg_default_index ('0' if QPKG could not be found).

	[[ -n ${qpkg_name:-} ]] || return

	for qpkg_default_index in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$qpkg_default_index]} = "$qpkg_name" ]] || continue

		return 0
	done

	qpkg_default_index=0

	return 1

	}

QpkgIsInstalledRepoSelfManaged()
	{

	# Is this QPKG managable by sherpa?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	local a=$(QpkgGetInstalledStoreID "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ -z $a || $a = undefined || $a = sherpa ]]

	}

QpkgIsNtInstalledRepoSelfManaged()
	{

	# Is this QPKG not managable by sherpa?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	! QpkgIsInstalledRepoSelfManaged "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}"

	}

QpkgIsBackupExist()
	{

	# Does this QPKG have an existing `backup` file?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#	$r_qpkg_bu_path
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	[[ -e $r_qpkg_bu_path/${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}.config.tar.gz ]]

	}

QpkgIsUpgradable()
	{

	# Does an upgraded QPKG exist?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	QpkgIsInstalled "$a" && QpkgIsInstalledAuthorOk "$a" && QpkgIsInstalledRepoSelfManaged "$a" && [[ $(QpkgGetInstalledVer "$a") != "$(QpkgGetDatabaseVer "$a")" ]] && QpkgIsDatabaseArchOK "$a" && QpkgIsDatabaseMinOSVerOk "$a" && QpkgIsDatabaseMaxOSVerOk "$a" && QpkgIsDatabaseMinRAMOk "$a"

	}

QpkgIsInstallable()
	{

	# Can this QPKG be installed?

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index

	# Outputs: (local)
	#   $? = true/false

	[[ $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	QpkgIsNtReallyInstalled && QpkgIsDatabaseArchOK && QpkgIsDatabaseMinOSVerOk && QpkgIsDatabaseMaxOSVerOk && QpkgIsDatabaseMinRAMOk

	}

QpkgIsDatabaseDependent()
	{

	# Does this QPKG depend on any other QPKGs?

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index

	# Outputs: (local)
	#   $? = true/false

	[[ $qpkg_index -gt 0 && $qpkg_default_index -gt 0 ]] || return

	local a=''

	a=${r_qpkg_depends_on[$qpkg_index]}
	[[ $a = default ]] && a=${r_qpkg_depends_on[$qpkg_default_index]}
	[[ $a != none ]]

	}

QpkgIsDatabaseIndependent()
	{

	# Will this package run independent of other QPKGs?

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index

	# Outputs: (local)
	#   $? = true/false

	! QpkgIsDatabaseDependent

	}

QpkgIsDatabaseArchOK()
	{

	# Does an arch-compatible QPKG exist to suit this NAS?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	local a=$(QpkgGetDatabaseURL "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ -n $a && $a != none ]]

	}

QpkgIsDatabaseMinRAMOk()
	{

	# Does this NAS meets the minimum RAM requirements for QPKG name?

	# Inputs: (local)
	#   $1 (optional) = QPKG name.

	# Inputs: (global)
	#	$r_nas_ram_kb
	#   $qpkg_name (default)

	# Outputs: (local)
	#   $? = true/false

	local a=$(QpkgGetDatabaseMinRAM "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ -n $a ]] && [[ $a = none || $r_nas_ram_kb -ge $a ]]

	}

QpkgIsDatabaseMinOSVerOk()
	{

	# Does this NAS meets the minimum OS firmware version requirements for QPKG name?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$r_nas_firmware_version
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=$(QpkgGetDatabaseMinOSVer "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ -n $a ]] && [[ $a = none || ${r_nas_firmware_version//.} -ge $a ]]

	}

QpkgIsDatabaseMaxOSVerOk()
	{

	# Does this NAS meets the maximum OS firmware version requirements for QPKG name?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$r_nas_firmware_version
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=$(QpkgGetDatabaseMaxOSVer "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ -n $a ]] && [[ $a = none || ${r_nas_firmware_version//.} -le $a ]]

	}

QpkgIsDatabaseCanBackup()
	{

	# Does this QPKG service-script support `backup` and `restore` actions?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$r_qpkg_can_backup[]
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name (default for $1)
	#	$r_qpkg_name[]

	# Outputs: (local)
	#   $? = true/false

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_can_backup[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_can_backup[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_can_backup[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	[[ $a = true ]]

	}

QpkgIsDatabaseCanRestartToUpdate()
	{

	# Does this QPKG service-script support updating the internal application when the QPKG is restarted?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)
	#	$r_qpkg_name[]
	#	$r_qpkg_can_restart_to_update[]

	# Outputs: (local)
	#   $? = 0 (true), !0 (false) (first package found).

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local -i i=0

	for i in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$i]} = "$a" ]] || continue
		${r_qpkg_can_restart_to_update[$i]} && return 0 || break
	done

	return 1

	}

QpkgIsDatabaseCanClean()
	{

	# Does this QPKG service-script support cleaning of the internal application?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = 0 (true), 1 (false) (first package found).

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}
	local -i i=0

	for i in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$i]} = "$a" ]] || continue
		${r_qpkg_can_clean[$i]} && return 0 || break
	done

	return 1

	}

QpkgIsDatabaseSherpaCompatible()
	{

	# Is this QPKG service-script compatible with enhanced actions supplied by sherpa?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name (default for $1)
	#	$r_qpkg_is_sherpa_compatible[]

	# Outputs: (local)
	#   $? = true/false

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_is_sherpa_compatible[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_is_sherpa_compatible[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_is_sherpa_compatible[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	[[ $a = true ]]

	}

QpkgIsDatabaseUniqueUnpack()
	{

	# Was this QPKG built to extract itself to a unique path? Requires QDK 2.3.14 or-later.
	# If true, then this QPKG can be installed/reinstalled/upgraded concurrently with other QPKGs.

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#   $qpkg_default_index
	#   $qpkg_index
	#	$qpkg_name (default for $1)
	#	$r_qpkg_is_unique_unpack[]

	# Outputs: (local)
	#   $? = true/false

	local a=''
	local -i i=0

	if [[ -n ${1:-} ]]; then
		for i in "${!r_qpkg_name[@]}"; do
			[[ ${r_qpkg_name[$i]} = "$1" ]] || continue
			a=${r_qpkg_is_unique_unpack[$i]}			# Always grab first found as default.
			break
		done
	else
		a=${r_qpkg_is_unique_unpack[$qpkg_index]}
		[[ $a = default ]] && a=${r_qpkg_is_unique_unpack[$qpkg_default_index]}
	fi

	[[ -n $a ]] || a=none
	[[ $a = true ]]

	}

QpkgIsDatabaseWillLog()
	{

	# Does this QPKG service-script log all actions? If so, when an action fails, user can be directed to check the service-script log.

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = 0 (true) / !0 (false) (first package found).

	local -i i=0

	for i in "${!r_qpkg_name[@]}"; do
		[[ ${r_qpkg_name[$i]} = "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}" ]] || continue
		${r_qpkg_will_log[$i]} && return 0 || break
	done

	return 1

	}

QpkgIsInstalledAutoUpdate()
	{

	# Is the installed QPKG set to auto-update on restart?

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	[[ $(/sbin/getcfg "$a" Auto_Update -u -f /etc/config/qpkg.conf) = TRUE ]]

	}

QpkgIsInstalledAuthorOk()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	[[ $(QpkgGetDatabaseAuthor "$a") = "$(QpkgGetInstalledAuthor "$a")" ]]

	}

QpkgIsNtInstalledAuthorOk()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	! QpkgIsInstalledAuthorOk "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}"

	}

QpkgIsInstalled()
	{

	# Check if specified QPKG is installed, and that QPKG author is valid.

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	$GREP_CMD -q "^\[$a\]" /etc/config/qpkg.conf && QpkgIsInstalledAuthorOk "$a"

	}

QpkgIsNtInstalled()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	! QpkgIsInstalled "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}"

	}

QpkgIsReallyInstalled()
	{

	# Check if specified QPKG is installed, and don't check anything else.

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	$GREP_CMD -q "^\[$a\]" /etc/config/qpkg.conf

	}

QpkgIsNtReallyInstalled()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	! QpkgIsReallyInstalled "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}"

	}

QpkgIsInstalledMissing()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   stdout = package installation date.
	#   $? = true (found) / false (not-found).

	local a=$(QpkgGetInstalledPath "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}")

	[[ $a != undefined && ! -d $a ]]

	}

QpkgIsInstalledEnabled()
	{

	# Inputs: (local)
	#   $1 (string, optional override for $qpkg_name) = QPKG name: if $1 is explicitly stated, lookup $1 in package lists, ignoring current $qpkg_name and $qpkg_index.

	# Inputs: (global)
	#	$qpkg_name (default for $1)

	# Outputs: (local)
	#   $? = true/false

	local a=${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}

	[[ $(/sbin/getcfg "$a" Enable -u -f /etc/config/qpkg.conf) = TRUE ]]

	}

LoadQpkgSigning()
	{

	# Outputs: (global)
	#	$r_qpkg_certificate
	#	$r_qpkg_signature

	r_qpkg_certificate=''
	r_qpkg_signature=''

	# This certificate block is the same used by QNAP for LicenseCenter.
	read -r -d '' r_qpkg_certificate << EOB
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIFALhDVuwwDQYJKoZIhvcNAQELBQAwgYAxCzAJBgNVBAYT
AlRXMQ8wDQYDVQQIDAZUYWl3YW4xDzANBgNVBAcMBlRhaXBlaTENMAsGA1UECgwE
UU5BUDEMMAoGA1UECwwDTkFTMRAwDgYDVQQDDAdRTkFQX0NBMSAwHgYJKoZIhvcN
AQkBFhFzZWN1cml0eUBxbmFwLmNvbTAeFw0yMjAzMTgwNzM5MTRaFw0yNTAzMTcw
NzM5MTRaMIGGMQswCQYDVQQGEwJUVzEPMA0GA1UECAwGVGFpd2FuMQ8wDQYDVQQH
DAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsMA05BUzEWMBQGA1UEAwwN
TGljZW5zZUNlbnRlcjEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlAcW5hcC5jb20w
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/bAgbZryVvBXfpBHNUKQV
sAkAfvDXjKnxa7lKHrRIcFcOnf+voUZcP1Ly9qWb782gB2eUHsUS1Xqj4CF/dUJf
FEnOBrQUo9+Q9B3x4oTRpMdky7acP4dxAbt4T92swgaReQXAewy9s9//a52HIBca
1dAA4JPwplqiZ/oh18GDCKxh84Iu9Gcu2J5e+VXEI/KUxCwKUd22aDTpv128MSoq
dYexCerCJtQbgM3cwkkMiDnFpjrsta5iFpyrNKdLoBJ7YbY3d5Onkqy4DjE8hwR7
0j7Qd+3xbMqv3FOCKeLLLn6N03IXHKP/big/MdXKY1dJQVA3/ks/knPH8mhcOM0d
AgMBAAGjPDA6MDgGA1UdHwQxMC8wLaAroCmGJ2h0dHA6Ly9kb3dubG9hZC5xbmFw
LmNvbS9jcmwvcXRzX3YxLmNybDANBgkqhkiG9w0BAQsFAAOCAQEAWlT1GDH6v8G3
laIAs2/RdxhPgtKX4aL+fnTEFNF5V2yH0G4luyq5tHQw+VCHtDM6Z3GXWhciKPAR
upbRcHq744JCFaUb6i8z1w1KVJDaQ38EVE5+JtpoPMrrnb+hKB/gGmi4PoMSpnvX
VCxLbCbBnwi19o6t/MnPbz0shvUB2NDngnal6lYQFw/F8Sr6cSjV6GAY4TOZotdu
+gunwqQtYUycEVfNyiWVk/flgED8R8oxTPl9ZoDGen+OgjkZrvgynKnqPLHyxZSd
hYSoWyWcZWkMCQ+69kOgJVvrRa7z9F9y30uAHXIUrsLV2d/dImVjApMHbZ60iALG
AVIlas0e4g==
-----END CERTIFICATE-----
EOB

	# This digital signature block is the same used by QNAP for LicenseCenter.
	read -r -d '' r_qpkg_signature << EOB
MIME-Version: 1.0
Content-Disposition: attachment; filename=\"smime.p7m\"
Content-Type: application/pkcs7-mime; smime-type=signed-data; name=\"smime.p7m\"
Content-Transfer-Encoding: base64

MIIGtAYJKoZIhvcNAQcCoIIGpTCCBqECAQExDTALBglghkgBZQMEAgEwIwYJKoZI
hvcNAQcBoBYEFAkoseBaFir08zCz63r2YA82DXzxoIIDxzCCA8MwggKroAMCAQIC
BQC4Q1bsMA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJUVzEPMA0GA1UECAwG
VGFpd2FuMQ8wDQYDVQQHDAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsM
A05BUzEQMA4GA1UEAwwHUU5BUF9DQTEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlA
cW5hcC5jb20wHhcNMjIwMzE4MDczOTE0WhcNMjUwMzE3MDczOTE0WjCBhjELMAkG
A1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UEBwwGVGFpcGVpMQ0wCwYD
VQQKDARRTkFQMQwwCgYDVQQLDANOQVMxFjAUBgNVBAMMDUxpY2Vuc2VDZW50ZXIx
IDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAv2wIG2a8lbwV36QRzVCkFbAJAH7w14yp8Wu5Sh60
SHBXDp3/r6FGXD9S8valm+/NoAdnlB7FEtV6o+Ahf3VCXxRJzga0FKPfkPQd8eKE
0aTHZMu2nD+HcQG7eE/drMIGkXkFwHsMvbPf/2udhyAXGtXQAOCT8KZaomf6IdfB
gwisYfOCLvRnLtieXvlVxCPylMQsClHdtmg06b9dvDEqKnWHsQnqwibUG4DN3MJJ
DIg5xaY67LWuYhacqzSnS6ASe2G2N3eTp5KsuA4xPIcEe9I+0Hft8WzKr9xTgini
yy5+jdNyFxyj/24oPzHVymNXSUFQN/5LP5Jzx/JoXDjNHQIDAQABozwwOjA4BgNV
HR8EMTAvMC2gK6AphidodHRwOi8vZG93bmxvYWQucW5hcC5jb20vY3JsL3F0c192
MS5jcmwwDQYJKoZIhvcNAQELBQADggEBAFpU9Rgx+r/Bt5WiALNv0XcYT4LSl+Gi
/n50xBTReVdsh9BuJbsqubR0MPlQh7QzOmdxl1oXIijwEbqW0XB6u+OCQhWlG+ov
M9cNSlSQ2kN/BFROfibaaDzK652/oSgf4BpouD6DEqZ711QsS2wmwZ8ItfaOrfzJ
z289LIb1AdjQ54J2pepWEBcPxfEq+nEo1ehgGOEzmaLXbvoLp8KkLWFMnBFXzcol
lZP35YBA/EfKMUz5fWaAxnp/joI5Ga74Mpyp6jyx8sWUnYWEqFslnGVpDAkPuvZD
oCVb60Wu8/Rfct9LgB1yFK7C1dnf3SJlYwKTB22etIgCxgFSJWrNHuIxggKbMIIC
lwIBATCBijCBgDELMAkGA1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UE
BwwGVGFpcGVpMQ0wCwYDVQQKDARRTkFQMQwwCgYDVQQLDANOQVMxEDAOBgNVBAMM
B1FOQVBfQ0ExIDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tAgUAuENW
7DALBglghkgBZQMEAgGggeQwGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkq
hkiG9w0BCQUxDxcNMjIxMjAyMDMwOTE3WjAvBgkqhkiG9w0BCQQxIgQgvtdZSm+m
c7QevdJma9Em5ycFr3I7Wo4aG40Vcx/mT5IweQYJKoZIhvcNAQkPMWwwajALBglg
hkgBZQMEASowCwYJYIZIAWUDBAEWMAsGCWCGSAFlAwQBAjAKBggqhkiG9w0DBzAO
BggqhkiG9w0DAgICAIAwDQYIKoZIhvcNAwICAUAwBwYFKw4DAgcwDQYIKoZIhvcN
AwICASgwDQYJKoZIhvcNAQEBBQAEggEAuInAOUj+ebOkTqlqg3cf7v2FdKeCvZZn
cunx1xRnHJRVAAvcH/UZ3t7RF6MV5NmEQdVN79NBZl0KU1x7K3zyvcXnkacNuHnI
t+6neKKKkxJmB4hh4ljeYtx9a1RBgwH+PiYyH8+58S7+MF3MVhSH8jEiomgSbvsK
BroOCFQDoYWk14K/VIXW1scmvpNvFNBWwm19pYwi977rF+lPWzMHx/0jVXspFSEd
U48h9xKvPg6CsIlyfuKetHBjZZI6iSCvh2FZOWsD1/W2oGYkkY9Hdff24B34/res
cKXk/K9/JFAONWBbXUpxtzpBCeVJlZS1wQgu4Q+Fr6imaBXJkiyiNg==
EOB

	readonly r_qpkg_certificate
	readonly r_qpkg_signature

	}

MakePath()
	{

	# Inputs: (local)
	#   $1 = path to create.
	#   $2 = reason for this path.

	# Outputs: (local)
	#	$? : 0 = created OK.
	#	   : 1 = creation failed.

	# Outputs: (global)
	#	$show_suggest_raise_issue

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined path} && -n ${2:?${FUNCNAME[0]}'()': undefined reason} ]] || return

	if [[ $1 != undefined ]] && ! mkdir -p "$1"; then
		ShowAsError "unable to create $2 path $(ShowAsFileName "$1") $(ShowAsExitcode "$?")"
		show_suggest_raise_issue=true

		return 1
	fi

	return 0

	}

ClearPath()
	{

	# Clear (empty) an existing directory, but don't delete the directory.
	# Delete files in a relatively safe manner. Parent of directory MUST be specified to avoid an `rm -rf /*` situation because of empty args.

	# Inputs: (local)
	#	$1 = full path to parent of directory name to clear.
	#   $2 = directory name to clear.

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined parent path} && -n ${2:?${FUNCNAME[0]}'()': undefined target path} ]] || return

	local parent=${1:-undefined}
	local target=$($BASENAME_CMD "${2:-undefined}")

	[[ -n $parent && $parent != undefined && -n $target && $target != undefined && -d $parent/$target ]] && rm -rf "${parent:?}/${target:?}"/*

	}

RunAndLog()
	{

	# Run a commandstring, log the results, and show onscreen if required.

	# Inputs: (local)
	#   $1 = commandstring to execute.
	#   $2 = pathfile to record stdout and stderr for commandstring.
	#   $3 = 'log:failure-only' (optional) - if specified, stdout & stderr are only recorded in the specified log if the command failed. Default is to always record stdout & stderr.
	#   $4 = e.g. '10' (optional) - an additional acceptable result code. Any other non-zero result from command will be considered a failure.

	# Inputs: (global)
	#   $r_run_logs_path
	#   $useropt_debug
	#   $useropt_verbose

	# Outputs: (local)
	#   stdout = commandstring stdout and stderr if script is in 'debug' mode.
	#   pathfile (specified as $2) = stdout and stderr from commandstring (specified as $1).
	#   $? = result_code of commandstring.

	[[ -n ${1:?${FUNCNAME[0]}'()': undefined commandstring} && -n ${2:?${FUNCNAME[0]}'()': undefined pathfile} ]] || return

	FuncInit

	MakePath "$r_run_logs_path" 'runtime logs'

	local -r r_log_pathfile=$($MKTEMP_CMD "$r_run_logs_path"/"${FUNCNAME[0]}"_XXXXXX)
	local -i z=0

	ShowAsCommand "$1" > "$2"
	DebugAsProc "exec: '$1'"

	if [[ $useropt_verbose = true ]]; then
		eval "$1 > >($TEE_CMD $r_log_pathfile) 2>&1"		# NOTE: `tee` buffers stdout here
		z=$?
	else
		(eval "$1" > "$r_log_pathfile" 2>&1)				# run in a subshell to suppress 'Terminated' message later
		z=$?
	fi

	if [[ -e $r_log_pathfile ]]; then
		ShowAsResultAndStdout "$z" "$(<"$r_log_pathfile")" >> "$2"
		rm -f "$r_log_pathfile" 2> /dev/null
	else
		ShowAsResultAndStdout "$z" '<null>' >> "$2"
	fi

	case $z in
		0|"${4:-}")
			[[ ${3:-} != log:failure-only || $useropt_debug = true ]] && AddExtLogToSessLog "$2"
			DebugAsDone 'exec: complete'
			[[ $useropt_debug = false ]] && rm -f "$2" 2> /dev/null
			;;
		*)
			AddExtLogToSessLog "$2"
			DebugAsError 'exec: complete, but with errors'
	esac

	FuncExit $z

	}

DeDupeWords()
	{

	[[ -n ${1:-} ]] || return

	tr ' ' '\n' <<< "$1" | $SORT_CMD | $UNIQ_CMD | tr '\n' ' ' | $SED_CMD 's|^[[:blank:]]*||;s|[[:blank:]]*$||'

	}

FileMatchesMD5()
	{

	# Inputs: (local)
	#   $1 = pathfile to generate an MD5 checksum for.
	#   $2 = MD5 checksum to compare against.

	[[ $($MD5SUM_CMD "${1:?${FUNCNAME[0]}'()': undefined pathfile}" | cut -f1 -d' ') = "${2:?${FUNCNAME[0]}'()': undefined checksum}" ]]

	}

Pluralise()
	{

	[[ ${1:-0} -ne 1 ]] && printf s

	}

Capitalise()
	{

	# Capitalise first character of $1.

	[[ -n ${1:-} ]] || return

	if [[ $1 == sherpa* ]]; then
		printf '%s' "$1"
	else
		printf '%s' "$(Uppercase ${1:0:1})${1:1}"
	fi

	}

Uppercase()
	{

	tr 'a-z' 'A-Z' <<< "${1:-}"

	}

Lowercase()
	{

	tr 'A-Z' 'a-z' <<< "${1:-}"

	}

LTrim()
	{

	# Trim leading whitespace from $1.

	[[ -n ${1:-} ]] || return

	printf '%s' "${1##+(' ')}"

	}

RTrim()
	{

	# Trim trailing whitespace from $1.

	[[ -n ${1:-} ]] || return

	printf '%s' "${1%%+(' ')}"

	}

Trim()
	{

	# Trim leading and trailing whitespace from $1.

	[[ -n ${1:-} ]] || return

	RTrim "$(LTrim "$1")"

	}

FormatAsThous()
	{

	# Format as thousands.

	# A string-based thousands-group formatter totally unreliant on locale.
	# Why? Because builtin `printf` in 32b ARM QTS versions doesn't follow locale. ¯\_(ツ)_/¯

	# Inputs: (local)
	# 	$1 = integer value

	local a=$($SED_CMD 's/[^0-9]*//g' <<< "${1:-}")	# Strip everything not a numeral.
	local b=''
	local c=''

	while [[ ${#a} -gt 0 ]]; do
		b=${a:${#a}<3?0:-3}							# A nifty trick found here: https://stackoverflow.com/a/19858692

		if [[ -z $c ]]; then
			c=$b
		else
			c=$b,$c
		fi

		if [[ ${#b} -eq 3 ]]; then
			a=${a%???}								# Trim rightside 3 characters.
		else
			break
		fi
	done

	printf '%s' "$c"

	return 0

	}

FormatAsIsoBytes()
	{

	$AWK_CMD 'BEGIN{ u[0]="B"; u[1]="kB"; u[2]="MB"; u[3]="GB"} { n = $1; i = 0; while(n > 1000) { i+=1; n= int((n/1000)+0.5) } print n u[i] } ' <<< "$1"

	}

ShowTitle()
	{

	# Inputs: (global)
	# 	$show_title
	# 	$title_shown
	# 	$useropt_verbose

	# Outputs: (global)
	# 	$title_shown

	[[ $show_title = true && $title_shown = false && $useropt_verbose = false ]] || return

	EraseThisLine

	# Only show ASCII title when no arguments have been specified.

	if [[ -z ${r_args_raw[*]:-} ]]; then
		Display "$(ShowTitleArt)"
	else
		Display "$(ShowAsTitleName) $(ShowAsVersion)"
	fi

	title_shown=true

	}

ShowAsTitleName()
	{

	TextBrightWhite sherpa

	}

ShowTitleArt()
	{

	Display "$(TextBrightOrange '     _')"
	Display "$(TextBrightOrange ' ___| |__   ___ _ __ _ __   __ _')"
	Display "$(TextBrightOrange "/ __| '_ \ / _ \ '__| '_ \ / _\` |")  $(ShowAsDescription)"
	Display "$(TextBrightOrange '\__ \ | | |  __/ |  | |_) | (_| |')  $(ShowAsCopyrightBasic)"
	Display "$(TextBrightOrange '|___/_| |_|\___|_|  | .__/ \__,_|')  $(ShowAsVersion)"
	Display "$(TextBrightOrange '                    |_|')"

	}

ShowAsDescription()
	{

	printf '%s' '<?title_description?>'

	}

ShowAsCopyrightBasic()
	{

	printf '%s' '<?copyright_basic?>'

	}

ShowAsVersion()
	{

	printf '%s' "v$r_this_script_ver"

	}

#ShowAsEmail()
# 	{
#
# # 	printf '%s' '<?email?>'
# 	TextUnderlinedCyan '<?email?>'
#
# 	}

ShowAsAction()
	{

	TextBrightYellow '[action]'

	}

ShowAsPackages()
	{

	TextBrightOrange '[packages]'

	}

ShowAsPackageGroup()
	{

	TextBrightOrange '[package group]'

	}

ShowAsOptions()
	{

	TextBrightRed '[options]'

	}

ShowAsPackageName()
	{

	printf '%s' "${1:-${qpkg_name:?${FUNCNAME[0]}'()': undefined package name}}"

	}

ShowAsFileName()
	{

	printf '%s' "'${1:?${FUNCNAME[0]}'()': undefined filename}'"

	}

ShowAsURL()
	{

	TextUnderlinedCyan "${1:?${FUNCNAME[0]}'()': undefined URL}"

	}

ShowAsExitcode()
	{

	printf '%s' "[${1:?${FUNCNAME[0]}'()': undefined exitcode}]"

	}

ShowAsLogFilename()
	{

	printf '%s' "${r_chars_results}log file: '${1:?${FUNCNAME[0]}'()': undefined filename}'"

	}

ShowAsCommand()
	{

	echo "${r_chars_results}command: '${1:?${FUNCNAME[0]}'()': undefined commandstring}'"

	}

ShowAsResultAndStdout()
	{

	[[ -n ${1:-} ]] || return
	[[ -n ${2:-} ]] || return

	local a=$r_chars_results

	[[ ${1:-0} -ne 0 ]] && a=$r_chars_alert

	echo "${a}result_code: $(ShowAsExitcode "$1") ***** stdout/stderr begins below *****"
	echo "$2"
	echo "${a}***** stdout/stderr is complete *****"

	}

DisplayProcReport()
	{

	# Inputs: (local)
	#	$1 = report type string (optional)

	# Inputs: (global)
	#	$report_title_shown

	# Outputs: (local)
	#	stdout = formatted string

	# Outputs: (global)
	#	$report_title_shown

	[[ ${report_title_shown:=false} = false ]] || return

	local a=''

	[[ -n ${1:-} ]] && a="$1 "

	ShowAsProc "${a}report"

	report_title_shown=true

	}

DebugInfoMajSepr()
	{

	# Debug info major separator.

	DebugInfo "$(eval printf '%0.s=' "{1..$r_debug_log_full_width}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugInfoMinSepr()
	{

	# Debug info minor separator.

	DebugInfo "$(eval printf '%0.s-' "{1..$r_debug_log_full_width}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugExtLogMinSepr()
	{

	# Debug external log minor separator.

	DebugAsLog "$(eval printf '%0.s-' "{1..$r_debug_log_full_width}")" # `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugHardware()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" hardware "$2" "$3"

	}

DebugKernel()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" kernel "$2" "$3"

	}

DebugFirmware()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" firmware "$2" "$3"

	}

DebugOS()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" os "$2" "$3"

	}

DebugShell()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" shell "$2" "$3"

	}

DebugUserspace()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" userspace "$2" "$3"

	}

DebugScript()
	{

	# Inputs: (local)
	#	$1 = name
	#	$2 = value

	DebugItem ok script "$1" "$2"

	}

DebugIpk()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" ipk "$2" "$3"

	}

DebugQpkg()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = name
	#	$3 = value

	DebugItem "$1" qpkg "$2" "$3"

	}

DebugItem()
	{

	# Inputs: (local)
	#	$1 = type
	#	$2 = category
	#	$3 = name
	#	$4 = value

	[[ -n ${1:-} ]] || return
	[[ -n ${2:-} ]] || return
	[[ -n ${3:-} ]] || return
	[[ -n ${4:-} ]] || return

	local a=$(Uppercase "$2")

	case $1 in
		error)
			DebugErrorTabld "$a" "$3" "$4"
			;;
		warning)
			DebugWarningTabld "$a" "$3" "$4"
			;;
		info)
			DebugInfoTabld "$a" "$3" "$4"
			;;
		*)
			DebugDetectTabld "$a" "$3" "$4"
	esac

	}

DebugDetectTabld()
	{

	# Debug detected tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsDetect "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and 'none' as third field.
		DebugAsDetect "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsDetect "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsDetect "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugInfoTabld()
	{

	# Debug info tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsInfo "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and 'none' as third field.
		DebugAsInfo "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsInfo "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsInfo "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugWarningTabld()
	{

	# Debug warning tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required
		DebugAsWarn "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and 'none' as third field
		DebugAsWarn "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsWarn "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsWarn "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugErrorTabld()
	{

	# Debug error tabulated.

	if [[ -z ${3:-} ]]; then			# If $3 is nothing, then assume only 2 fields are required.
		DebugAsError "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# If $3 is only a whitespace then print $2 with trailing colon and 'none' as third field.
		DebugAsError "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# If $3 has a trailing whitespace then print $3 without the trailing whitespace.
		DebugAsError "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsError "$(printf "%${r_debug_log_first_column_width}s: %${r_debug_log_second_column_width}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugVar()
	{

	# Inputs: (local)
	#   $1 = variable name

	# Outputs: (global)
	#   to debug log

	if [[ -n ${!1:-} ]]; then
		DebugAsVar "\$$1 : '${!1}'"
	else
		DebugAsVar "\$$1 : null"
	fi

	}

DebugArray()
	{

	# Inputs: (local)
	#   $1 = array name
	#   $2 = array contents: i.e. "${myarray[*]}"

	# Outputs: (global)
	#   to debug log

	[[ -n ${1:-} ]] || return

	if [[ -n ${2:-} ]]; then
		DebugAsArray "\$$1 : ['$2']"
	else
		DebugAsArray "\$$1 : [null]"
	fi

	}

DebugInfo()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${2:-} = ' ' || ${2:-} = "'' " ]]; then	# If $2 has no usable content then print $1 with trailing colon and 'none' as second field.
		DebugAsInfo "$1: none"
	elif [[ -n ${2:-} ]]; then
		DebugAsInfo "$1: ${2:-}"
	else
		DebugAsInfo "$1"
	fi

	}

FuncInit()
	{

	# Debug function entry.

	local -r r_var_name=${FUNCNAME[1]}_STARTNANOSECONDS
	local var_safe_name=${r_var_name//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	eval "$var_safe_name=$(ConvertNowToNanoseconds)"

	DebugAsFuncEn

	}

FuncExit()
	{

	# Debug function exit.

	local -r r_var_name=${FUNCNAME[1]}_STARTNANOSECONDS
	local var_safe_name=${r_var_name//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	DebugAsFuncEx "${1:-0}" "$(ConvertMillisecondsToFuncDuration "$(CalcMillisecondsDiffFromNanoseconds "${!var_safe_name}" "$(ConvertNowToNanoseconds)")")"

	return ${1:-0}

	}

FuncForkInit()
	{

	# Debug forked function entry.

	trap '[[ -n ${action_pidfile:-} && -e $action_pidfile ]] && rm -f "$action_pidfile" 2> /dev/null; [[ -n ${pidfile:-} && -e ${pidfile:-} ]] && rm -f "$pidfile" 2> /dev/null; exit' SIGINT

	# Redirect debug output to a temporary log, then add it to session log before exiting. This will keep action log progress in-order.
	original_sess_active_pathfile=$sess_active_pathfile
	MakePath "$r_action_logs_path" 'action logs'
	sess_active_pathfile=$($MKTEMP_CMD "$r_action_logs_path"/"${FUNCNAME[1]}"_XXXXXX)

	local -r r_var_name=${FUNCNAME[1]}_STARTNANOSECONDS
	local var_safe_name=${r_var_name//[.-]/_}
	var_safe_name=${var_safe_name//:/_}
	eval "$var_safe_name=$(ConvertNowToNanoseconds)"

	DebugAsFuncEn

	}

FuncForkExit()
	{

	# Debug forked function exit.

	local -r r_var_name=${FUNCNAME[1]}_STARTNANOSECONDS
	local var_safe_name=${r_var_name//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	SendActionStatus ex
	DebugAsFuncEx "${1:-0}" "$(ConvertMillisecondsToFuncDuration "$(CalcMillisecondsDiffFromNanoseconds "${!var_safe_name}" "$(ConvertNowToNanoseconds)")")"

	if [[ -n $sess_active_pathfile && -e $sess_active_pathfile ]]; then
		if [[ -s $sess_active_pathfile ]]; then
			$CAT_CMD "$sess_active_pathfile" >> "$original_sess_active_pathfile"
		fi

		rm -f "$sess_active_pathfile" 2> /dev/null
	fi

	[[ -n ${action_pidfile:-} && -e $action_pidfile ]] && rm -f "$action_pidfile" 2> /dev/null; [[ -n ${pidfile:-} && -e ${pidfile:-} ]] && rm -f "$pidfile" 2> /dev/null

	exit ${1:-0}

	}

CalcAmountDiff()
	{

	# Inputs: (local)
	#	$1 = e.g. start time in seconds/milliseconds.
	#	$2 = e.g. end time in seconds/milliseconds.

	# Outputs: (local)
	#	stdout = difference.

	if [[ $2 -gt $1 ]]; then
		printf '%s' "$(($2-$1))"
	else
		printf '%s' "$(($1-$2))"
	fi

	} 2> /dev/null

CalcMillisecondsDiffFromNanoseconds()
	{

	# Inputs: (local)
	#	$1 = start time in nanoseconds.
	#	$2 = end time in nanoseconds.

	# Outputs: (local)
	#	stdout = difference in milliseconds.

	printf '%s' "$((($2-$1)/(10**6)))"

	} 2> /dev/null

ConvertSecondsToFullDate()
	{

	# Inputs: (local)
	#	$1 = Epoch seconds.

	# Outputs: (local)
	#	stdout = real date.

	/bin/date -d @"$1" +%c | tr -s ' '

	} 2> /dev/null

ConvertSecondsToDatecode()
	{

	# Convert supplied epoch-seconds into sherpa datecode.

	# Inputs: (local)
	#	$1 = Epoch seconds.

	# Outputs: (local)
	#	stdout = datecode.

	[[ -n ${1:-} ]] || return

	local a=$($SED_CMD 's/[^0-9]*//g' <<< "${1:-}")		# Strip everything not a numeral.

	if [[ ${#a} -ne 10 ]]; then
		printf 000000
		return 1
	fi

	/bin/date -d @"$a" '+%y%m%d'

	} 2> /dev/null

ConvertSecondsToTime()
	{

	# Inputs: (local)
	#	$1 = Epoch seconds.

	# Outputs: (local)
	#	stdout = time component only.

	/bin/date -d @"$1" '+%-l:%M:%S %p' | tr -s ' '

	} 2> /dev/null

ConvertSecondsToDuration()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# Inputs: (local)
	#	$1 = a time in seconds to convert to 'HHh:MMm:SSs' or, if less than 1 minute, to 'S seconds'.

	((h=${1:-0}/3600))
	((m=(${1:-0}%3600)/60))
	((s=${1:-0}%60))

	if [[ $h -gt 0 ]]; then
		printf '%01dh:%02dm:%02ds' "$h" "$m" "$s"
	elif [[ $m -gt 0 ]]; then
		printf '%01dm:%02ds' "$m" "$s"
	else
		[[ $s -eq 0 ]] && s=1			# Never show zero seconds as a duration (bash isn't that fast).

		if [[ $s -eq 1 ]]; then
			printf '%d second' "$s"
		else
			printf '%d seconds' "$s"
		fi
	fi

	} 2> /dev/null

ConvertMillisecondsToSeconds()
	{

	# Inputs: (local)
	#	$1 = milliseconds.

	# Outputs: (local)
	#	stdout = seconds.

	printf '%s' "$(($1/(10**3)))"

	} 2> /dev/null

ConvertMillisecondsToDuration()
	{

	# Inputs: (local)
	#	$1 = milliseconds to convert to 'HHh:MMm:SSs' or, if less than 1 minute, to 'S seconds'.

	ConvertSecondsToDuration "$(ConvertMillisecondsToSeconds "$1")"

	} 2> /dev/null

ConvertMillisecondsToFuncDuration()
	{

	# NOTE: This formatter is only used by script function timers.

	# Inputs: (local)
	#	$1 = duration in milliseconds.

	if [[ ${1:-0} -lt 30000 ]]; then
		printf '%s' "$(FormatAsThous "${1:-0}")ms" | $TAIL_CMD -n1			# Prevent "broken pipe" error: https://superuser.com/a/642932
	else
		ConvertMillisecondsToDuration "$1"
	fi

	} 2> /dev/null

ConvertNanosecondsToMilliseconds()
	{

	# Inputs: (local)
	#	$1 = nanoseconds.

	# Outputs: (local)
	#	stdout = milliseconds.

	printf '%s' "$(($1/(10**6)))"

	} 2> /dev/null

ConvertDateCodeToExtendedDate()
	{

	# Inputs: (local)
	#	$1 = datecode in the format 'YYMMDD'. Example: '240928'

	# Outputs: (local)
	#	stdout = extended date format without time. Example: 'Sun 28 Sep 2024'

	[[ -n ${1:-} ]] || return

	local a=$($SED_CMD 's/[^0-9]*//g' <<< "${1:-}")		# Strip everything not a numeral.

	if [[ ${#a} -ne 6 ]]; then
		printf '%s' "$1"
		return 1
	fi

	/bin/date -d ${a::2}-${a:2:2}-${a:4:2} '+%a %d %b %Y'

	} 2> /dev/null

ConvertNowToFullDate()
	{

	# Outputs: (local)
	#	stdout = real date.

	/bin/date +%c | tr -s ' '

	} 2> /dev/null

ConvertNowToSeconds()
	{

	# Outputs: (local)
	#	stdout = epoch seconds.

	/bin/date +%s

	} 2> /dev/null

ConvertNowToMilliseconds()
	{

	# Outputs: (local)
	#	stdout = epoch milliseconds.

	ConvertNanosecondsToMilliseconds "$(ConvertNowToNanoseconds)"

	} 2> /dev/null

ConvertNowToNanoseconds()
	{

	# Outputs: (local)
	#	stdout = epoch nanoseconds.

	/bin/date +%s%N

	} 2> /dev/null

FormatAsLongMinutesSecs()
	{

	# Inputs: (local)
	#	$1 = a time in long minutes and seconds to convert to 'MMMm:SSs'.

	# Separate minutes from seconds
	local m=${1%%:*}
	local s=${1#*:}

	# Remove leading whitespace
	m=${m##* }
	s=${s##* }

	printf '%01dm:%02ds\n' "$((10#$m))" "$((10#$s))"

	} 2> /dev/null

DebugAsFuncEn()
	{

	DebugThis "(>>) ${FUNCNAME[2]}()"

	}

DebugAsFuncEx()
	{

	DebugThis "(<<) ${FUNCNAME[2]}|${1:-0}|${2:-}"

	}

DebugAsProc()
	{

	[[ -n $1 ]] && DebugThis "(--) $1"

	}

DebugAsDone()
	{

	[[ -n $1 ]] && DebugThis "(==) $1"

	}

DebugAsDetect()
	{

	[[ -n $1 ]] && DebugThis "(**) $1"

	}

DebugAsInfo()
	{

	[[ -n $1 ]] && DebugThis "(II) $1"

	}

DebugAsWarn()
	{

	[[ -n $1 ]] && DebugThis "(WW) $1"

	}

DebugAsError()
	{

	[[ -n $1 ]] && DebugThis "(EE) $1"

	}

DebugAsLog()
	{

	[[ -n $1 ]] && DebugThis "(LL) $1"

	}

DebugAsVar()
	{

	[[ -n $1 ]] && DebugThis "(vv) $1"

	}

DebugAsArray()
	{

	[[ -n $1 ]] && DebugThis "(aa) $1"

	}

DebugThis()
	{

	[[ -n ${1:-} ]] || return

	[[ ${useropt_verbose:-false} = true ]] && ShowAsDebug "$1"
	WriteToLog dbug "$1"

	}

AddExtLogToSessLog()
	{

	# Add the contents of pathfile $1 to the session debug log, with each line formatted as an external log entry.

	local a=''
	local b=false

	if [[ $useropt_verbose = true ]]; then   # Prevent external log contents appearing onscreen again, because they've already been seen live.
		b=true
		useropt_verbose=false
	fi

	DebugAsLog 'adding external log to main log'
	DebugExtLogMinSepr
	DebugAsLog "$(ShowAsLogFilename "${1:?${FUNCNAME[0]}'()': undefined pathfile}")"

	while read -r a; do
		DebugAsLog "$a"
	done < "$1"

	DebugExtLogMinSepr
	useropt_verbose=$b

	}

ShowAsProcLong()
	{

	ShowAsProc "${1:-} (might take a while)" "${2:-}"

	} >&2

ShowAsProc()
	{

	# Inputs: (local)
	#	$1 = task being carried-out.
	#	$2 = trailing task (after the ellipsis) (optional). If specified, $useropt_terse will be ignored.

	# Inputs: (global)
	#	$r_chars_ellipsis
	#	$useropt_terse
	#	$useropt_verbose

	[[ -n ${1:-} ]] || return

	local a=$1
	local b=''
	[[ -n ${2:-} ]] && b=${2:-}
	local c="$a $r_chars_ellipsis $b"

	if [[ ${useropt_verbose:=false} = false && ${useropt_terse:=true} = true ]] || [[ ${useropt_verbose:=false} = false && -n ${2:-} ]]; then
		OpStepClearWait "$(TextBrightYellow proc)" "$c"
	else
		OpStepClear "$(TextBrightYellow proc)" "$c"
	fi

	WriteToLog proc "$c"

	} >&2

ShowAsDebug()
	{

	[[ -n ${1:-} ]] || return

	OpStepClear "$(TextBlackOnCyan dbug)" "$1"

	}

ShowAsNote()
	{

	# Note to user.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightYellow note)" "$a"
	WriteToLog note "$a"

	} >&2

ShowAsDone()
	{

	# Process completed OK.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightGreen 'done')" "$a"
	WriteToLog 'done' "$a"

	} >&2

ShowAsWarn()
	{

	# Warning only.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightOrange warn)" "$a"
	WriteToLog warn "$a"

	} >&2

ShowAsAbort()
	{

	# Fatal abort.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed bort)" "$a"
	WriteToLog bort "$a"
	SetError

	} >&2

ShowAsFail()
	{

	# Non-fatal error.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed fail)" "$a"
	WriteToLog fail "$a"

	} >&2

ShowAsError()
	{

	# Fatal error.

	local a=''

	[[ -n ${1:-} ]] && a=$(AddPeriod "$1") || return

	OpStepClear "$(TextBrightRed derp)" "$a"
	WriteToLog derp "$a"
	SetError

	} >&2

ShowAsQuiz()
	{

	[[ -n ${1:-} ]] || return

	OpStepClearWait "$(TextBrightOrangeBlink quiz)" "$1:"
	WriteToLog quiz "$1:"

	}

ShowAsQuizDone()
	{

	[[ -n ${1:-} ]] || return

	OpStepClear "$(TextBrightOrange quiz)" "$1"

	}

AddPeriod()
	{

	[[ -n ${1:-} ]] || return

	[[ ${1: -1} != ':' && ${1: -1} != '?' && ${1: -1} != '.' ]] && printf '%s.' "$1" || printf '%s' "$1"

	}

ShowAsPercentProgress()
	{

	# Show single action package progress as percent-complete and a fraction of the total.

	# Inputs: (local)
	#	$1 = verb (present) (optional)
	#	$2 = expected action duration: 'long' (optional)
	#	$3 = ok count
	#	$4 = skip count
	#	$5 = fail count
	#	$6 = total count

	local -r r_a=${1:-}
	local -i b=${3:-0}
	local -i c=${4:-0}
	local -i d=${5:-0}
	local -i e=${6:-0}
	local -r r_f=$(PercFrac "$b" "$c" "$d" "$e")

	if [[ ${2:-} != long ]]; then
		ShowAsProc "$r_a" "$r_f"
	else
		ShowAsProcLong "$r_a" "$r_f"
	fi

	[[ $((b+c+d)) -ge $e ]] && sleep 0.5

	return 0

	} >&2

PercFrac()
	{

	# Calculate percent-complete and a fraction of the total.

	# Inputs: (local)
	#	$1 = ok count
	#	$2 = skip count
	#	$3 = fail count
	#	$4 = total count

	local -i a=$((${1:-0}+${2:-0}+${3:-0}))
	local -i b=${4:-0}
	local c=''

	[[ $b -gt 0 ]] || return		# No-point calculating a fraction of zero.

	if [[ $a -gt $b ]]; then
		a=$b
		c='100%'
	else
		c="$((200*(a+1)/(b+1)%2+100*(a+1)/(b+1)))%"
	fi

	printf '%s' "$c ($(TextBrightWhite "$a")/$(TextBrightWhite "$b"))"

	return 0

	} 2> /dev/null

ShowAsIterativeProgress()
	{

	# Show single action package progress as an incrementing amount with no limit.

	# Inputs: (local)
	#	$1 = operation 		"calculating"
	#	$2 = count1			15
	#	$3 = suffix1		"iterations"
	#	$4 = count2			560
	#	$5 = suffix2		"packages"
	#	$6 = expected action duration: 'long' (optional) 'short' (default)

	local -r r_a=${1:?${FUNCNAME[0]}'()': undefined action}
	local -i b=${2:-0}
	local -r r_c=${3:?${FUNCNAME[0]}'()': undefined suffix1}
	local -i d=${4:-0}
	local -r r_e=${5:?${FUNCNAME[0]}'()': undefined suffix2}
	local f=''

	f="$(TextBrightWhite "$b") ${r_c}$(Pluralise "$b") ($(TextBrightWhite "$d") ${r_e}$(Pluralise "$d"))"

	if [[ ${6:-short} != long ]]; then
		ShowAsProc "$r_a" "$f"
	else
		ShowAsProcLong "$r_a" "$f"
	fi

	return 0

	}

ShowAsActionLogDetail()
	{

	# Inputs: (local)
	#   $1 = datetime in seconds (unused)
	#   $2 = package or group name			'SABnzbd', 'essential'
	#   $3 = action							'download', 'downloaded'
	#   $4 = result							'ok', 'skipped-ok', 'skipped', 'failed'
	#   $5 = duration in milliseconds
	#   $6 = reason (optional)				"file already exists in local cache"
	#   $7 = package type					'QPKG', 'IPK', etc...
	#   $8 = quantity 						number of packages affected.

	if [[ ${2:-undefined} = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$2"

		return 1
	fi

	if [[ ${7:-undefined} = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$7"

		return 1
	fi

	local package_type=''
	local quantity_msg=''

	package_type=$7$(Pluralise "$8")

	case $8 in
		0)
			quantity_msg='no '
			;;
		1)
			: # Don't shown 1's.
			;;
		*)
			quantity_msg="$8 "
	esac

	if [[ ${8:-undefined} = undefined ]]; then
		ShowAsError "${FUNCNAME[0]}() was provided an undefined value for \$8"

		return 1
	fi

	case ${4:-} in
		failed)
			if [[ -n "${6:-}" ]]; then
				# Use different behaviours depending on action.

				case $3 in
					download|?(reas)sign|uninstall)
						DisplayAsIndentActionResultDurationReason "$3" "$2 $package_type" "$5" "$6"
						;;
					*)
						if QpkgIsDatabaseWillLog "$2"; then
							DisplayAsIndentActionResultDurationReason "$3" "$2 $package_type" "$5" "For more information: /etc/init.d/$($BASENAME_CMD "$(QpkgGetInstalledServicePathFile "$2")") log"
						else
							DisplayAsIndentActionResultDurationReason "$3" "$2 $package_type" "$5" "$6"
						fi
				esac
			else
				DisplayAsIndentActionResultDurationReason "$3" "$2 $package_type" "$5" 'no reason was provided by the service-script'
			fi
			;;
		skipped*)
			if [[ -n "${6:-}" ]]; then
				DisplayAsIndentActionResultDurationReason "$3" "${quantity_msg}${2} $package_type" '' "$6"
			else
				DisplayAsIndentActionResultDurationReason "$3" "${quantity_msg}${2} $package_type" '' "no reason provided"
			fi
			;;
		*)
			DisplayAsIndentActionResultDurationReason "$3" "${quantity_msg}${2} $package_type" "$5" "$6"
	esac

	return 0

	}

OpStepClearWait()
	{

	# Displays script operation message from beginning of line, remain on this line, and leave cursor at end.

	# Inputs: (local)
	#	$1 = a 4 character string such as 'info', 'proc', 'done', 'derp'.
	#	$2 = detailed message.

	# Inputs: (global)
	#	$useropt_colourful

	local -i n=4			# Width of the message type.

	[[ ${useropt_colourful:=false} = true ]] && n=10  	# Allow extra length for ANSI codes in message type.

	DisplayWait "$(printf "\033[2K\r%-${n}s: %s" "${1:-}" "${2:-}")"

	return 0

	}

OpStepClear()
	{

	# Displays script operation message from beginning of line, jump down a line, and leave cursor at start.

	# Inputs: (local)
	#	$1 = a 4 character string such as 'info', 'proc', 'done', 'derp'.
	#	$2 = detailed message.

	# Inputs: (global)
	#	$useropt_colourful

	local -i n=4			# Width of the message type.

	[[ ${useropt_colourful:=false} = true ]] && n=10  	# Allow extra length for ANSI codes in message type.

	Display "$(printf "\033[2K\r%-${n}s: %s" "${1:-}" "${2:-}")"

	return 0

	}

WriteToLog()
	{

	# Inputs: (local)
	#	$1 = pass/fail
	#	$2 = message

	# Inputs: (global)
	#	$sess_active_pathfile
	#	$useropt_debug

	[[ -n ${1:-} && -n ${2:-} ]] || return

	[[ ${useropt_debug:=false} = true && -n ${sess_active_pathfile:-} ]] && printf '%-4s: %s\n' "$(StripANSICodes "$1")" "$(StripANSICodes "$2")" >> "$sess_active_pathfile"

	}

TextBrightGreen()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;32m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightYellow()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;33m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightOrange()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;38;5;214m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightOrangeBlink()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;5;38;5;214m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightRed()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;31m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightRedBlink()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;5;31m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

#TextCyan()
# 	{
#
# 	[[ -n ${1:-} ]] || return
#
# 	if [[ ${useropt_colourful:=false} = true ]]; then
# 		printf '\033[1;36m%s\033[0m' "$1"
# 	else
# 		printf '%s' "$1"
# 	fi
#
# 	} 2> /dev/null

TextDarkGrey()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;90m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

#TextUnderlined()
# 	{
#
# 	[[ -n ${1:-} ]] || return
#
# 	if [[ ${useropt_colourful:=false} = true ]]; then
# 		printf '\033[4m%s\033[0m' "$1"
# 	else
# 		printf '%s' "$1"
# 	fi
#
# 	} 2> /dev/null

TextUnderlinedCyan()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[4;36m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBlackOnCyan()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[30;46m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

TextBrightWhite()
	{

	[[ -n ${1:-} ]] || return

	if [[ ${useropt_colourful:=false} = true ]]; then
		printf '\033[1;97m%s\033[0m' "$1"
	else
		printf '%s' "$1"
	fi

	} 2> /dev/null

Tableise()
	{

	# Generate an ANSI-aware table with auto-minimum-width columns.

	# With many thanks to Stéphane Chazelas for writing this, and to Josh Klodnicki for his enhancements.
	#  	  https://unix.stackexchange.com/a/121139/259233

	awk '{
		nf[NR]=NF
		for (i = 1; i <= NF; i++) {
			cell[NR,i] = $i
			gsub(/\033\[[0-9;]*[mK]/, "", $i)
			len[NR,i] = l = length($i)
			if (l > max[i]) max[i] = l
		}
	}
	END {
		for (row = 1; row <= NR; row++) {
			for (col = 1; col < nf[row]; col++)
				printf "%s%*s%s", cell[row,col], max[col]-len[row,col], "", OFS
			print cell[row,nf[row]]
		}

	}' FS='|' OFS="$(printf "%$((r_report_column_spacing))s")"

	}

StripANSICodes()
	{

	# QTS 4.2.6 BusyBox `sed` doesn't fully support extended-regexes, so code-stripping only works with a real `sed`.

	if [[ ${sed_ext_regex_supported:=false} = true ]]; then
		echo -en "${1:-}" | /bin/sed -r 's/\x1b\[[0-9;]*m//g' 			# https://superuser.com/a/380778
	elif [[ -e /opt/bin/sed && -L /opt/etc/passwd ]]; then				# Try to ensure Entware is active first.
		echo -en "${1:-}" | /opt/bin/sed -r 's/\x1b\[[0-9;]*m//g' 		# https://superuser.com/a/380778
	else
		echo -en "${1:-}" 												# Can't strip, so pass thru original message unaltered.
	fi

	} 2> /dev/null

UpdateParentCapabilities()
	{

	SendParentChangeEnv UpdateColourisation
	SendParentChangeEnv UpdateSedRexegSupport
	SendParentChangeEnv UpdateSleepDecimalSecondsSupport

	}

UpdateCapabilities()
	{

	UpdateColourisation
	UpdateSedRexegSupport
	UpdateSleepDecimalSecondsSupport

	}

UpdateColourisation()
	{

	# If it seems Entware is active, check if possible to return to colourful display.

	if [[ -e /opt/bin/sed && -L /opt/etc/passwd && $(LoadSetting Colourful "$r_colourful_default") = true ]]; then
		useropt_colourful=true
		SendParentChangeEnv 'useropt_colourful=true'
	else
		useropt_colourful=false
		SendParentChangeEnv 'useropt_colourful=false'
	fi

	}

UpdateSedRexegSupport()
	{

	OsIsSupportSedExtRegex && sed_ext_regex_supported=true || sed_ext_regex_supported=false

	}

UpdateSleepDecimalSecondsSupport()
	{

	OsIsSupportDecimalSleepSeconds && sleep_decimal_seconds_supported=true || sleep_decimal_seconds_supported=false

	}

HideCursor()
	{

	[[ $useropt_verbose = false ]] && printf '\033[?25l'

	}

ShowCursor()
	{

	printf '\033[?25h'

	}

HideKeystrokes()
	{

	[[ $useropt_verbose = false && -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD '-echo'

	}

ShowKeystrokes()
	{

	[[ -n ${GNU_STTY_CMD:-} && -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD 'echo'

	}

sleep()
	{

	# Inputs:
	#	$1 = seconds to sleep (decimal or integer) (optional), default is 1 second.

	local n=${1:-}

	[[ ${n//.} -eq 0 ]] && n=1

	if [[ ${sleep_decimal_seconds_supported:=false} = true ]]; then
		$SLEEP_CMD "$n"
	elif [[ -e $GNU_SLEEP_CMD && -L /opt/etc/passwd ]]; then  				# Try to ensure Entware is active first.
		$GNU_SLEEP_CMD "$n"
	else
		$SLEEP_CMD "$((${n%.*}+1))"											# Ensure decimal seconds are rounded-up to next integer.
	fi

	return 0

	} 2> /dev/null

LoadObjects()
	{

	# Ensure `objects` in the local cache is up-to-date, then source it.

	[[ ${objects_loaded:=false} = false ]] || return 0

	FuncInit

	LoadLists

	if [[ ! -e $PWD/dont-refresh-objects ]]; then
		if [[ ! -e $r_objects_pathfile ]] || ! IsThisFileRecent "$r_objects_pathfile" "$r_file_change_threshold_minutes"; then
			ShowAsProc 'download objects'

			if $CURL_CMD --silent --fail "$r_objects_archive_url" > "$r_objects_archive_pathfile"; then
				$TAR_CMD --extract --gzip --no-same-owner --file="$r_objects_archive_pathfile" --directory="$r_cache_path"
			fi
		fi
	fi

	if [[ ! -e $r_objects_pathfile ]]; then
		ShowAsAbort 'objects missing'

		FuncExit 1; exit
	fi

	ShowAsProc objects

	. "$r_objects_pathfile"
	objects_loaded=true

	readonly r_objects_epoch
	DebugVar r_objects_epoch

	FuncExit

	}

LoadPackages()
	{

	# Ensure `packages` in the local cache is up-to-date, then source it.

	[[ ${packages_loaded:=false} = false ]] || return 0

	FuncInit

	local previous=''

	LoadObjects

	if [[ ! -e $PWD/dont-refresh-packages ]]; then
		if [[ ! -e $r_packages_pathfile ]] || ! IsThisFileRecent "$r_packages_pathfile" "$r_file_change_threshold_minutes"; then
			ShowAsProc 'download QPKG list'

			if $CURL_CMD --silent --fail "$r_packages_archive_url" > "$r_packages_archive_pathfile"; then
				$TAR_CMD --extract --gzip --no-same-owner --file="$r_packages_archive_pathfile" --directory="$r_cache_path"
			fi

			InitQPKGsTiers
		fi
	fi

	if [[ ! -e $r_packages_pathfile ]]; then
		ShowAsAbort 'QPKG list missing'

		FuncExit 1; exit
	fi

	ShowAsProc QPKGs

	# Supported QPKG details - parallel arrays.

	# First, clear existing list arrays (if-any).

	unset r_qpkg_abbrvs
	unset r_qpkg_appl_author
	unset r_qpkg_appl_author_email
	unset r_qpkg_appl_version
	unset r_qpkg_arch
	unset r_qpkg_author
	unset r_qpkg_author_email
	unset r_qpkg_can_backup
	unset r_qpkg_can_clean
	unset r_qpkg_can_restart_to_update
	unset r_qpkg_conflicts_with
	unset r_qpkg_depends_on
	unset r_qpkg_description
	unset r_qpkg_hash
	unset r_qpkg_is_sherpa_compatible
	unset r_qpkg_is_unique_unpack
	unset r_qpkg_max_os_version
	unset r_qpkg_min_os_version
	unset r_qpkg_min_ram_kb
	unset r_qpkg_name
	unset r_qpkg_note
	unset r_qpkg_requires_ipks
	unset r_qpkg_test_for_active
	unset r_qpkg_url
	unset r_qpkg_version
	unset r_qpkg_will_log

	r_packages_epoch=undefined

	# Second, create an index 0 element for each array. This element is used to indicate no matching QPKG when searching array.

	r_qpkg_abbrvs+=('')						# If set, this package is user-installable, and these abbreviations may be used to specify app.
	r_qpkg_appl_author+=('')				# Name of the person or group maintaining the internal application.
	r_qpkg_appl_author_email+=('')			# Email address for the internal application developer.
	r_qpkg_appl_version+=('')				# The application version contained within this QPKG. QPKGs can update their own versions in 'qpkg.conf'. Use 'version' if the application version is the same as $r_qpkg_version.
	r_qpkg_arch+=('')						# QPKG supports this architecture. Use 'all' if every arch is supported. Use 'none' to disable installation.
	r_qpkg_author+=('')						# Name of the person or group maintaining this QPKG.
	r_qpkg_author_email+=('')				# Email address of the package maintainer.
	r_qpkg_can_backup+=('')					# 'true'/'false': this QPKG service-script supports configuration 'backup' and 'restore' actions.
	r_qpkg_can_clean+=('')					# 'true'/'false': the internal application can be cleaned and re-downloaded.
	r_qpkg_can_restart_to_update+=('')		# 'true'/'false': the internal application can be updated by restarting the QPKG.
	r_qpkg_conflicts_with+=('')				# Abort if these QPKGs are installed.
	r_qpkg_depends_on+=('')					# Require these QPKGs to be installed first. Use 'none' if package is independent. Separate alternatives with '|'.
	r_qpkg_description+=('')				# QPKG description.
	r_qpkg_hash+=('') 						# MD5 checksum.
	r_qpkg_is_sherpa_compatible+=('')		# 'true'/'false': the service-script responds to enhanced sherpa actions.
	r_qpkg_is_unique_unpack+=('')			# 'true'/'false': QPKG will self-extract contents to a unique path. Requires build with QDK 2.3.14 or-later.
	r_qpkg_max_os_version+=('')				# The maximum QTS/QuTS version supported by this QPKG.
	r_qpkg_min_os_version+=('')				# The minimum QTS/QuTS version supported by this QPKG.
	r_qpkg_min_ram_kb+=('')					# QPKG requires at-least this much RAM installed in kiB. Use 'none' if no minimum.
	r_qpkg_name+=('')						# Internal QPKG name.
	r_qpkg_note+=('')						# An additional note to be prominently displayed.
	r_qpkg_requires_ipks+=('')				# Require these IPKs to be installed first.
	r_qpkg_test_for_active+=('')			# Test command-string to determine if this QPKG is active or inactive. Use 'builtin' if QPKG has its own status tests.
	r_qpkg_url+=('') 						# Remote URL.
	r_qpkg_version+=('') 					# QPKG version.
	r_qpkg_will_log+=('')					# 'true'/'false': the service-script keeps a log of all actions.

	# Third, source remaining elements from packages file.

	. "$r_packages_pathfile"

	# Fourth, lock list arrays and values.

	readonly r_qpkg_abbrvs
	readonly r_qpkg_appl_author
	readonly r_qpkg_appl_author_email
	readonly r_qpkg_appl_version
	readonly r_qpkg_arch
	readonly r_qpkg_author
	readonly r_qpkg_author_email
	readonly r_qpkg_can_backup
	readonly r_qpkg_can_clean
	readonly r_qpkg_can_restart_to_update
	readonly r_qpkg_conflicts_with
	readonly r_qpkg_depends_on
	readonly r_qpkg_description
	readonly r_qpkg_hash
	readonly r_qpkg_is_sherpa_compatible
	readonly r_qpkg_is_unique_unpack
	readonly r_qpkg_max_os_version
	readonly r_qpkg_min_os_version
	readonly r_qpkg_min_ram_kb
	readonly r_qpkg_name
	readonly r_qpkg_note
	readonly r_qpkg_requires_ipks
	readonly r_qpkg_test_for_active
	readonly r_qpkg_url
	readonly r_qpkg_version
	readonly r_qpkg_will_log

	packages_loaded=true

	readonly r_base_qpkg_conflicts_with
	readonly r_base_qpkg_warnings
	readonly r_essential_ipks
	readonly r_essential_pips
	readonly r_exclusion_pips
	readonly r_min_perl_version
	readonly r_min_python_version
	readonly r_packages_epoch

	DebugVar r_packages_epoch

	for qpkg_name in "${r_qpkg_name[@]}"; do
		[[ $previous = "$qpkg_name" ]] && continue || previous=$qpkg_name	# Ensure only first mention of each QPKG name is added to "GRall" array.
		QPKGs-GRall:Add "$qpkg_name"
	done

	BuildQPKGsTiers

	FuncExit

	}

CaughtSIGINT()
	{

	# Inputs: (global)
	#	$r_action_abort_pathfile
	#	$r_display_inhibit_pathfile

	trap - SIGINT

	[[ -n ${r_display_inhibit_pathfile:-} ]] && [[ -d $($DIRNAME_CMD "$r_display_inhibit_pathfile") ]] && /bin/touch "$r_display_inhibit_pathfile"
	[[ -n ${r_action_abort_pathfile:-} ]] && [[ -d $($DIRNAME_CMD "$r_action_abort_pathfile") ]] && /bin/touch "$r_action_abort_pathfile"
	EraseThisLine
	ShowAsAbort 'caught SIGINT'
	CloseActionMsgPipe

	# TODO: send SIGTERM to each PID in $r_async_procs_path here.

	exit

	}

CaughtEXIT()
	{

	trap - EXIT

	ShowKeystrokes
	ShowCursor
	ReleaseLockfile

	}

readonly r_script_startseconds=$(ConvertNowToSeconds)

trap CaughtSIGINT SIGINT
trap CaughtEXIT EXIT

Init || exit
ProcActions
ShowResults
ErrorIsNt
