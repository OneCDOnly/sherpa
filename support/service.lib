#!/usr/bin/env bash
#* Please don't edit this file directly, it was built/modified programmatically with the 'build-qpkgs.sh' script. (source: 'service-library.source')
#* service.lib
#* copyright (C) 2017-2024 OneCD.
#* Contact:
#*   one.cd.only@gmail.com
#* Description:
#*   A library of common bash functions used by many sherpa QPKG service-scripts.
#*   Each QPKG has a copy for use only by that QPKG's service-script.
#* Project:
#*	 https://git.io/sherpa
#* Forum:
#*	 https://forum.qnap.com/viewtopic.php?f=320&t=132373
#* Tested on:
#*	 GNU bash, version 3.2.57(2)-release (i686-pc-linux-gnu)
#*	 GNU bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)
#*	   Copyright (C) 2007 Free Software Foundation, Inc.
#*   ... and periodically on:
#*	 GNU bash, version 5.0.17(1)-release (aarch64-openwrt-linux-gnu)
#*	   Copyright (C) 2019 Free Software Foundation, Inc.
#* License:
#*   This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#*	 This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#*	 You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/
readonly SERVICE_LIB_VERSION='240422'
InitLibrary()
{
IsQNAP || exit
if [[ -z $LANG ]];then
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8
fi
if [[ ${DEBUG_QPKG:-} = true ]];then
debug=true
else
debug=false
fi
local re=''
for re in \\bd\\b \\bdebug\\b \\bdbug\\b \\bverbose\\b;do
if [[ $USER_ARGS_RAW =~ $re ]];then
debug=true
break
fi
done
ln -fns /proc/self/fd /dev/fd
UnsetError
UnsetRestartPending
readonly DAEMON_CHECK_TIMEOUT_SECONDS=60
readonly DAEMON_STOP_TIMEOUT_SECONDS=120
readonly PIDFILE_APPEAR_TIMEOUT_SECONDS=60
readonly PID_START_RECHECK_WAIT_SECONDS=$(CalcAdaptiveSeconds 10)
readonly PID_STOP_RECHECK_WAIT_SECONDS=$(CalcAdaptiveSeconds 10)
readonly PORT_CHECK_TIMEOUT_SECONDS=240
readonly BACKUP_PATH=$(/sbin/getcfg SHARE_DEF defVolMP -f /etc/config/def_share.info)/.qpkg_config_backup
readonly CHARS_REGULAR_PROMPT='$ '
readonly CHARS_SUDO_PROMPT="${CHARS_REGULAR_PROMPT}sudo "
readonly CHARS_SUPER_PROMPT='# '
readonly DEBUG_LOG_DATAWIDTH=100
readonly NAS_FIRMWARE_VER=$(/sbin/getcfg System Version -f /etc/config/uLinux.conf)
readonly OPKG_PATH=/opt/bin:/opt/sbin
export PATH=$OPKG_PATH:$(/bin/sed "s|$OPKG_PATH||" <<< "$PATH")
readonly QPKG_PATH=$(/sbin/getcfg $QPKG_NAME Install_Path -f /etc/config/qpkg.conf)
readonly QPKG_CONFIG_PATH=$QPKG_PATH/config
readonly APP_VERSION_STORE_PATHFILE=$QPKG_CONFIG_PATH/version.stored
readonly SCREEN_CONF_PATHFILE=$QPKG_CONFIG_PATH/screen.conf
readonly QPKG_VERSION=$(/sbin/getcfg $QPKG_NAME Version -d unknown -f /etc/config/qpkg.conf)
readonly SCREEN_LOG_PATHFILE=/var/log/$QPKG_NAME.screen.log
readonly SERVICE_LOG_PATHFILE=/var/log/$QPKG_NAME.log
readonly SERVICE_STATUS_PATHFILE=/var/run/$QPKG_NAME.last.operation
allow_access_to_sys_packages=true
app_version_cmd=undefined
app_version_pathfile=undefined
OSIsSupportSecureDownload && curl_insecure_arg='' || curl_insecure_arg=' --insecure'
daemon_launch_cmd=undefined
daemon_pathfile=undefined
daemon_pid_pathfile=undefined
daemon_port=0
get_daemon_port_cmd=undefined
get_ui_listening_address_cmd=undefined
get_ui_port_cmd=undefined
get_ui_port_secure_cmd=undefined
get_ui_port_secure_enabled_test_cmd=undefined
install_pip_deps=false
interpreter=undefined
launcher_pathfile=undefined
local_temp_path=undefined
orig_daemon_service_script=undefined
pidfile_is_managed_by_app=false
pip_cache_path=undefined
qpkg_backup_pathfile=$BACKUP_PATH/$QPKG_NAME.config.tar.gz
qpkg_ini_file=config.ini
qpkg_ini_pathfile=$QPKG_CONFIG_PATH/$qpkg_ini_file
qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def
qpkg_repo_path=undefined
recheck_daemon_pid_after_launch=false
recheck_daemon_pid_after_kill=false
remote_arch=undefined
remote_url=undefined
resolve_remote_url=false
run_daemon_in_screen_session=false
service_operation=unspecified
service_result=undefined
silence_pypi_errors=true
source_arch=undefined
source_archive_pathfile=undefined
source_git_branch=undefined
source_git_branch_depth=undefined
source_git_url=undefined
ui_listening_address=undefined
ui_port=0
ui_port_secure=0
userlink_pathfile=undefined
venv_path=undefined
venv_pip_pathfile=undefined
venv_python_pathfile=undefined
InitByServiceType
InitService
MakePaths
EnsureConfigFileExists
GetAppVersion
DisableOpkgDaemonStart
IsSourcedOnline && IsAutoUpdateMissing && EnableAutoUpdate >/dev/null
if [[ $run_daemon_in_screen_session = true && ! -e $SCREEN_CONF_PATHFILE ]];then
echo -e "logfile ${SCREEN_LOG_PATHFILE}\nlogfile flush 1\nlog on" > "$SCREEN_CONF_PATHFILE"
fi
}
InitByServiceType()
{
case $SERVICE_SCRIPT_TYPE in
1)
daemon_pid_pathfile=/var/run/$QPKG_NAME.pid
install_pip_deps=true
interpreter=/opt/bin/python3
pidfile_is_managed_by_app=true
pip_cache_path=$QPKG_PATH/pip-cache
qpkg_repo_path=$QPKG_PATH/repo-cache
recheck_daemon_pid_after_launch=true
source_git_branch=main
source_git_branch_depth=shallow
venv_path=$QPKG_PATH/venv
venv_pip_pathfile=$venv_path/bin/pip
venv_python_pathfile=$venv_path/bin/python3
;;
2)
:
;;
3)
daemon_pid_pathfile=/var/run/$QPKG_NAME.pid
;;
4)
:
;;
5)
allow_access_to_sys_packages=false
daemon_pid_pathfile=/var/run/$QPKG_NAME.pid
qpkg_repo_path=$QPKG_PATH/repo-cache
source_archive_pathfile="$qpkg_repo_path/$QPKG_NAME.tar.gz"
;;
6)
daemon_pid_pathfile=/var/run/$QPKG_NAME.pid
interpreter=/opt/bin/python3
pip_cache_path=$QPKG_PATH/pip-cache
qpkg_backup_pathfile=undefined
qpkg_ini_pathfile=undefined
qpkg_repo_path=$QPKG_PATH/repo-cache
run_daemon_in_screen_session=true
venv_path=$QPKG_PATH/venv
venv_pip_pathfile=$venv_path/bin/pip
venv_python_pathfile=$venv_path/bin/python3
;;
7)
interpreter=/opt/bin/python3
pip_cache_path=$QPKG_PATH/pip-cache
venv_path=$QPKG_PATH/venv
venv_pip_pathfile=$venv_path/bin/pip
venv_python_pathfile=$venv_path/bin/python3
;;
8)
daemon_pid_pathfile=/var/run/$QPKG_NAME.pid
;;
*)
:
esac
}
ShowHelp()
{
Display "$(TextBrightWhite "$(/usr/bin/basename "$0")") $SERVICE_SCRIPT_VERSION • a service control script for the $(FormatAsPackageName $QPKG_NAME) QPKG"
Display
Display "Usage: $0 [ACTION]"
Display
Display '[ACTION] may be any one of the following:'
Display
DisplayAsHelp start "activate $(FormatAsPackageName $QPKG_NAME) if not already active."
DisplayAsHelp stop "deactivate $(FormatAsPackageName $QPKG_NAME) if active."
DisplayAsHelp restart "stop, then start $(FormatAsPackageName $QPKG_NAME)."
DisplayAsHelp enable "enable $(FormatAsPackageName $QPKG_NAME) so it can be started."
DisplayAsHelp disable "disable $(FormatAsPackageName $QPKG_NAME) to prevent it starting."
DisplayAsHelp status "check if $(FormatAsPackageName $QPKG_NAME) package is active. Returns \$? = 0 if active, 1 if not."
IsSupportBackup && DisplayAsHelp backup "backup the current $(FormatAsPackageName $QPKG_NAME) configuration to persistent storage."
IsSupportBackup && DisplayAsHelp restore "restore a previously saved configuration from persistent storage. $(FormatAsPackageName $QPKG_NAME) will be stopped, then restarted."
IsSupportReset && DisplayAsHelp reset-config "delete the application configuration, databases and history. $(FormatAsPackageName $QPKG_NAME) will be stopped, then restarted."
IsSourcedOnline && DisplayAsHelp clean "delete the local copy of $(FormatAsPackageName $QPKG_NAME), and download it again from remote source. Configuration will be retained."
DisplayAsHelp log 'display the service-script log.'
IsSourcedOnline && DisplayAsHelp enable-auto-update "auto-update $(FormatAsPackageName $QPKG_NAME) before starting (default)."
IsSourcedOnline && DisplayAsHelp disable-auto-update "don't auto-update $(FormatAsPackageName $QPKG_NAME) before starting."
DisplayAsHelp version 'display the package version numbers.'
Display
}
StartQPKG()
{
if [[ $(type -t StartQPKGCustom) = function ]];then
StartQPKGCustom
else
StartQPKGLibrary
fi
}
StartQPKGLibrary()
{
IsError && return
if IsNotRestart && IsNotRestore && IsNotClean && IsNotReset;then
IsDaemonActive && return
fi
if IsRestore || IsClean || IsReset;then
IsNotRestartPending && return
fi
DisplayWaitCommitToLog 'auto-update:'
if IsAutoUpdate;then
DisplayCommitToLog true
else
DisplayCommitToLog false
fi
CloneGitRepo || { SetError;return 1 ;}
InstallAddons || { SetError;return 1 ;}
if IsNotDaemon;then
if [[ $userlink_pathfile != undefined ]];then
if [[ ! -L $userlink_pathfile && -e $launcher_pathfile ]];then
ln -s "$launcher_pathfile" "$userlink_pathfile"
if [[ -L $userlink_pathfile ]];then
DisplayCommitToLog "symlink created: '$userlink_pathfile'"
else
DisplayErrCommitAllLogs "unable to create symlink to '$QPKG_NAME' launcher"
SetError
return 1
fi
else
DisplayCommitToLog "symlink exists: '$userlink_pathfile'"
fi
return
fi
fi
if IsOnlineArchive;then
local source_archive_pathfile=$qpkg_repo_path/source.archive
if IsAutoUpdate || [[ ! -e $source_archive_pathfile ]];then
local release_url=''
local download_opts=$curl_insecure_arg
[[ $debug = false ]] && download_opts+=' --silent'
if [[ $resolve_remote_url = true ]];then
DisplayWaitCommitToLog 'check release package:'
if IsSiteUp "$remote_url";then
release_url=$(RequestLatestRelease "$remote_url" "$remote_arch")
if [[ -n $release_url && $release_url != undefined ]];then
DisplayCommitToLog OK
else
DisplayErrCommitAllLogs "'unable to calculate remote URL'"
fi
else
DisplayErrCommitAllLogs "'unable to access remote site'"
fi
else
release_url=$remote_url
fi
if [[ -n $release_url ]];then
[[ -e $source_archive_pathfile ]] && download_opts+=" --time-cond $source_archive_pathfile"
download_opts+=" --show-error --location --output $source_archive_pathfile"
DisplayRunAndLog 'refresh release package' "/sbin/curl${download_opts} '$release_url'" log:failure-only
fi
fi
local tar_extract_verbose=''
local tar_extract_opts=''
local unzip_extract_verbose=''
local unzip_extract_opts=''
if [[ $debug = true ]];then
tar_extract_verbose=' --verbose'
fi
if [[ -e $source_archive_pathfile ]] && [[ ! -e $daemon_pathfile || $(($(/bin/date +%s)-$(/usr/bin/stat "$source_archive_pathfile" -c %Y))) -lt 60 ]];then
tar_extract_opts="$tar_extract_verbose --extract --gzip --file=$source_archive_pathfile --directory=$qpkg_repo_path"
unzip_extract_opts="$unzip_extract_verbose -o $source_archive_pathfile -d $qpkg_repo_path"
DisplayRunAndLog 'extract release package' "/usr/bin/unzip${unzip_extract_opts} 2>/dev/null || /bin/tar${tar_extract_opts}" log:failure-only
fi
fi
[[ -e $(GetLaunchTarget) ]] || { SetError;return 1 ;}
EnsureConfigFileExists
LoadPorts app || { SetError;return 1 ;}
if [[ $daemon_port -le 0 && $ui_port -le 0 && $ui_port_secure -le 0 ]];then
DisplayErrCommitAllLogs "unable to start daemon: 'no port specified'"
SetError
return 1
elif IsNotPortAvailable $ui_port || IsNotPortAvailable $ui_port_secure;then
DisplayErrCommitAllLogs "unable to start daemon: ports '$ui_port' or '$ui_port_secure' are already in-use"
portpid=$(/usr/sbin/lsof -i :$ui_port -Fp)
DisplayErrCommitAllLogs "process details for port '$ui_port': '${portpid}': PID '$([[ -n ${portpid:-} ]] && /bin/tr '\000' ' ' </proc/"${portpid/p/}"/cmdline)'"
portpid=$(/usr/sbin/lsof -i :$ui_port_secure -Fp)
DisplayErrCommitAllLogs "process details for secure port '$ui_port_secure': PID '${portpid}': '$([[ -n ${portpid:-} ]] && /bin/tr '\000' ' ' </proc/"${portpid/p/}"/cmdline)'"
SetError
return 1
fi
if IsUseVirtualPythonEnv && IsNotVirtualEnvironmentExist;then
DisplayErrCommitAllLogs "unable to start daemon: 'virtual environment does not exist'"
SetError
return 1
fi
local msg='start daemon'
if [[ $run_daemon_in_screen_session = true ]];then
msg+=' (in screen session)'
rm -f "${SCREEN_LOG_PATHFILE:?}"
fi
if ! DisplayRunAndLog "$msg" "$daemon_launch_cmd" log:failure-only "$run_daemon_in_screen_session";then
SetError
return 1
fi
WaitForDaemon
WaitForStartPid
if ! IsDaemonActive;then
DisplayErrCommitAllLogs 'IsDaemonActive() failed!'
SetError
[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$SCREEN_LOG_PATHFILE"
return 1
fi
if ! CheckPorts;then
DisplayErrCommitAllLogs 'CheckPorts() failed!'
SetError
[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$SCREEN_LOG_PATHFILE"
return 1
fi
CommitInfoToSysLog 'start daemon: OK'
return 0
}
StopQPKG()
{
if [[ $(type -t StopQPKGCustom) = function ]];then
StopQPKGCustom
else
StopQPKGLibrary
fi
}
StopQPKGLibrary()
{
IsError && return
if IsNotDaemon;then
if [[ -L $userlink_pathfile ]];then
rm -f "$userlink_pathfile"
DisplayCommitToLog "symlink removed: '$userlink_pathfile'"
fi
return
fi
if IsDaemonActive;then
if IsRestart || IsRestore || IsClean || IsReset;then
SetRestartPending
fi
local acc=0
local pid=0
local msg='stop daemon'
[[ $run_daemon_in_screen_session = true ]] && msg+=' (in screen session)'
pid=$(<$daemon_pid_pathfile)
DisplayWaitCommitToLog "$msg (PID:${pid}) with SIGTERM (no-more than $DAEMON_STOP_TIMEOUT_SECONDS second$(Pluralise "$DAEMON_STOP_TIMEOUT_SECONDS")):"
kill "$pid"
while true;do
while [[ -d /proc/$pid ]];do
/bin/sleep 1
((acc++))
DisplayWait "$acc,"
if [[ $acc -ge $DAEMON_STOP_TIMEOUT_SECONDS ]];then
DisplayCommitToLog 'failed!'
DisplayCommitToLog "$msg (PID:${pid}) with SIGKILL:"
kill -9 "$pid" 2> /dev/null
[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"
break 2
fi
done
[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"
Display OK
CommitToLog "stopped in $acc second$(Pluralise "$acc")"
CommitInfoToSysLog "$msg: OK"
break
done
WaitForKillPid
IsNotDaemonActive || { SetError;return 1 ;}
fi
return 0
}
InstallAddons()
{
IsUseVirtualPythonEnv || return 0
local default_essential_modules_pathfile=$QPKG_CONFIG_PATH/pip-essential.txt
local default_requirements_modules_pathfile=$QPKG_CONFIG_PATH/requirements.txt
local default_recommended_modules_pathfile=$QPKG_CONFIG_PATH/recommended.txt
local essential_modules_pathfile=$qpkg_repo_path/pip-essential.txt
local requirements_modules_pathfile=$qpkg_repo_path/requirements.txt
local recommended_modules_pathfile=$qpkg_repo_path/recommended.txt
local excluded_modules_pathfile=$QPKG_CONFIG_PATH/pip-exclusions.txt
local rename_modules_pathfile=$QPKG_CONFIG_PATH/pip-rename.txt
local pyproject_pathfile=$qpkg_repo_path/pyproject.toml
local pip_conf_pathfile=$venv_path/pip.conf
local new_env=false
local allow_sys_packages=' --system-site-packages'
local no_pips_installed=true
local no_pip_deps=' --no-deps'
local module_exclusions=''
local re=''
local cmd=''
[[ $allow_access_to_sys_packages != true ]] && allow_sys_packages=''
[[ $install_pip_deps = true ]] && no_pip_deps=''
if IsNotVirtualEnvironmentExist;then
DisplayRunAndLog 'create new virtual Python environment' "export PIP_CACHE_DIR=$pip_cache_path VIRTUALENV_OVERRIDE_APP_DATA=$pip_cache_path;$interpreter -m virtualenv ${venv_path}${allow_sys_packages}" log:failure-only
new_env=true
fi
if IsNotVirtualEnvironmentExist;then
DisplayErrCommitAllLogs "unable to install addons: 'virtual environment does not exist'"
SetError
return 1
fi
if [[ ! -e $pip_conf_pathfile ]];then
DisplayRunAndLog "create global 'pip' config" "echo -e \"[global]\ncache-dir = $pip_cache_path\" > $pip_conf_pathfile" log:failure-only
fi
IsNotAutoUpdate && [[ $new_env = false ]] && return 0
if [[ $QPKG_NAME = OWatcher3 ]];then
DisplayRunAndLog "KLUDGE: install 'm2r' PyPI module first" "$venv_pip_pathfile install${no_pip_deps} --no-input m2r" log:failure-only
if [[ $? -gt 0 && $silence_pypi_errors = false ]];then
CommitWarnToSysLog "'mr2' PyPI module installation failed."
fi
fi
[[ -e $essential_modules_pathfile && -d $(/usr/bin/dirname "$default_essential_modules_pathfile") ]] && cp -f "$essential_modules_pathfile" "$default_essential_modules_pathfile"
[[ -e $default_essential_modules_pathfile ]] && essential_modules_pathfile=$default_essential_modules_pathfile
[[ -e $requirements_modules_pathfile && -d $(/usr/bin/dirname "$default_requirements_modules_pathfile") ]] && cp -f "$requirements_modules_pathfile" "$default_requirements_modules_pathfile"
[[ -e $default_requirements_modules_pathfile ]] && requirements_modules_pathfile=$default_requirements_modules_pathfile
[[ -e $recommended_modules_pathfile && -d $(/usr/bin/dirname "$default_recommended_modules_pathfile") ]] && cp -f "$recommended_modules_pathfile" "$default_recommended_modules_pathfile"
[[ -e $default_recommended_modules_pathfile ]] && recommended_modules_pathfile=$default_recommended_modules_pathfile
if [[ -e $excluded_modules_pathfile ]];then
module_exclusions=$(/bin/tr '\n' ' ' <<< "$(StripComments "$(<"$excluded_modules_pathfile")")")
module_exclusions=${module_exclusions%* }
re="/^${module_exclusions// /\|^}"
for target in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile $pyproject_pathfile;do
if [[ -e $target ]];then
if [[ -e /opt/bin/sed ]];then
cmd="/opt/bin/sed -i '${re}/Id' $target"
else
cmd="/bin/sed -i '${re}/d' $target"
fi
DisplayRunAndLog "exclude problem PyPI modules from '$(/usr/bin/basename "$target")'" "$cmd" log:failure-only
fi
done
fi
for target in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile;do
if [[ -e $target ]];then
DisplayRunAndLog "install PyPI modules from '$(/usr/bin/basename "$target")'" "$venv_pip_pathfile install${no_pip_deps} --no-input --upgrade pip -r $target" log:failure-only
if [[ $? -gt 0 && $silence_pypi_errors = false ]];then
CommitWarnToSysLog 'PyPI module installation failed.'
fi
no_pips_installed=false
fi
done
if [[ $no_pips_installed = true ]];then
if [[ -e $qpkg_repo_path/setup.py || -e $pyproject_pathfile ]];then
DisplayRunAndLog "install PyPI modules from '$(/usr/bin/basename "$target")'" "$venv_pip_pathfile install${no_pip_deps} --no-input --upgrade pip $qpkg_repo_path" log:failure-only
if [[ $? -gt 0 && $silence_pypi_errors = false ]];then
CommitWarnToSysLog 'PyPI module installation failed.'
fi
no_pips_installed=false
fi
fi
if [[ -e $rename_modules_pathfile ]];then
for module in $(StripComments "$(<"$rename_modules_pathfile")");do
RenameSharedObjectFile "$module"
done
fi
if IsSupportGetAppVersion;then
GetAppVersion
if [[ $new_env = false && -e $APP_VERSION_STORE_PATHFILE && $(<"$APP_VERSION_STORE_PATHFILE") != "$app_version" ]];then
DisplayRunAndLog "clean Python bytecode files" "/opt/bin/find $qpkg_repo_path -type d -name '__pycache__' -print0 | xargs -I {} -0 rm -rf '{}'
" log:failure-only
fi
if [[ ! -e $APP_VERSION_STORE_PATHFILE || $(<"$APP_VERSION_STORE_PATHFILE") != "$app_version" ]];then
DisplayRunAndLog "generate language translations" "cd $qpkg_repo_path;$venv_python_pathfile $qpkg_repo_path/tools/make_mo.py" log:failure-only
fi
SaveAppVersion
fi
return 0
}
StripComments()
{
[[ -n $1 ]] || return
local a="$1"
a=$(/bin/sed -e '/^#[[:space:]].*/d;/#$/d;s/[[:space:]]#[[:space:]].*//' <<< "$a")
a=$(/bin/sed -e 's/^[[:space:]]*//' <<< "$a")
a=$(/bin/sed 's/[[:space:]]*$//' <<< "$a")
a=$(/bin/sed "/^$/d" <<< "$a")
echo "$a"
}
BackupConfig()
{
DisplayRunAndLog 'update configuration backup' "/bin/tar --create --gzip --file=$qpkg_backup_pathfile --directory=$QPKG_PATH/config ." log:failure-only || SetError
return 0
}
RestoreConfig()
{
if [[ ! -f $qpkg_backup_pathfile ]];then
DisplayErrCommitAllLogs "unable to restore configuration: 'no backup file was found'"
SetError
return 1
fi
DisplayRunAndLog 'restore configuration backup' "/bin/tar --extract --gzip --file=$qpkg_backup_pathfile --directory=$QPKG_PATH/config" log:failure-only || SetError
return 0
}
ResetConfig()
{
DisplayRunAndLog 'reset configuration' "mv $qpkg_ini_default_pathfile $QPKG_PATH;rm -rf $QPKG_PATH/config/*; mv $QPKG_PATH/$(/usr/bin/basename "$qpkg_ini_default_pathfile") $qpkg_ini_default_pathfile" log:failure-only || SetError
return 0
}
MakePaths()
{
local a=''
if [[ -d $QPKG_PATH ]];then
for a in "$local_temp_path" "$qpkg_repo_path" "$pip_cache_path" "$venv_path";do
[[ $a != undefined && ! -d $a ]] && mkdir -p "$a"
done
fi
[[ $BACKUP_PATH != undefined && ! -d $BACKUP_PATH ]] && mkdir -p "$BACKUP_PATH"
}
LoadPorts()
{
case $1 in
app)
DisplayWaitCommitToLog 'load ports from configuration file:'
[[ $get_ui_port_cmd != undefined ]] && ui_port=$(eval "$get_ui_port_cmd")
[[ $get_ui_port_secure_cmd != undefined ]] && ui_port_secure=$(eval "$get_ui_port_secure_cmd")
DisplayCommitToLog OK
;;
qts)
DisplayWaitCommitToLog 'load UI ports from QPKG icon:'
ui_port=$(/sbin/getcfg $QPKG_NAME Web_Port -d 0 -f /etc/config/qpkg.conf)
ui_port_secure=$(/sbin/getcfg $QPKG_NAME Web_SSL_Port -d 0 -f /etc/config/qpkg.conf)
DisplayCommitToLog OK
;;
*)
DisplayErrCommitAllLogs "unable to load ports: action '$1' is unrecognised"
SetError
return 1
esac
[[ $get_daemon_port_cmd != undefined ]] && daemon_port=$(eval "$get_daemon_port_cmd")
[[ $get_ui_listening_address_cmd != undefined ]] && ui_listening_address=$(eval "$get_ui_listening_address_cmd")
ui_port=${ui_port//[!0-9]/}
[[ -z $ui_port || $ui_port -lt 0 || $ui_port -gt 65535 ]] && ui_port=0
ui_port_secure=${ui_port_secure//[!0-9]/}
[[ -z $ui_port_secure || $ui_port_secure -lt 0 || $ui_port_secure -gt 65535 ]] && ui_port_secure=0
daemon_port=${daemon_port//[!0-9]/}
[[ -z $daemon_port || $daemon_port -lt 0 || $daemon_port -gt 65535 ]] && daemon_port=0
[[ -z $ui_listening_address ]] && ui_listening_address=undefined
return 0
}
GetAppVersion()
{
if IsSupportGetAppVersion && [[ -e $app_version_pathfile ]];then
app_version=$(eval "$app_version_cmd")
return 0
else
app_version=unknown
return 1
fi
}
StatusQPKG()
{
if [[ $(type -t StatusQPKGCustom) = function ]];then
StatusQPKGCustom
else
StatusQPKGLibrary
fi
}
StatusQPKGLibrary()
{
IsNotError || return
DisplayWaitCommitToLog 'auto-update:'
if IsAutoUpdate;then
DisplayCommitToLog true
else
DisplayCommitToLog false
fi
if IsDaemonActive;then
if IsDaemon || IsSourcedOnline;then
LoadPorts app
CheckPorts || exit
fi
else
exit 1
fi
exit 0
}
DisableOpkgDaemonStart()
{
if [[ $orig_daemon_service_script != undefined && -x $orig_daemon_service_script ]];then
$orig_daemon_service_script stop
chmod -x "$orig_daemon_service_script"
fi
}
CloneGitRepo()
{
IsGitApp || return 0
local branch_depth='--depth 1'
[[ $source_git_branch_depth = single-branch ]] && branch_depth='--single-branch'
local active_branch=$(GetPathGitBranch "$qpkg_repo_path")
local branch_switch=false
WaitForGit || return
if [[ -d $qpkg_repo_path/.git ]];then
if [[ $active_branch != "$source_git_branch" ]];then
branch_switch=true
DisplayCommitToLog "active git branch: '$active_branch', new git branch: '$source_git_branch'"
[[ $QPKG_NAME = nzbToMedia ]] && BackupConfig
DisplayCommitToLog 'new git branch has been specified, so must clean local repository'
CleanLocalRepo
fi
fi
if [[ ! -d $qpkg_repo_path/.git ]];then
DisplayRunAndLog "clone $(FormatAsPackageName "$QPKG_NAME") from remote repository" "cd /tmp;/opt/bin/git clone --branch $source_git_branch $branch_depth -c advice.detachedHead=false $source_git_url $qpkg_repo_path" log:failure-only
else
if IsAutoUpdate;then
DisplayRunAndLog "update $(FormatAsPackageName "$QPKG_NAME") from remote repository" "cd /tmp;/opt/bin/git -C $qpkg_repo_path clean -f; /opt/bin/git -C $qpkg_repo_path reset --hard origin/$source_git_branch; /opt/bin/git -C $qpkg_repo_path pull" log:failure-only
fi
fi
if IsAutoUpdate;then
DisplayCommitToLog "active git branch: '$(GetPathGitBranch "$qpkg_repo_path")'"
fi
[[ $branch_switch = true && $QPKG_NAME = nzbToMedia ]] && RestoreConfig
return 0
}
CleanLocalRepo()
{
if [[ -z $QPKG_PATH || -z $QPKG_NAME ]] || IsNotSourcedOnline;then
SetError
return 1
fi
(IsGitApp || IsOnlineArchive) && DisplayRunAndLog 'clean local repository' "rm -rf \"$qpkg_repo_path\"" log:failure-only
IsUseVirtualPythonEnv && [[ -d $venv_path ]] && DisplayRunAndLog 'clean virtual environment' "rm -rf \"$venv_path\"" log:failure-only
IsUsePipCache && [[ -d $pip_cache_path ]] && DisplayRunAndLog 'clean PyPI cache' "rm -rf \"$pip_cache_path\"" log:failure-only
[[ -e $APP_VERSION_STORE_PATHFILE ]] && DisplayRunAndLog 'remove application version' "rm -f \"$APP_VERSION_STORE_PATHFILE\"" log:failure-only
IsUseTemp && [[ -d $local_temp_path ]] && DisplayRunAndLog 'clean temp path' "rm -rf \"$local_temp_path\"" log:failure-only
MakePaths
}
WaitForGit()
{
if IsNotQPKGInstalled Entware;then
DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not installed'"
return 1
fi
if IsNotQPKGEnabled Entware;then
DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not enabled'"
return 1
fi
if WaitForFileToAppear '/opt/bin/git' 300;then
export PATH=$OPKG_PATH:$(/bin/sed "s|$OPKG_PATH||" <<< "$PATH")
return 0
fi
return 1
}
GetLaunchTarget()
{
if [[ $venv_python_pathfile != undefined ]];then
echo -n "$venv_python_pathfile"
elif [[ $daemon_pathfile != undefined ]];then
echo -n "$daemon_pathfile"
else
return 1
fi
}
ReconfirmPidFile()
{
local target_pid=0
local process_pathfilename=$(GetLaunchTarget)
[[ -n $process_pathfilename ]] || return
[[ -n $daemon_pid_pathfile ]] || return
for target_pid in $(/bin/pidof "$(/usr/bin/basename "$process_pathfilename")");do
[[ -d /proc/$target_pid ]] || continue
[[ -e /proc/$target_pid/cmdline ]] || continue
[[ $(</proc/$target_pid/cmdline) =~ $process_pathfilename ]] || continue
echo "$target_pid" > "$daemon_pid_pathfile"
return
done
rm -f "$daemon_pid_pathfile"
return 1
}
WaitForStartPid()
{
local -i i=0
if [[ $pidfile_is_managed_by_app = true ]];then
if WaitForFileToAppear "$daemon_pid_pathfile" "$PIDFILE_APPEAR_TIMEOUT_SECONDS";then
/bin/sleep 1
fi
fi
if [[ $recheck_daemon_pid_after_launch = true ]];then
DisplayWaitCommitToLog "wait $PID_START_RECHECK_WAIT_SECONDS second$(Pluralise "$PID_START_RECHECK_WAIT_SECONDS") to recheck PID:"
for ((i=1;i<=PID_START_RECHECK_WAIT_SECONDS; i++)); do
/bin/sleep 1
DisplayWait "$i,"
done
DisplayCommitToLog 'done'
fi
ReconfirmPidFile || return
}
WaitForKillPid()
{
local -i i=0
if [[ $recheck_daemon_pid_after_kill = true ]];then
DisplayWaitCommitToLog "wait $PID_STOP_RECHECK_WAIT_SECONDS second$(Pluralise "$PID_STOP_RECHECK_WAIT_SECONDS") to recheck PID:"
for ((i=1;i<=PID_STOP_RECHECK_WAIT_SECONDS; i++)); do
/bin/sleep 1
DisplayWait "$i,"
done
DisplayCommitToLog 'done'
fi
! ReconfirmPidFile || return
}
WaitForDaemon()
{
local -i i=0
if [[ -n $1 ]];then
MAX_SECONDS=$1
else
MAX_SECONDS=$DAEMON_CHECK_TIMEOUT_SECONDS
fi
if [[ ! -e $1 ]];then
DisplayWaitCommitToLog 'wait for daemon to appear:'
DisplayWait "(no-more than $MAX_SECONDS second$(Pluralise "$MAX_SECONDS")):"
local target_proc=''
target_proc=$(GetLaunchTarget)
(
for ((i=1;i<=MAX_SECONDS; i++)); do
/bin/sleep 1
DisplayWait "$i,"
if IsProcessActive "$target_proc" "$daemon_pid_pathfile";then
Display OK
CommitToLog "appeared in $i second$(Pluralise "$i")"
true
exit
fi
done
false
)
if [[ $? -ne 0 ]];then
DisplayErrCommitAllLogs "daemon not found! (exceeded timeout: $MAX_SECONDS second$(Pluralise "$MAX_SECONDS"))"
return 1
fi
fi
DisplayCommitToLog "daemon: exists"
return 0
}
WaitForFileToAppear()
{
local -i i=0
[[ -n $1 ]] || return
if [[ -n $2 ]];then
MAX_SECONDS=$2
else
MAX_SECONDS=30
fi
if [[ ! -e $1 ]];then
DisplayWaitCommitToLog "wait for $1 to appear:"
DisplayWait "(no-more than $MAX_SECONDS second$(Pluralise "$MAX_SECONDS")):"
(
for ((i=1;i<=MAX_SECONDS; i++)); do
/bin/sleep 1
DisplayWait "$i,"
if [[ -e $1 ]];then
Display OK
CommitToLog "visible after $i second$(Pluralise "$i")"
true
exit
fi
done
false
)
if [[ $? -ne 0 ]];then
DisplayErrCommitAllLogs "$1 not found! (exceeded timeout: $MAX_SECONDS second$(Pluralise "$MAX_SECONDS"))"
return 1
fi
fi
DisplayCommitToLog "file '$1': exists"
return 0
}
ViewLog()
{
if [[ -e $SERVICE_LOG_PATHFILE ]];then
if [[ -e /opt/bin/less ]];then
LESSSECURE=1 /opt/bin/less +G --quit-on-intr --tilde --LINE-NUMBERS --RAW-CONTROL-CHARS --prompt ' use arrow-keys to scroll up-down left-right, press Q to quit' "$SERVICE_LOG_PATHFILE"
else
/bin/cat --number "$SERVICE_LOG_PATHFILE"
fi
else
Display "service log not found: $SERVICE_LOG_PATHFILE"
SetError
return 1
fi
return 0
}
EnsureConfigFileExists()
{
IsNotSupportReset && return
if IsNotConfigFound && IsDefaultConfigFound;then
DisplayCommitToLog 'no configuration file found: using default'
cp "${qpkg_ini_default_pathfile:?undefined}" "${qpkg_ini_pathfile:?undefined}"
fi
}
SaveAppVersion()
{
[[ $APP_VERSION_STORE_PATHFILE != undefined ]] && echo "$app_version" > "$APP_VERSION_STORE_PATHFILE"
}
DisplayRunAndLog()
{
local -r LOG_PATHFILE=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
local -i z=0
DisplayWaitCommitToLog "$1:"
RunAndLog "${2:?empty}" "$LOG_PATHFILE" "${3:-}" '' "${4:-false}"
z=$?
if [[ $z -eq 0 ]];then
DisplayCommitToLog OK
else
DisplayCommitToLog failed
fi
if [[ $z -eq 0 ]];then
[[ ${3:-} != log:failure-only ]] && AddFileToDebug "$LOG_PATHFILE"
else
[[ $z -ne ${4:-} ]] && AddFileToDebug "$LOG_PATHFILE"
fi
[[ -e $LOG_PATHFILE ]] && rm -f "$LOG_PATHFILE"
return $z
}
RunAndLog()
{
local -r LOG_PATHFILE=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
local -i z=0
FormatAsCommand "${1:?empty}" > "${2:?empty}"
if [[ $debug = true ]];then
Display
if [[ ${5:-false} = false ]];then
Display "exec: '$1'"
eval "$1 > >(/usr/bin/tee $LOG_PATHFILE) 2>&1"
z=${PIPESTATUS[0]}
else
Display "exec (in screen session): '$1'"
fi
else
if [[ ${5:-false} = false ]];then
(eval "$1" > "$LOG_PATHFILE" 2>&1)
z=$?
fi
fi
if [[ ${5:-false} = true ]];then
FormatAsCommand "$1" >> "$SCREEN_LOG_PATHFILE"
/usr/sbin/screen -c "$SCREEN_CONF_PATHFILE" -dmLS "$QPKG_NAME" bash -c "$1"
z=$?
fi
if [[ -e $LOG_PATHFILE ]];then
FormatAsResultAndStdout "$z" "$(<"$LOG_PATHFILE")" >> "$2"
else
FormatAsResultAndStdout "$z" '<null>' >> "$2"
fi
if [[ $debug = true ]];then
if [[ $z -eq 0 ]];then
Display 'exec: completed OK'
else
Display 'exec: completed, but with errors'
fi
fi
[[ -e $LOG_PATHFILE ]] && rm -f "$LOG_PATHFILE"
return $z
}
AddFileToDebug()
{
local debug_was_set=$debug
local linebuff=''
debug=false
DebugAsLog ''
DebugAsLog 'adding external log to main log ...'
DebugExtLogMinorSeparator
DebugAsLog "$(FormatAsLogFilename "${1:?no filename supplied}")"
while read -r linebuff;do
DebugAsLog "$linebuff"
done < "$1"
DebugExtLogMinorSeparator
debug=$debug_was_set
}
DebugExtLogMinorSeparator()
{
DebugAsLog "$(DebugMinorSeparator)"
}
DebugBulletSeparatorWithText()
{
local a=''
[[ -n ${1:-} ]] && a=" ${1:-} "
local b=$(((DEBUG_LOG_DATAWIDTH-${#a})/2))
local c=$((DEBUG_LOG_DATAWIDTH-${#a}-b))
eval printf '%0.s•' "{1..$b}";echo -n "$a"; eval printf '%0.s•' "{1..$c}"; echo
}
DebugMinorSeparator()
{
eval printf '%0.s-' "{1..$DEBUG_LOG_DATAWIDTH}"
}
DebugAsLog()
{
[[ -n ${1:-} ]] || return
DebugThis "(LL) $1"
}
DebugThis()
{
[[ $debug = true ]] && Display "${1:-}"
WriteAsDebug "${1:-}"
}
WriteAsDebug()
{
WriteToLog dbug "${1:-}"
}
WriteToLog()
{
printf "%-4s: %s\n" "$(StripANSICodes "${1:-}")" "$(StripANSICodes "${2:-}")" >> "$SERVICE_LOG_PATHFILE"
}
StripANSICodes()
{
if [[ -e /opt/bin/sed && -L /opt/etc/passwd ]];then
/opt/bin/sed -r 's/\x1b\[[0-9;]*m//g' <<< "${1:-}"
else
echo "${1:-}"
fi
}
Capitalise()
{
echo "$(Uppercase ${1:0:1})${1:1}"
}
Uppercase()
{
/bin/tr 'a-z' 'A-Z' <<< "$1"
}
Lowercase()
{
/bin/tr 'A-Z' 'a-z' <<< "$1"
}
ReWriteUIPorts()
{
[[ $get_daemon_port_cmd != undefined ]] && return
DisplayWaitCommitToLog 'update QPKG icon with UI ports:'
/sbin/setcfg $QPKG_NAME Web_Port "$ui_port" -f /etc/config/qpkg.conf
if IsSSLEnabled;then
/sbin/setcfg $QPKG_NAME Web_SSL_Port "$ui_port_secure" -f /etc/config/qpkg.conf
else
/sbin/setcfg $QPKG_NAME Web_SSL_Port '-2' -f /etc/config/qpkg.conf
fi
DisplayCommitToLog OK
}
CheckPorts()
{
local msg=''
DisplayCommitToLog "daemon listening address: '$ui_listening_address'"
if [[ $daemon_port -ne 0 ]];then
DisplayCommitToLog "daemon port: '$daemon_port'"
if IsPortResponds $daemon_port;then
msg="daemon port '$daemon_port'"
fi
else
DisplayWaitCommitToLog 'HTTPS port enabled:'
if IsSSLEnabled;then
DisplayCommitToLog true
DisplayCommitToLog "HTTPS port: '$ui_port_secure'"
if IsPortSecureResponds $ui_port_secure;then
msg="HTTPS port '$ui_port_secure'"
fi
else
DisplayCommitToLog false
fi
DisplayCommitToLog "HTTP port: '$ui_port'"
if IsPortResponds $ui_port;then
[[ -n $msg ]] && msg+=' and '
msg+="HTTP port '$ui_port'"
fi
fi
if [[ -z $msg ]];then
DisplayErrCommitAllLogs 'no response on configured port(s)'
SetError
return 1
else
DisplayCommitToLog "$msg test: OK"
ReWriteUIPorts
return 0
fi
}
GetPythonVer()
{
local v=''
v=$(GetThisBinPath ${1:-python} &>/dev/null && ${1:-python} -V 2>&1 | /bin/sed 's|^Python ||;s|\.||g')
[[ -n $v ]] && echo "${v:0:3}"
}
GetThisBinPath()
{
[[ -n ${1:?null} ]] && command -v "$1" 2>&1
}
RenameSharedObjectFile()
{
[[ -n ${1:-} ]] || return
if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "_$1") ]];then
mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "_$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "_$1")"
DisplayCommitToLog "renamed module: _$1"
fi
if [[ -e $(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1") ]];then
mv "$(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$1/$(GetFixedModuleSOFilename "$1")"
DisplayCommitToLog "renamed module: $1/$1"
fi
if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "$1") ]];then
mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "$1")"
DisplayCommitToLog "renamed module: $1"
fi
return 0
}
GetOriginalModuleSOFilename()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
[[ -n ${1:-} ]] && echo "$1.cpython-$pyver-$(/bin/uname -m)-linux-gnu.so"
}
GetFixedModuleSOFilename()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
[[ -n ${1:-} ]] && echo "$1.cpython-$pyver.so"
}
GetModulePath()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
echo "$venv_path/lib/python${pyver:0:1}.${pyver:1:2}/site-packages"
}
parse_yaml()
{
local prefix=$2
local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
/bin/sed -ne "s|^\($s\):|\1|" \
-e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
-e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
/bin/awk -F$fs '{
indent = length($1)/2;
vname[indent] = $2;
for (i in vname) {if (i > indent) {delete vname[i]}}
if (length($3) > 0) {
vn="";for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
}
}'
}
IsQNAP()
{
if [[ ! -e /etc/init.d/functions ]];then
Display 'QTS functions missing (is this a QNAP NAS?)'
SetError
return 1
fi
return 0
}
IsQPKGInstalled()
{
/bin/grep -q "^\[${1:-$QPKG_NAME}\]" /etc/config/qpkg.conf
}
IsNotQPKGInstalled()
{
! IsQPKGInstalled "${1:-$QPKG_NAME}"
}
IsQPKGEnabled()
{
[[ $(Lowercase "$(/sbin/getcfg "${1:-$QPKG_NAME}" Enable -d false -f /etc/config/qpkg.conf)") = true ]]
}
IsNotQPKGEnabled()
{
! IsQPKGEnabled "${1:-$QPKG_NAME}"
}
IsSupportBackup()
{
[[ $qpkg_backup_pathfile != undefined ]]
}
IsNotSupportBackup()
{
! IsSupportBackup
}
IsSupportReset()
{
[[ $qpkg_ini_pathfile != undefined ]]
}
IsNotSupportReset()
{
! IsSupportReset
}
IsSupportGetAppVersion()
{
[[ $app_version_cmd != undefined && $app_version_pathfile != undefined ]]
}
IsNotSupportGetAppVersion()
{
! IsSupportGetAppVersion
}
IsUseVirtualPythonEnv()
{
[[ $venv_path != undefined ]]
}
IsNotVirtualEnvironmentUsed()
{
! IsUseVirtualPythonEnv
}
IsGitApp()
{
[[ $source_git_url != undefined && $source_git_branch != undefined && $qpkg_repo_path != undefined ]]
}
IsNotGitApp()
{
! IsGitApp
}
IsUsePipCache()
{
[[ $pip_cache_path != undefined ]]
}
IsNotUsePipCache()
{
! IsUsePipCache
}
IsOnlineArchive()
{
[[ $remote_url != undefined ]]
}
IsNotOnlineArchive()
{
! IsOnlineArchive
}
IsSourcedOnline()
{
IsGitApp || IsUsePipCache || IsUseVirtualPythonEnv || IsOnlineArchive
}
IsNotSourcedOnline()
{
! IsSourcedOnline
}
IsUseTemp()
{
[[ $local_temp_path != undefined ]]
}
IsNotUseTemp()
{
! IsUseTemp
}
IsSSLEnabled()
{
eval "$get_ui_port_secure_enabled_test_cmd"
}
IsNotSSLEnabled()
{
! IsSSLEnabled
}
IsDaemon()
{
[[ $daemon_pathfile != undefined ]]
}
IsNotDaemon()
{
! IsDaemon
}
IsDaemonActive()
{
DisplayWaitCommitToLog 'daemon:'
local target_proc=''
target_proc=$(GetLaunchTarget)
if IsProcessActive "$target_proc" "$daemon_pid_pathfile";then
DisplayCommitToLog "active (PID:$(<"$daemon_pid_pathfile"))"
return 0
fi
DisplayCommitToLog inactive
return 1
}
IsNotDaemonActive()
{
! IsDaemonActive
}
IsProcessActive()
{
[[ -n ${1:?process pathfilename null} ]] || return
[[ -n ${2:?pid pathfilename null} ]] || return
rm -f "$2"
[[ ! -e $2 ]] && ReconfirmPidFile
[[ -e $2 && -d /proc/"$(<$2)" && -n ${1:-} && $(</proc/"$(<$2)"/cmdline) =~ ${1:-} ]]
}
IsPackageActive()
{
DisplayWaitCommitToLog 'package active:'
if [[ -e $BACKUP_SERVICE_PATHFILE ]];then
DisplayCommitToLog true
return 0
fi
DisplayCommitToLog false
return 1
}
IsNotPackageActive()
{
! IsPackageActive
}
IsSysFilePresent()
{
if [[ -z ${1:?pathfilename null} ]];then
SetError
return 1
fi
if [[ ! -e $1 ]];then
Display "A required NAS system file is missing: '$1'"
SetError
return 1
fi
return 0
}
IsNotSysFilePresent()
{
! IsSysFilePresent "${1:?pathfilename null}"
}
IsPortAvailable()
{
local port=${1//[!0-9]/}
[[ -n $port && $port -gt 0 ]] || return 0
/usr/sbin/lsof -i :"$port" -sTCP:LISTEN >/dev/null 2>&1 && return 1
return 0
}
IsNotPortAvailable()
{
! IsPortAvailable "${1:-0}"
}
IsPortResponds()
{
local port=${1//[!0-9]/}
if [[ -z $port ]];then
Display 'empty port: not testing for response'
return 1
elif [[ $port -eq 0 ]];then
Display "port '0': not testing for response"
return 1
fi
local acc=0
DisplayWaitCommitToLog "test for port '$port' response (no-more than $PORT_CHECK_TIMEOUT_SECONDS second$(Pluralise "$PORT_CHECK_TIMEOUT_SECONDS")):"
local target_proc=''
target_proc=$(GetLaunchTarget)
while true;do
if ! IsProcessActive "$target_proc" "$daemon_pid_pathfile";then
DisplayCommitToLog 'process not active'
break
fi
/sbin/curl --silent --fail --max-time 1 http://localhost:"$port" &>/dev/null
case $? in
0|22|52)
Display OK
CommitToLog "responded in $acc second$(Pluralise "$acc")"
return 0
;;
28)
:
;;
7)
/bin/sleep 1
;;
*)
:
esac
((acc+=1))
DisplayWait "$acc,"
if [[ $acc -ge $PORT_CHECK_TIMEOUT_SECONDS ]];then
DisplayCommitToLog 'failed!'
CommitErrToSysLog "port '$port' failed to respond after $acc second$(Pluralise "$acc")!"
break
fi
done
return 1
}
IsPortSecureResponds()
{
local port=${1//[!0-9]/}
if [[ -z $port ]];then
Display 'empty port: not testing for response'
return 1
elif [[ $port -eq 0 ]];then
Display "port '0': not testing for response"
return 1
fi
local acc=0
DisplayWaitCommitToLog "test for secure port '$port' response:"
DisplayWait "(no-more than $PORT_CHECK_TIMEOUT_SECONDS second$(Pluralise "$PORT_CHECK_TIMEOUT_SECONDS")):"
local target_proc=''
target_proc=$(GetLaunchTarget)
while true;do
if ! IsProcessActive "$target_proc" "$daemon_pid_pathfile";then
DisplayCommitToLog 'process not active'
break
fi
/sbin/curl --silent --insecure --fail --max-time 1 https://localhost:"$port" &>/dev/null
case $? in
0|22|52)
Display OK
CommitToLog "port responded after $acc second$(Pluralise "$acc")"
return 0
;;
35)
DisplayCommitToLog 'TLS inactive'
break
;;
28)
:
;;
7)
/bin/sleep 1
;;
*)
:
esac
((acc+=1))
DisplayWait "$acc,"
if [[ $acc -ge $PORT_CHECK_TIMEOUT_SECONDS ]];then
DisplayCommitToLog 'failed'
CommitErrToSysLog "secure port '$port' failed to respond after $acc second$(Pluralise "$acc")!"
break
fi
done
return 1
}
IsConfigFound()
{
[[ $qpkg_ini_pathfile != undefined && -e $qpkg_ini_pathfile ]]
}
IsNotConfigFound()
{
! IsConfigFound
}
IsDefaultConfigFound()
{
[[ $qpkg_ini_default_pathfile != undefined && -e $qpkg_ini_default_pathfile ]]
}
IsNotDefaultConfigFound()
{
! IsDefaultConfigFound
}
IsVirtualEnvironmentExist()
{
[[ -e $venv_path/bin/activate ]]
}
IsNotVirtualEnvironmentExist()
{
! IsVirtualEnvironmentExist
}
OSIsSupportSecureDownload()
{
[[ ${NAS_FIRMWARE_VER//.} -ge 500 ]]
}
IsSiteUp()
{
local site=$(cut -d'/' -f3 <<< ${1:-} | cut -d':' -f1)
[[ -n $site && $site != undefined ]] || return
for ((n=0;n<20; n++)); do
/bin/ping -c 1 -w 1 "$site" && return 0
/bin/sleep 5
done
return 1
} &>/dev/null
RequestLatestRelease()
{
[[ -n $1 && $1 != undefined ]] || return
[[ -n $2 && $2 != undefined ]] || return
/sbin/curl${download_opts} "$1" | /bin/grep browser_download_url | cut -d\" -f4 | /bin/grep "$2"
} 2>/dev/null
SetServiceAction()
{
service_operation=${1:-unspecified}
CommitServiceStatus "$service_operation"
DisplayAndCommitActionToLog
}
SetServiceStatusAsOK()
{
service_result=ok
CommitServiceStatus "$service_result"
DisplayAndCommitStatusToLog
}
SetServiceStatusAsFailed()
{
service_result=failed
CommitServiceStatus "$service_result"
DisplayAndCommitStatusToLog
}
CommitServiceStatus()
{
if IsNotStatus && IsNotLog && IsNotNone;then
[[ -n ${1:-} && $SERVICE_STATUS_PATHFILE != undefined ]] && echo "${1:-}" > "$SERVICE_STATUS_PATHFILE"
fi
}
SetRestartPending()
{
_restart_pending_flag=true
}
UnsetRestartPending()
{
_restart_pending_flag=false
}
IsRestartPending()
{
[[ $_restart_pending_flag = true ]]
}
IsNotRestartPending()
{
[[ $_restart_pending_flag = false ]]
}
SetError()
{
IsError && return
_error_flag=true
}
UnsetError()
{
IsNotError && return
_error_flag=false
}
IsError()
{
[[ $_error_flag = true ]]
}
IsNotError()
{
! IsError
}
IsRestart()
{
[[ $service_operation = restart ]]
}
IsNotRestart()
{
! IsRestart
}
IsNotLog()
{
! [[ $service_operation = log ]]
}
IsNotNone()
{
! [[ $service_operation = none ]]
}
IsClean()
{
[[ $service_operation = clean ]]
}
IsNotClean()
{
! IsClean
}
IsRestore()
{
[[ $service_operation = restore ]]
}
IsNotRestore()
{
! IsRestore
}
IsReset()
{
[[ $service_operation = reset ]]
}
IsNotReset()
{
! IsReset
}
IsNotStatus()
{
! [[ $service_operation = status ]]
}
IsUnsupported()
{
[[ $service_operation = unsupported ]]
}
ShowAsError()
{
local capitalised=$(Capitalise "${1:-}")
Display "$(TextBrightRed derp): $capitalised"
} >&2
DisplayCommitToLog()
{
Display "${1:-}"
CommitToLog "${1:-}"
}
DisplayWaitCommitToLog()
{
DisplayWait "${1:-}"
CommitToLogWait "${1:-}"
}
DisplayWarnCommitAllLogs()
{
DisplayCommitToLog "${1:-}"
CommitWarnToSysLog "${1:-}"
}
DisplayErrCommitAllLogs()
{
DisplayCommitToLog "${1:-}"
CommitErrToSysLog "${1:-}"
}
FormatAsLogFilename()
{
echo "= log file: '${1:-}'"
}
FormatAsCommand()
{
Display "command: '${1:-}'"
}
FormatAsStdout()
{
Display "output: \"${1:-}\""
}
FormatAsResult()
{
Display "result: $(FormatAsExitcode "${1:-}")"
}
FormatAsResultAndStdout()
{
if [[ ${1:-0} -eq 0 ]];then
echo "= result_code: $(FormatAsExitcode "$1")"
else
echo "! result_code: $(FormatAsExitcode "$1")"
fi
DebugBulletSeparatorWithText 'stdout & stderr begins below'
echo "${2:-}"
DebugBulletSeparatorWithText 'stdout & stderr is complete'
}
FormatAsFuncMessages()
{
echo "= ${FUNCNAME[1]}()"
FormatAsCommand "${1:?command null}"
FormatAsStdout "${2:-}"
}
FormatAsExitcode()
{
echo "[${1:-}]"
}
FormatAsPackageName()
{
echo "'${1:-}'"
}
DisplayAsHelp()
{
printf "  --%-19s  %s\n" "${1:-}" "${2:-}"
}
Display()
{
echo "${1:-}"
}
DisplayWait()
{
echo -n "${1:-} "
}
DisplayAndCommitActionToLog()
{
[[ $service_operation = unspecified ]] && return
starttime=$(/bin/date +%s%N)
local msg="source: $(/usr/bin/basename "$0"), action: $service_operation, datetime: $(date)"
msg=" $(/bin/tr -s ' ' <<< "$msg") "
local target=DisplayCommitToLog
if IsNotStatus && IsNotLog && IsNotNone;then
IsUnsupported && target=CommitToLog
CommitToLog '•'
$target "$(TextInverse "$msg")"
$target "package: $QPKG_VERSION, service: $SERVICE_SCRIPT_VERSION, library: $SERVICE_LIB_VERSION"
fi
}
DisplayAndCommitStatusToLog()
{
[[ $service_operation = unspecified ]] && return
local msg="source: $(/usr/bin/basename "$0"), action: $service_operation, datetime: $(date), result: $service_result, elapsed time: $(FormatAsDuration "$(CalcMilliDifference "$starttime" "$(/bin/date +%s%N)")")"
msg=" $(/bin/tr -s ' ' <<< "$msg") "
local target=DisplayCommitToLog
if IsNotStatus && IsNotLog && IsNotNone;then
IsUnsupported && target=CommitToLog
case $service_result in
ok)
$target "$(TextBlackOnGreen "$msg")"
;;
failed)
$target "$(TextBlackOnRed "$msg")"
;;
*)
$target "$(TextBlackOnYellow "$msg")"
esac
fi
}
CommitInfoToSysLog()
{
CommitSysLog "${1:-}" 4
}
CommitWarnToSysLog()
{
CommitSysLog "${1:-} Please check the service log for more information." 2
}
CommitErrToSysLog()
{
CommitSysLog "${1:-}" 1
}
CommitToLog()
{
if IsNotStatus && IsNotLog && IsNotNone;then
[[ ${1:-} = '•' && ! -s "$SERVICE_LOG_PATHFILE" ]] || echo -e "${1:-}" >> "$SERVICE_LOG_PATHFILE"
fi
}
CommitToLogWait()
{
if IsNotStatus && IsNotLog && IsNotNone;then
echo -n "${1:-} " >> "$SERVICE_LOG_PATHFILE"
fi
}
CommitSysLog()
{
if IsNotStatus && IsNotLog && IsNotNone;then
if [[ -z ${1:-} || -z ${2:-} ]];then
SetError
return 1
fi
/sbin/write_log "[$QPKG_NAME] $1" "$2"
fi
}
TextBrightWhite()
{
printf '\033[1;97m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBrightRed()
{
printf '\033[1;31m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnGreen()
{
printf '\033[30;42m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnRed()
{
printf '\033[30;41m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnYellow()
{
printf '\033[30;43m%s\033[0m' "${1:-}"
} 2>/dev/null
TextInverse()
{
printf '\033[7m%s\033[0m' "${1:-}"
} 2>/dev/null
Pluralise()
{
[[ ${1:-0} -ne 1 ]] && echo s
}
CalcMilliDifference()
{
local start=${1:-0}
local end=${2:-1}
echo "$(((end-start)/1000000))"
}
FormatAsThous()
{
local rightside_group=''
local foutput=''
local remainder=$(/bin/sed 's/[^0-9]*//g' <<< "${1:-}")
while [[ ${#remainder} -gt 0 ]];do
rightside_group=${remainder:${#remainder}<3?0:-3}
if [[ -z $foutput ]];then
foutput=$rightside_group
else
foutput=$rightside_group,$foutput
fi
if [[ ${#rightside_group} -eq 3 ]];then
remainder=${remainder%???}
else
break
fi
done
echo "$foutput"
return 0
}
FormatAsDuration()
{
if [[ ${1:-0} -lt 10000 ]];then
echo "$(FormatAsThous "${1:-0}")ms"
else
FormatSecsToHoursMinutesSecs "$(($1/1000))"
fi
}
FormatSecsToHoursMinutesSecs()
{
((h=${1:-0}/3600))
((m=(${1:-0}%3600)/60))
((s=${1:-0}%60))
printf '%01dh:%02dm:%02ds\n' "$h" "$m" "$s"
} 2>/dev/null
IsAutoUpdateMissing()
{
[[ $(/sbin/getcfg $QPKG_NAME Auto_Update -f /etc/config/qpkg.conf) = '' ]]
}
IsAutoUpdate()
{
[[ $(Lowercase "$(/sbin/getcfg $QPKG_NAME Auto_Update -f /etc/config/qpkg.conf)") = true ]]
}
IsNotAutoUpdate()
{
! IsAutoUpdate
}
EnableAutoUpdate()
{
StoreAutoUpdateSelection true
}
DisableAutoUpdate()
{
StoreAutoUpdateSelection false
}
StoreAutoUpdateSelection()
{
/sbin/setcfg "$QPKG_NAME" Auto_Update "$(Uppercase "$1")" -f /etc/config/qpkg.conf
DisplayCommitToLog "auto-update: $1"
}
GetPathGitBranch()
{
[[ -n $1 ]] || return
/opt/bin/git -C "$1" branch | /bin/grep '^\*' | /bin/sed 's|^\* ||'
} 2>/dev/null
IsSU()
{
if [[ $EUID -ne 0 ]];then
if [[ -e /usr/bin/sudo ]];then
ShowAsError 'this utility must be run with superuser privileges. Try again as:'
Display "${CHARS_SUDO_PROMPT}$0 $USER_ARGS_RAW" >&2
else
ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
fi
return 1
fi
return 0
}
ShowUnsupportedAction()
{
ShowAsError "specified action '$1' is unsupported by this service script."
SetError
CommitToLog "specified action '$1' is unsupported."
Display
ShowHelp
}
CalcAdaptiveSeconds()
{
local a=$(GetSysLoad1MinAverage);a=${a/./}
local b=$(($(GetCPUCores)*100))
local c=$((10#$a/10#$b))
local d=$((10#${1:-1}))
[[ $((10#$c)) -gt 1 ]] && d=$((c*d))
[[ $((10#$d)) -gt 1800 ]] && d=1800
echo -n "$d"
}
GetSysLoad1MinAverage()
{
/usr/bin/uptime | /bin/sed 's|.*load average: ||' | /bin/awk -F', ' '{print $1}'
}
GetCPUCores()
{
local n=$(/bin/grep -c '^processor' /proc/cpuinfo)
[[ $n -eq 0 ]] && n=$(/bin/grep -c '^Processor' /proc/cpuinfo)
echo -n "$n"
}
ProcessArgs()
{
if IsGitApp;then
local test_branch=$(/sbin/getcfg $QPKG_NAME Git_Branch -d unknown -f /etc/config/qpkg.conf)
if [[ $test_branch = unknown ]];then
/sbin/setcfg $QPKG_NAME Git_Branch $source_git_branch -f /etc/config/qpkg.conf
else
source_git_branch=$test_branch
fi
fi
if IsNotError;then
local user_arg=${USER_ARGS_RAW%% *}
case $user_arg in
b|-b|backup|--backup|backup-config|--backup-config)
IsSU ||	exit
if IsSupportBackup;then
SetServiceAction backup
StopQPKG
BackupConfig
StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
clean|--clean)
IsSU ||	exit
if IsSourcedOnline;then
SetServiceAction clean
StopQPKG
[[ $QPKG_NAME = nzbToMedia ]] && BackupConfig
CleanLocalRepo
StartQPKG
[[ $QPKG_NAME = nzbToMedia ]] && RestoreConfig
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
debug|help|verbose)
ShowHelp
;;
disable)
IsSU ||	exit
SetServiceAction disable
/sbin/qpkg_service disable "$QPKG_NAME"
if IsNotQPKGEnabled;then
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") is disabled."
else
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") disable failed."
SetError
fi
;;
disable-auto-update|--disable-auto-update)
IsSU ||	exit
if IsSourcedOnline;then
SetServiceAction disable-auto-update
DisableAutoUpdate
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
enable)
IsSU ||	exit
SetServiceAction enable
/sbin/qpkg_service enable "$QPKG_NAME"
if IsQPKGEnabled;then
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") is enabled."
else
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") enable failed."
SetError
fi
;;
enable-auto-update|--enable-auto-update)
IsSU ||	exit
if IsSourcedOnline;then
SetServiceAction enable-auto-update
EnableAutoUpdate
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
l|-l|log|--log)
SetServiceAction log
ViewLog
;;
remove)
SetServiceAction uninstall
;;
reset-config|--reset-config)
IsSU ||	exit
if IsSupportReset;then
SetServiceAction reset
StopQPKG
ResetConfig
StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
r|-r|restart|--restart)
IsSU ||	exit
SetServiceAction restart
if IsNotQPKGEnabled;then
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") QPKG is disabled. Please enable it first with: $0 enable"
SetError
else
StopQPKG && StartQPKG
fi
;;
restore|--restore|restore-config|--restore-config)
IsSU ||	exit
if IsSupportBackup;then
SetServiceAction restore
StopQPKG
RestoreConfig
StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
start|--start)
IsSU ||	exit
SetServiceAction start
if IsNotQPKGEnabled;then
DisplayCommitToLog "$(FormatAsPackageName "$QPKG_NAME") QPKG is disabled. Please enable it first with: $0 enable"
SetError
else
StartQPKG
fi
;;
s|-s|status|--status)
SetServiceAction status
StatusQPKG
;;
stop|--stop)
IsSU ||	exit
SetServiceAction stop
StopQPKG
;;
v|-v|version|--version)
SetServiceAction none
Display "package: '$QPKG_VERSION'"
Display "service: '$SERVICE_SCRIPT_VERSION'"
Display "library: '$SERVICE_LIB_VERSION'"
;;
*)
if [[ -z $user_arg ]];then
ShowHelp
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
esac
fi
if [[ -n $user_arg ]];then
if IsError;then
SetServiceStatusAsFailed
exit 1
else
SetServiceStatusAsOK
fi
fi
exit
}
InitLibrary
