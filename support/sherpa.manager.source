#!/usr/bin/env bash
#*<?dontedit?>
#
#* sherpa.manager.sh
#*  Copyright (C) 2017-<?year?> OneCD - one.cd.only@gmail.com
#
#   So, blame OneCD if it all goes horribly wrong. ;)
#
# Description:
#   This is the management script for the sherpa mini-package-manager.
#   It's automatically downloaded via the `sherpa.loader.sh` script in the `sherpa` QPKG no-more than once per 24 hours.
#
#* Project:
#*   https://git.io/sherpa
#
# Forum:
#   https://forum.qnap.com/viewtopic.php?f=320&t=132373
#
# Tested on:
#   GNU bash, version 3.2.57(2)-release (i686-pc-linux-gnu)
#   GNU bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)
#   Copyright (C) 2007 Free Software Foundation, Inc.
#
# ... and periodically on:
#   GNU bash, version 5.1.16(1)-release (aarch64-openwrt-linux-gnu)
#   Copyright (C) 2020 Free Software Foundation, Inc.
#
#* License:
#*   This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#
#*   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
#*   You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/
#
# Project variable and function naming style-guide:
#			  functions: 'CamelCase'
#  background functions: '_CamelCaseWithLeadingAndTrailingUnderscores_'
#  utility interceptors: (same as original)
#			  variables: 'lowercase_with_inline_underscores'
# flag "object" methods: 'Capitalised.CamelCase.With.Inline.Periods.And.Colon.Before:Method'
# list "object" methods: 'Capitalised-CamelCase-With-Inline-Hyphens-And-Colon-Before:Method'
#   "object" properties: '_lowercase_with_leading_and_inline_and_trailing_underscores_' (these should ONLY be managed via the object's methods)
#			  constants: 'UPPERCASE_WITH_INLINE_UNDERSCORES' (also set as readonly)
#				indents: 1 x tab
#
# Notes:
#   If on-screen line-spacing is required, this should only be done by the next function that outputs to display.
#   Display functions should never finish by putting an empty line on-screen for spacing.

set -o nounset -o pipefail
readonly USER_ARGS_RAW=$*
readonly SCRIPT_STARTSECONDS=$(/bin/date +%s)

Self:Init()
	{

	Func:Entry
	Vars:Load
	IsQNAP || return
	IsSU || return
	Self.LockFile:Claim || return
	UpdateColourisation
	Consts:Load

	sess_active_pathfile=$THIS_PACKAGE_PATH/session.$$.active.log
	rm -f "$REPORT_PATHFILE" "$RAMDISKS_FREESPACE_PATHFILE" "$DISPLAY_INHBIT_PATHFILE"

	trap RunOnEXIT EXIT
	trap RunOnSIGINT INT

	[[ ! -e /dev/fd ]] && ln -s /proc/self/fd /dev/fd	# KLUDGE: `/dev/fd` isn't always created by QTS during startup

	Keystrokes:Hide
	Cursor:Hide
	Env:Confirm || return
	Lists:Load
	CreatePaths || return
	ArchivePriorSessLogs
	IsReset
	Objects:Load || return
	TerminalDimensions:Load

	# test if this QTS `sleep` can handle decimal seconds. Early QTS BusyBox versions cannot.
	readonly DECIMAL_SLEEP_SECONDS_SUPPORTED=$($QTS_SLEEP_CMD .01 &>/dev/null && echo true || echo false)

	IsVerbose
	IsDebug

	DebugInfoMajSepr
	DebugScript started "$(/bin/date -d @"$SCRIPT_STARTSECONDS" | tr -s ' ')"
	DebugScript versions "QPKG: ${THIS_PACKAGE_VER:-unknown}, manager: ${THIS_SCRIPT_VER:-unknown}, loader: ${LOADER_SCRIPT_VER:-unknown}, objects: ${OBJECTS_VER:-unknown}"
	DebugScript PID "$$"
	DebugInfoMinSepr
	DebugInfo 'Markers: (**) detected, (II) information, (WW) warning, (EE) error, (LL) log file, (--) processing,'
	DebugInfo '(==) done, (>>) f entry, (<<) f exit, (vv) variable name & value, ($1) positional argument value'
	DebugInfoMinSepr

	readonly NAS_FIRMWARE_VER=$(GetFirmwareVer)
	readonly NAS_FIRMWARE_BUILD=$(GetFirmwareBuild)
	readonly NAS_FIRMWARE_DATE=$(GetFirmwareDate)
	readonly NAS_RAM_KB=$(GetInstalledRAM)
	readonly NAS_ARCH=$(GetArch)
	readonly NAS_PLATFORM=$(GetPlatform)
	readonly NAS_QPKG_ARCH=$(GetQpkgArch)
	readonly ENTWARE_VER=$(GetEntwareType)
	readonly CPU_CORES=$(GetCPUCores)
	readonly CONCURRENCY=$CPU_CORES		# maximum concurrent package actions to run. Should probably make this account for CPU speed too.
	readonly LOG_TAIL_LINES=5000		# note: a full download and install of everything generates a session log of around 1600 lines, but include a bunch of opkg updates and it can get much longer
	prev_msg=' '
	fork_pid=''

	OS.IsSupportSecureDownload && curl_insecure_arg='' || curl_insecure_arg=' --insecure'
	QPKG.IsInstalled Entware && [[ $ENTWARE_VER = none ]] && DebugAsWarn "$(FormatAsPackName Entware) appears to be installed but is not visible"

	if [[ $(GetSudoUID) = '<undefined>' ]]; then
		help_syntax_prefix="$CHARS_SUPER_PROMPT"
		help_syntax_sudo_prefix="$CHARS_SUPER_PROMPT"
	else
		help_syntax_prefix="$CHARS_REGULAR_PROMPT"
		help_syntax_sudo_prefix="$CHARS_SUDO_PROMPT"
	fi

	if [[ -z $USER_ARGS_RAW ]]; then
		opts_show_basic_help=true
		skip_package_actions=true
		DisableDebugToArchiveAndFile
	else
		Packages:Load || return
		ParseArgs
	fi

	EraseThisLine

	if [[ $hide_title = false && $opts_verbose = false ]]; then
		Display "$(FormatAsTitle) $(FormatAsVersion) $(FormatAsDescription)"
		DisplayLineSpaceIfNoneAlready
	fi

	if ! QPKGs.Conflicts:Check; then
		skip_package_actions=true
		Func:Exit 1; return
	fi

	QPKGs.Warnings:Check

	# KLUDGE: remove all max QTS versions from /etc/config/qpkg.conf (these are not removed automatically when installing updated QPKGs without max version set)
	# Retain this kludge for 12 months to give everyone time to update their installed sherpa QPKGs. Remove after 2023-09-22

	if [[ $(/sbin/getcfg sherpa max_versions_cleared -d FALSE -f /etc/config/qpkg.conf) = FALSE ]]; then
		$SED_CMD -i '/^FW_Ver_Max/d' /etc/config/qpkg.conf
		$SETCFG_CMD sherpa max_versions_cleared TRUE -f /etc/config/qpkg.conf
	fi

	ArgSuggestions:Show
	Self:LogEnv
	Self:IsAnythingToDo
	Self:Validate
	Func:Exit

	}

Self:Results()
	{

	display_last_action_datetime=false

	if ARGs-unknown:IsNone; then
		if [[ $opts_increase_qpkg_timeouts = true ]]; then
			QPKGs.Timeouts:Increase
		elif [[ $opts_revert_qpkg_timeouts = true ]]; then
			QPKGs.Timeouts:Decrease
		elif [[ $opts_show_abbreviations = true ]]; then
			QPKGs.Abbreviations:Show
		elif [[ $opts_show_actions = true ]]; then
			Help.Actions:Show
		elif [[ $opts_show_reassign = true ]]; then
			Help.Action.Reassign:Show
		elif [[ $opts_show_actions_all = true ]]; then
			Help.ActionsAll:Show
		elif [[ $opts_show_backups = true ]]; then
			QPKGs.Backups:Show
		elif [[ $opts_show_groups = true ]]; then
			Help.Groups:Show
		elif [[ $opts_show_options = true ]]; then
			Help.Options:Show
		elif [[ $opts_show_packages = true ]]; then
			QPKGs:List:Show
		elif [[ $opts_show_problems = true ]]; then
			Help.Problems:Show
		elif [[ $opts_show_repos = true ]]; then
			QPKGs.Repos:Show
		elif [[ $opts_show_results = true ]]; then
			display_last_action_datetime=true
			opts_show_packages_ok=true
			opts_show_packages_skipped=true
			opts_show_packages_failed=true
		elif [[ $opts_show_status = true ]]; then
			QPKGs.Statuses:Show
			opts_show_packages_ok=false
			opts_show_packages_skipped=false
			opts_show_packages_failed=false
		elif [[ $opts_show_tips = true ]]; then
			Help.Tips:Show
		fi

		if [[ $opts_paste_log_last = true ]]; then
			Log.Last:Paste
		elif [[ $opts_show_log_last = true ]]; then
			Self.LockFile:Release
			Log.Last:View
		elif [[ $opts_paste_log_tail = true ]]; then
			Log.Tail:Paste
		elif [[ $opts_show_log_tail = true ]]; then
			Self.LockFile:Release
			Log.Tail:View
		elif [[ $opts_show_versions = true ]]; then
			Self.Vers:Show
		fi

		if QPKGs.AClist.ISbackedup:IsSet; then
			QPKGs.IsBackedUp:Show
		elif QPKGs.AClist.ISNTbackedup:IsSet; then
			QPKGs.IsNtBackedUp:Show
		elif QPKGs.AClist.ISinstalled:IsSet; then
			QPKGs.IsInstalled:Show
		elif QPKGs.AClist.ISNTinstalled:IsSet; then
			QPKGs.IsNtInstalled:Show
		elif QPKGs.AClist.ISactive:IsSet; then
			QPKGs.IsActive:Show
		elif QPKGs.AClist.ISNTactive:IsSet; then
			QPKGs.IsNtActive:Show
		elif QPKGs.AClist.SCinstallable:IsSet; then
			QPKGs.ScInstallable:Show
		elif QPKGs.AClist.SCupgradable:IsSet; then
			QPKGs.ScUpgradable:Show
		elif QPKGs.AClist.SCstandalone:IsSet; then
			QPKGs.ScStandalone:Show
		elif QPKGs.AClist.SCdependent:IsSet; then
			QPKGs.ScDependent:Show
		fi
	fi

	if [[ $opts_show_basic_help = true ]]; then
		Help.Basic:Show
		Help.Basic.Example:Show
	fi

	[[ $opts_show_packages_ok = true ]] && Actions.Results:Show ok
	[[ $opts_show_packages_skipped = true ]] && Actions.Results:Show skipped
	[[ $opts_show_packages_failed = true ]] && Actions.Results:Show failed
	[[ $opts_show_backuploc = true ]] && Help.BackupLocation:Show
	[[ $show_zero_qpkgs = true ]] && ShowZeroQpkgs
	[[ $show_suggest_raise_issue = true ]] && Help.Issue:Show

	DebugInfoMinSepr
	DebugScript finished "$(/bin/date)"
	DebugScript 'elapsed time' "$(FormatSecsToHoursMinutesSecs "$(($(/bin/date +%s)-SCRIPT_STARTSECONDS))")"
	DebugInfoMajSepr

	[[ ${self_debug_archive_afterward:=false} = true ]] && ArchiveActiveSessLog
	ResetActiveSessLog

	if [[ $opts_verbose = false ]]; then
		EraseThisLine
		DisplayLineSpaceIfNoneAlready   # final on-screen linespace
	fi

	return 0

	}

Vars:Load()
	{

	# default values
	backup_stdin_fd=none
	colourful=true
	hide_title=false
	ipks_install=false
	ipks_upgrade=false
	linespace_visible=false
	msg_pipe_fd=none
	pips_install=false
	qpkg_timeouts_increased=false
	show_suggest_raise_issue=false
	show_zero_qpkgs=true
	skip_package_actions=false

	# user-selectable options
	opts_check=false
	opts_increase_qpkg_timeouts=false
	opts_revert_qpkg_timeouts=false
	opts_verbose=false

	opts_paste_log_last=false
	opts_paste_log_tail=false

	opts_show_abbreviations=false
	opts_show_actions=false
	opts_show_actions_all=false
	opts_show_backups=false
	opts_show_backuploc=false
	opts_show_basic_help=false
	opts_show_groups=false
	opts_show_log_last=false
	opts_show_log_tail=false
	opts_show_options=false
	opts_show_packages=false
	opts_show_packages_failed=false
	opts_show_packages_ok=false
	opts_show_packages_skipped=false
	opts_show_problems=false
	opts_show_reassign=false
	opts_show_repos=false
	opts_show_results=false
	opts_show_status=false
	opts_show_tips=false
	opts_show_versions=false

	package_ver_final_col_width=0

	}

Consts:Load()
	{

	if ! /bin/grep -q "$(echo 'ZG9udGVkaXQK' | /usr/bin/openssl enc -base64 -d)" "$0"; then		# use encrypted search-string to prevent grep finding this code line
		local -r SOURCE_BRANCH=stable
	else
		local -r SOURCE_BRANCH=unstable
	fi

	# default values
	readonly THIS_PACKAGE_PATH=$(QPKG.InstallationPath)
	readonly THIS_PACKAGE_VER=$(QPKG.Local.Ver)
	readonly THIS_SCRIPT_VER="<?today?>-$SOURCE_BRANCH"

	readonly CACHE_PATH=$THIS_PACKAGE_PATH/cache
	readonly LOGS_PATH=$THIS_PACKAGE_PATH/logs
	readonly QPKG_DL_PATH=$CACHE_PATH/QPKGs.downloads
	readonly QPKG_BU_PATH=$(GetDefVol)/.qpkg_config_backup
	readonly CERT_DB_PATHFILE=/etc/config/nas_sign_qpkg.db
	readonly IPK_DL_PATH=$CACHE_PATH/IPKs.downloads
	readonly IPK_CACHE_PATH=$CACHE_PATH/IPKs
	readonly PIP_CACHE_PATH=$CACHE_PATH/PIPs
	readonly ACTION_TIMES_PATH=$CACHE_PATH/action.times
	readonly ACTION_MSG_PIPE=/var/run/sherpa.action.messages.pipe

	readonly FILE_CHANGE_THRESHOLD_MINUTES=60
	readonly STATUS_CHECK_TIMEOUT_SECONDS=10
	readonly QPKG_START_TIMEOUT_SECONDS=1500		# 25 minutes
	readonly QPKG_RESTART_TIMEOUT_SECONDS=1800		# 30 minutes
	readonly QPKG_STOP_TIMEOUT_SECONDS=300			# 5 minutes
	readonly QPKG_ENABLE_TIMEOUT_SECONDS=10
	readonly QPKG_DISABLE_TIMEOUT_SECONDS=10
	readonly QPKG_EXTENDED_TIMEOUT_SECONDS=1800		# 30 minutes - this value is applied to 'qpkg_service' when '--increase-timeout' is specified

	readonly OBJECTS_PATHFILE=$CACHE_PATH/objects
	readonly OBJECTS_ARCHIVE_URL='<?cdn_sherpa_url?>'/objects.tar.gz
	readonly OBJECTS_ARCHIVE_PATHFILE=$CACHE_PATH/objects.tar.gz

	readonly PACKAGES_PATHFILE=$CACHE_PATH/packages
	readonly PACKAGES_ARCHIVE_URL='<?cdn_sherpa_url?>'/packages.tar.gz
	readonly PACKAGES_ARCHIVE_PATHFILE=$CACHE_PATH/packages.tar.gz

	# Entware
	readonly EXTERNAL_PACKAGES_ARCHIVE_PATHFILE=/opt/var/opkg-lists/entware
	readonly EXTERNAL_PACKAGES_PATHFILE=$CACHE_PATH/Packages

	readonly PREV_IPK_LIST=$CACHE_PATH/ipk.prev.list
	readonly PREV_PIP_LIST=$CACHE_PATH/pip.prev.list

	readonly SESS_ARCHIVE_PATHFILE=$LOGS_PATH/session.archive.log
	readonly SESS_LAST_PATHFILE=$LOGS_PATH/session.last.log
	readonly SESS_TAIL_PATHFILE=$LOGS_PATH/session.tail.log
	readonly SESS_ACTIONS_RESULTS_PATHFILE=$LOGS_PATH/session.action.results.log
	readonly REPORT_PATHFILE=$LOGS_PATH/report.ansi
	readonly RAMDISKS_FREESPACE_PATHFILE=$LOGS_PATH/ramdisks.freespace
	readonly DISPLAY_INHBIT_PATHFILE=$CACHE_PATH/display.inhibit

	readonly ACTION_RESULT_INDENT=6
	readonly FILE_NAME_COL_WIDTH=33
	readonly HELP_DESC_INDENT=3
	readonly HELP_SYNTAX_INDENT=6

	readonly PACKAGE_NAME_COL_WIDTH=21
	readonly PACKAGE_STATUS_COL_WIDTH=23
	readonly PACKAGE_AUTHOR_COL_WIDTH=22
	readonly PACKAGE_REPO_COL_WIDTH=40
	readonly PACKAGE_INSTALL_DATE_COL_WIDTH=18
	readonly PACKAGE_VER_COL_WIDTH=17
	readonly PACKAGE_PATH_COL_WIDTH=48
	readonly PACKAGE_ABBS_COL_WIDTH=84
	readonly PACKAGE_DESCRIPTION_COL_WIDTH=100

	readonly CHAR_SPACER=' '

	readonly CHARS_SPECIAL='• '
	readonly CHARS_BLANK=$CHAR_SPACER'  '
	readonly CHARS_NORMAL=$CHAR_SPACER'- '
	readonly CHARS_ALERT=$CHAR_SPACER'! '
	readonly CHARS_DROPEND='└─ '
	readonly CHARS_DROPTHRU='├─ '
	readonly CHARS_NOTE='* '
	readonly CHARS_RESULTS='= '
	readonly CHARS_ELLIPSIS='...'
	readonly CHARS_REGULAR_PROMPT='$ '
	readonly CHARS_SUPER_PROMPT='# '
	readonly CHARS_SUDO_PROMPT="${CHARS_REGULAR_PROMPT}sudo "

	readonly DEBUG_LOG_DATAWIDTH=100
	readonly DEBUG_LOG_FIRST_COL_WIDTH=9
	readonly DEBUG_LOG_SECOND_COL_WIDTH=18

	# cherry-pick Entware binaries
	readonly OPKG_CMD=/opt/bin/opkg
	readonly GNU_FIND_CMD=/opt/bin/find
	readonly GNU_GREP_CMD=/opt/bin/grep
	readonly GNU_LESS_CMD=/opt/bin/less
	readonly GNU_SED_CMD=/opt/bin/sed
	readonly GNU_SLEEP_CMD=/opt/bin/sleep
	readonly GNU_SORT_CMD=/opt/bin/sort
	readonly GNU_SQLITE_CMD=/opt/bin/sqlite3
	readonly GNU_STTY_CMD=/opt/bin/stty
	readonly GNU_TIMEOUT_CMD=/opt/bin/timeout

	readonly PERL_CMD=/opt/bin/perl
	readonly PYTHON_CMD=/opt/bin/python
	readonly PYTHON3_CMD=/opt/bin/python3
	readonly PIP_CMD="$PYTHON3_CMD -m pip"

	# cherry-pick QTS binaries
	readonly AWK_CMD=/bin/awk
	readonly CAT_CMD=/bin/cat
	# don't assign a const for `/bin/date` as it's already been called before arriving here
	readonly DF_CMD=/bin/df
	readonly GREP_CMD=/bin/grep
	readonly LESS_CMD=/bin/less
	readonly MD5SUM_CMD=/bin/md5sum
	readonly MKNOD_CMD=/bin/mknod
	readonly MKTEMP_CMD=/bin/mktemp
	readonly SED_CMD=/bin/sed
	readonly SH_CMD=/bin/sh
	readonly QTS_SLEEP_CMD=/bin/sleep
	readonly TAR_CMD=/bin/tar
	readonly TOUCH_CMD=/bin/touch
	readonly UNAME_CMD=/bin/uname
	readonly UNIQ_CMD=/bin/uniq

	readonly CURL_CMD=/sbin/curl
	# don't assign a const for `/sbin/getcfg` as it's already been called before arriving here
	readonly SETCFG_CMD=/sbin/setcfg

	readonly BASENAME_CMD=/usr/bin/basename
	readonly DIRNAME_CMD=/usr/bin/dirname
	readonly DU_CMD=/usr/bin/du
	readonly HEAD_CMD=/usr/bin/head
	readonly READLINK_CMD=/usr/bin/readlink
	readonly SORT_CMD=/usr/bin/sort
	readonly TAIL_CMD=/usr/bin/tail
	readonly TEE_CMD=/usr/bin/tee
	readonly UNZIP_CMD=/usr/bin/unzip
	readonly UPTIME_CMD=/usr/bin/uptime
	readonly WC_CMD=/usr/bin/wc

	}

Env:Confirm()
	{

	# Confirm required binaries are present
	IsSysFileExist $AWK_CMD || return
	IsSysFileExist $CAT_CMD || return
	# don't perform a check for `/bin/date` as it's already been called before arriving here
	IsSysFileExist $DF_CMD || return
	IsSysFileExist $GREP_CMD || return
	# KLUDGE: don't perform a check for `/bin/less` because it's not always there
	IsSysFileExist $MD5SUM_CMD || return
	IsSysFileExist $MKNOD_CMD || return
	IsSysFileExist $MKTEMP_CMD || return
	IsSysFileExist $SED_CMD || return
	IsSysFileExist $SH_CMD || return
	[[ ! -e $GNU_SLEEP_CMD ]] && { IsSysFileExist $QTS_SLEEP_CMD || return ;}
	IsSysFileExist $TAR_CMD || return
	IsSysFileExist $TOUCH_CMD || return
	IsSysFileExist $UNAME_CMD || return
	IsSysFileExist $UNIQ_CMD || return

	IsSysFileExist $CURL_CMD || return
	# don't perform a check for `/sbin/getcfg` as it's already been called before arriving here
	IsSysFileExist $SETCFG_CMD || return

	IsSysFileExist $BASENAME_CMD || return
	IsSysFileExist $DIRNAME_CMD || return
	IsSysFileExist $DU_CMD || return
	IsSysFileExist $HEAD_CMD || return
	IsSysFileExist $READLINK_CMD || return
	[[ ! -e $SORT_CMD ]] && ln -s /bin/busybox "$SORT_CMD"	# KLUDGE: `/usr/bin/sort` randomly disappears from QTS
	IsSysFileExist $TAIL_CMD || return
	IsSysFileExist $TEE_CMD || return
	IsSysFileExist $UNZIP_CMD || return
	IsSysFileExist $UPTIME_CMD || return
	IsSysFileExist $WC_CMD || return

	}

Lists:Load()
	{

	# these are used internally by sherpa -----------------------------------------------------
	# ordered
	PACKAGE_TIERS=(standalone addon dependent)

	# sorted
	QPKG_IS_STATES=(active backedup downloaded enabled installed missing signed slow unknown)
	QPKG_ISNT_STATES=(active backedup downloaded enabled installed signed)
	QPKG_STATES_TRANSIENT=(starting stopping restarting)
	QPKG_SERVICE_RESULTS=(ok failed unknown)

	# sorted
	IPK_STATES=(downloaded installed reinstalled upgraded)

	# ordered
	PIP_ACTIONS=(download uninstall upgrade reinstall install)
	IPK_ACTIONS=(download uninstall upgrade reinstall install)
	QPKG_ACTIONS=(status rebuild reassign download backup deactivate disable uninstall upgrade reinstall install restore clean enable activate reactivate sign)

	# these actions, states and scopes may be specified by the user -----------------------------------------------------
	# sorted
	USER_QPKG_SC_GROUPS=(all canbackup canclean canrestarttoupdate dependent hasdependents installable standalone upgradable)
	USER_QPKG_SCNT_GROUPS=(canclean installable upgradable)
	USER_QPKG_IS_STATES=(active backedup enabled installed missing)
	USER_QPKG_ISNT_STATES=(active backedup enabled installed)
	USER_QPKG_ACTIONS=(activate backup clean enable deactivate disable install list reactivate reassign rebuild reinstall restore status uninstall upgrade)

	# KLUDGE: for some reason, setting `readonly` while populating arrays causes their scope to become local, so need to set as `readonly` afterward to ensure global scope. GNU bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)
	readonly PACKAGE_TIERS

	readonly QPKG_IS_STATES
	readonly QPKG_ISNT_STATES
	readonly QPKG_STATES_TRANSIENT
	readonly QPKG_SERVICE_RESULTS

	readonly IPK_STATES

	readonly PIP_ACTIONS
	readonly IPK_ACTIONS
	readonly QPKG_ACTIONS

	readonly USER_QPKG_SC_GROUPS
	readonly USER_QPKG_SCNT_GROUPS
	readonly USER_QPKG_IS_STATES
	readonly USER_QPKG_ISNT_STATES
	readonly USER_QPKG_ACTIONS

	local action=''

	for action in "${QPKG_ACTIONS[@]}" check debug update; do
		readonly "$(Uppercase "$action")"_LOG_FILE="$action".log
	done

	}

CreatePaths()
	{

	# KLUDGE: service scripts prior to 2022-12-08 would use these paths (by-default) to build/cache Python packages. This has been fixed, but still need to free-up this space to prevent out-of-space issues.
	[[ -d /root/.cache ]] && rm -rf /root/.cache
	[[ -d /root/.local/share/virtualenv ]] && rm -rf /root/.local/share/virtualenv

	[[ -d $IPK_DL_PATH ]] && rm -rf "$IPK_DL_PATH"
	[[ -d $IPK_CACHE_PATH ]] && rm -rf "$IPK_CACHE_PATH"
	[[ -d $PIP_CACHE_PATH ]] && rm -rf "$PIP_CACHE_PATH"

	MakePath "$CACHE_PATH" cache || return
	MakePath "$LOGS_PATH" logs || return
	MakePath "$QPKG_DL_PATH" 'QPKG download' || return
	MakePath "$IPK_DL_PATH" 'IPK download' || return
	MakePath "$IPK_CACHE_PATH" 'IPK cache' || return
	MakePath "$PIP_CACHE_PATH" 'PIP cache' || return
	MakePath "$ACTION_TIMES_PATH" 'action times' || return
	MakePath "$QPKG_BU_PATH" 'QPKG backup' || return

	}

Self:LogEnv()
	{

	[[ $skip_package_actions = true ]] && return

	Func:Entry
	ShowAsProc environment
	DebugInfoMinSepr
	DebugHardware ok model "$(get_display_name)"
	DebugHardware ok CPU "$(GetCPUInfo)"
	DebugHardware ok 'CPU cores' "$CPU_CORES"
	DebugHardware ok 'CPU architecture' "$NAS_ARCH"
	DebugHardware ok RAM "$(FormatAsThous "$NAS_RAM_KB")kiB"
	DebugFirmware ok OS "$(GetQnapOS)"

	if OS.IsSupported; then
		DebugFirmware ok version "$NAS_FIRMWARE_VER.$NAS_FIRMWARE_BUILD"
	else
		DebugFirmware warning version "$NAS_FIRMWARE_VER"
	fi

	if OS.IsCompatibleWithSigned; then
		DebugFirmware ok 'build date' "$NAS_FIRMWARE_DATE"
	else
		DebugFirmware warning 'build date' "$NAS_FIRMWARE_DATE"
	fi

	DebugFirmware ok kernel "$(GetKernel)"
	DebugFirmware ok platform "$NAS_PLATFORM"
	DebugUserspace ok 'OS uptime' "$(GetUptime)"

	if OS.IsStarting; then
		DebugUserspace warning 'OS startup' starting-up
	else
		DebugUserspace ok 'OS startup' complete
	fi

	if OS.IsStopping; then
		DebugUserspace warning 'OS shutdown' shutting-down
	else
		DebugUserspace ok 'OS shutdown' inactive
	fi

	DebugUserspace ok 'system load' "$(GetSysLoadAverages)"

	if [[ $EUID -eq 0 ]]; then
		DebugUserspace ok '$EUID' "$EUID"
	else
		DebugUserspace warning '$EUID' "$EUID"
	fi

	DebugUserspace ok '$SUDO_UID' "$(GetSudoUID)"
	DebugUserspace ok 'time in shell' "$(GetTimeInShell)"
	DebugUserspace ok '$BASH_VERSION' "$BASH_VERSION"
	DebugUserspace ok 'default volume' "$(GetDefVol)"
	DebugUserspace ok '/opt' "$($READLINK_CMD /opt 2>/dev/null || echo '<not present>')"

	local public_share=$(/sbin/getcfg SHARE_DEF defPublic -d Qpublic -f /etc/config/def_share.info)

	if [[ -L /share/$public_share ]]; then
		DebugUserspace ok "'$public_share' share" "/share/$public_share"
	else
		DebugUserspace warning "'$public_share' share" '<not present>'
	fi

	local -i max_width=70
	local -i trimmed_width=$((max_width-${#CHARS_ELLIPSIS}))

	if [[ ${#PATH} -le $max_width ]]; then
		DebugUserspace ok '$PATH' "$PATH"
	else
		DebugUserspace ok '$PATH (LHS-only)' "${PATH:0:trimmed_width}${CHARS_ELLIPSIS}"
	fi

	DebugBinPathVerAndMinVer python "$(GetPythonVer)" "$MIN_PYTHON_VER"
	DebugBinPathVerAndMinVer python3 "$(GetPython3Ver)" "$MIN_PYTHON_VER"
	DebugBinPathVerAndMinVer perl "$(GetPerlVer)" "$MIN_PERL_VER"
	DebugScript 'logs path' "$LOGS_PATH"
	DebugScript 'cache path' "$CACHE_PATH"
	DebugQpkg detect 'action concurrency' "$CONCURRENCY"

	if OS.IsSupportSignedPackages; then
		if OS.IsAllowUnsignedPackages; then
			DebugQpkg detect 'allow unsigned' yes
		else
			DebugQpkg detect 'allow unsigned' no
		fi
	else
		DebugQpkg detect 'allow unsigned' 'N/A'
	fi

	DebugQpkg detect architecture "$NAS_QPKG_ARCH"

	if QPKGs.IsTimeoutsIncreased; then
		DebugQpkg detect 'timeouts increased' yes
	else
		DebugQpkg warning 'timeouts increased' no
	fi

	DebugQpkg detect 'Entware installer' "$ENTWARE_VER"
	DebugInfoMinSepr
	RunAndLog "$DF_CMD -h | $GREP_CMD '^Filesystem\|^none\|^tmpfs\|ram'" "$RAMDISKS_FREESPACE_PATHFILE"

	QPKGs.States:Build
	Func:Exit

	}

Self:IsAnythingToDo()
	{

	# Establish whether there's something to-do

	[[ $skip_package_actions = true ]] && return

	local action=''
	local group=''
	local state=''
	local something_to_do=false

	if [[ $opts_check = true || $opts_show_status = true ]]; then
		something_to_do=true
	else
		for action in "${USER_QPKG_ACTIONS[@]}"; do
			[[ $action = list ]] && continue

			if QPKGs-AC${action}-to:IsAny; then
				something_to_do=true
				break
			fi

			for group in "${USER_QPKG_SC_GROUPS[@]}"; do
				if QPKGs.AC${action}.SC${group}:IsSet; then
					something_to_do=true
					break 2
				fi
			done

			for group in "${USER_QPKG_SCNT_GROUPS[@]}"; do
				if QPKGs.AC${action}.SCNT${group}:IsSet; then
					something_to_do=true
					break 2
				fi
			done

			for state in "${USER_QPKG_IS_STATES[@]}"; do
				if QPKGs.AC${action}.IS${state}:IsSet; then
					something_to_do=true
					break 2
				fi
			done

			for state in "${USER_QPKG_ISNT_STATES[@]}"; do
				if QPKGs.AC${action}.ISNT${state}:IsSet; then
					something_to_do=true
					break 2
				fi
			done
		done
	fi

	if [[ $something_to_do = false ]]; then
		ShowAsError "I've nothing to-do (the supplied arguments were incomplete, or didn't make sense)"
		opts_show_basic_help=true
		skip_package_actions=true
		return 1
	fi

	return 0

	}

Self:Validate()
	{

	# This function handles most of the high-level logic for package actions.
	# If a package isn't being processed by the correct action, odds-are it's due to a logic error in this function.

	[[ $skip_package_actions = true ]] && return

	Func:Entry
	ShowAsProc arguments

	local installed_ver=''
	local package=''
	local action=''
	local prospect=''

	# Decide if IPKs and PIPs should be installed/upgraded

	if [[ $opts_check = true ]] || QPKGs-ACupgrade-to:Exist Entware || QPKGs-ACinstall-to:Exist Entware || QPKGs-ACreinstall-to:Exist Entware; then
		ipks_upgrade=true
		ipks_install=true
		pips_install=true

		if QPKG.IsInstalled Entware && QPKG.IsEnabled Entware; then
			if [[ -e $PYTHON3_CMD ]]; then
				installed_ver=$(GetPython3Ver "$PYTHON3_CMD")

				if [[ ${installed_ver//./} -lt $MIN_PYTHON_VER ]]; then
					ShowAsInfo 'the installed Python environment will be upgraded'
					IPKs-ACuninstall-to:Add 'python*'
				fi
			fi

			if [[ -e $PERL_CMD ]]; then
				installed_ver=$(GetPerlVer "$PERL_CMD")

				if [[ ${installed_ver//./} -lt $MIN_PERL_VER ]]; then
					ShowAsInfo 'the installed Perl environment will be upgraded'
					IPKs-ACuninstall-to:Add 'perl*'
				fi
			fi
		fi
	fi

	QPKGs.IsCanBackup:Build
	QPKGs.IsCanRestartToUpdate:Build
	QPKGs.IsCanClean:Build
	AllocGroupPacksToAcs
	QPKGs-SCupgradable:Exist sherpa && QPKGs-ACupgrade-to:Add sherpa

	# KLUDGE: ensure old installs of Entware are reinstalled, due to an OpenSSL update breaking several IPKs in mid-March 2023

	if QPKG.IsInstalled Entware && QPKG.IsEnabled Entware; then
		local entware_install_date=$(QPKG.InstallDate Entware)

		if [[ ${entware_install_date//-/} -le 20230318 ]]; then
			ShowAsInfo 'the Entware QPKG will be reinstalled (an OpenSSL update in mid-March 2023 broke a few packages)'
			QPKGs-ACreinstall-to:Add Entware
		fi
	fi

	# Meta-action pre-processing

	if QPKGs-ACrebuild-to:IsAny; then
		for package in $(QPKGs-ACrebuild-to:Array); do
			QPKGs-ACinstall-to:Add "$package"
			QPKGs-ACrestore-to:Add "$package"
			QPKGs-ACrebuild-to:Remove "$package"
		done
	fi

	# Ensure standalone packages are also installed when processing these specific actions

	for action in upgrade reinstall install; do
		for package in $(QPKGs-AC${action}-to:Array); do
			for prospect in $(QPKG:GetStandalones "$package"); do
				QPKGs-ACinstall-to:Add "$prospect"
			done
		done
	done

	# Install standalones for installed dependents

	for package in $(QPKGs-ISinstalled:Array); do
		if [[ $opts_check = true ]] || QPKGs-ACactivate-to:Exist "$package"; then
			for prospect in $(QPKG:GetStandalones "$package"); do
				QPKGs-ISNTinstalled:Exist "$prospect" && QPKGs-ACinstall-to:Add "$prospect"
			done
		fi
	done

	# If a standalone has been selected for `reinstall`/`reactivate`, need to `deactivate` its dependents first, and `activate` them again later

	for package in $(QPKGs-ACreinstall-to:Array) $(QPKGs-ACreactivate-to:Array); do
		if QPKGs-SCstandalone:Exist "$package" && QPKGs-ISinstalled:Exist "$package"; then
			for prospect in $(QPKG:GetDependents "$package"); do
				if QPKGs-ISinstalled:Exist "$prospect"; then
					QPKGs-ACdeactivate-to:Add "$prospect"
					! QPKGs-ACuninstall-to:Exist "$prospect" && ! QPKGs-ACinstall-to:Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
				fi
			done
		fi
	done

	# If a standalone has been selected for `deactivate`/`uninstall`, need to `deactivate` its dependents first

	for package in $(QPKGs-ACdeactivate-to:Array) $(QPKGs-ACuninstall-to:Array); do
		if QPKGs-SCstandalone:Exist "$package" && QPKGs-ISinstalled:Exist "$package"; then
			for prospect in $(QPKG:GetDependents "$package"); do
				QPKGs-ISinstalled:Exist "$prospect" && QPKGs-ACdeactivate-to:Add "$prospect"
			done
		fi
	done

	# If a standalone has been selected for `uninstall`, then `install`, need to `deactivate` its dependents first, and `activate` them again later

	for package in $(QPKGs-ACuninstall-to:Array); do
		if QPKGs-SCstandalone:Exist "$package" && QPKGs-ISinstalled:Exist "$package"; then
			if QPKGs-ACinstall-to:Exist "$package"; then
				for prospect in $(QPKG:GetDependents "$package"); do
					if QPKGs-ISinstalled:Exist "$prospect"; then
						QPKGs-ACdeactivate-to:Add "$prospect"
						! QPKGs-ACuninstall-to:Exist "$prospect" && ! QPKGs-ACinstall-to:Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
					fi
				done
			fi
		fi
	done

	# Entware is a special case: complete removal and fresh install (to clear all installed IPKs)

	if QPKGs-ACreinstall-to:Exist Entware; then
		QPKGs-ACreinstall-to:Remove Entware
		QPKGs-ACuninstall-to:Add Entware
		QPKGs-ACinstall-to:Add Entware
	fi

	# If dependents have been selected for `reinstall`/`install`/`activate`/`reactivate, need to `activate` their standalone packages first

	for action in reinstall install activate reactivate; do
		for package in $(QPKGs-AC${action}-to:Array); do
			for prospect in $(QPKG:GetStandalones "$package"); do
				QPKGs-ISinstalled:Exist "$prospect" && QPKGs-ACactivate-to:Add "$prospect"
			done
		done
	done

	# Check for packages that must be enabled first, because `activate`/`reactivate` was requested

	for action in activate reactivate; do
		for package in $(QPKGs-AC${action}-to:Array); do
			QPKGs-ISinstalled:Exist "$package" && QPKGs-ISNTenabled:Exist "$package" && QPKGs-ACenable-to:Add "$package"
		done
	done

	# No-need to `deactivate`/`reactivate`/`disable` packages that are to be uninstalled

	if QPKGs.ACuninstall.SCall:IsSet; then
		QPKGs-ACdeactivate-to:Init
		QPKGs-ACreactivate-to:Init
		QPKGs-ACdisable-to:Init
	else
		QPKGs-ACdeactivate-to:Remove "$(QPKGs-ACuninstall-to:Array)"
		QPKGs-ACreactivate-to:Remove "$(QPKGs-ACuninstall-to:Array)"
		QPKGs-ACdisable-to:Remove "$(QPKGs-ACuninstall-to:Array)"
	fi

	# No-need to `activate` packages that are to be upgraded/reinstalled/installed/reactivated

	for action in upgrade reinstall install reactivate; do
		QPKGs-ACactivate-to:Remove "$(QPKGs-AC${action}-to:Array)"
	done

	# Build a list of original storage paths for packages to be uninstalled, then installed again later this session (a "complex reinstall")
	# This will ensure migrated packages end-up in their original locations
	QPKGs_were_installed_name=()
	QPKGs_were_installed_path=()

	if QPKGs-ACuninstall-to:IsAny; then
		for package in $(QPKGs-ACuninstall-to:Array); do
			if QPKGs-ISinstalled:Exist "$package" && QPKGs-ACinstall-to:Exist "$package"; then
				QPKGs_were_installed_name+=("$package")
				QPKGs_were_installed_path+=("$($DIRNAME_CMD "$(QPKG.InstallationPath "$package")")")
			fi
		done
	fi

	# Build list of required installation QPKGs
	QPKGs-ACdownload-to:Add "$(QPKGs-ACupgrade-to:Array) $(QPKGs-ACreinstall-to:Array) $(QPKGs-ACinstall-to:Array)"

	# Check all items

	if [[ $opts_check = true ]]; then
		QPKGs-ACsign-to:Add "$(QPKGs-ISinstalled:Array)"

		for package in $(QPKGs-SCdependent:Array); do
			! QPKGs-SCupgradable:Exist "$package" && QPKGs-SCcanrestarttoupdate:Exist "$package" && QPKGs-ISenabled:Exist "$package" && QPKGs-ACreactivate-to:Add "$package"
		done
	fi

	# KLUDGE: just in-case `python` has disappeared again ... ¯\_(ツ)_/¯
	[[ -e $PYTHON3_CMD && ! -L $PYTHON_CMD ]] && ln -s "$PYTHON3_CMD" "$PYTHON_CMD"

	Func:Exit

	}

# QPKG action processing shall be conducted in this order:
#
#	1. status all
#	2. rebuild all				(meta-action: `install` QPKG and `restore` config, but only if package has an existing backup file)
#	3. reassign all
#	4. download all
#	5. backup all
#
#	6. stop/deactivate dependents
#	7. disable dependents
#	8. stop/deactivate standalones
#	9. disable standalones
#  10. uninstall all
#
#  11. upgrade standalones
#  12. reinstall standalones
#  13. install standalones
#  14. restore standalones
#  15. clean standalones		(unsupported by all standalone QPKGs)
#  16. enable standalones
#  17. restart/reactivate standalones
#  18. start/activate standalones
#
#  19. upgrade dependents
#  20. reinstall dependents
#  21. install dependents
#  22. restore dependents
#  23. clean dependents			(supported by most dependent packages, but not all)
#  24. enable dependents
#  25. restart/reactivate dependents
#  26. start/activate dependents
#
#  27. "sign" all

Actions:Proc()
	{

	# Run all actions on selected packages in all tiers

	[[ $skip_package_actions = true ]] && return

	Func:Entry
	local tier=''
	local action=''
	local -i tier_index=0

	rm -f "$SESS_ACTIONS_RESULTS_PATHFILE"

	if QPKGs-ACstatus-to:IsAny; then
		Action:Proc status all QPKG statusing statused || return
	else
		Action:Proc reassign all QPKG reassigning reassigned || return
		Action:Proc download all QPKG downloading downloaded || return
		Action:Proc backup all QPKG backing-up backed-up || return

		# -> package removal phase begins here <-

		for ((tier_index=${#PACKAGE_TIERS[@]}-1; tier_index>=0; tier_index--)); do	# process tiers in-reverse
			tier=${PACKAGE_TIERS[$tier_index]}

			case $tier in
				standalone|dependent)
					Action:Proc deactivate $tier QPKG deactivating deactivated || return
					Action:Proc disable $tier QPKG disabling disabled || return
					Action:Proc uninstall $tier QPKG uninstalling uninstalled || return
			esac
		done

		# -> package installation phase begins here <-

		for tier in "${PACKAGE_TIERS[@]}"; do
			case $tier in
				standalone|dependent)
					Action:Proc upgrade $tier QPKG upgrading upgraded || return
					Action:Proc reinstall $tier QPKG reinstalling reinstalled || return
					Action:Proc install $tier QPKG installing installed || return
					Action:Proc restore $tier QPKG restoring restored || return
					Action:Proc clean $tier QPKG cleaning cleaned || return
					Action:Proc enable $tier QPKG enabling enabled || return
					Action:Proc reactivate $tier QPKG reactivating reactivated || return
					Action:Proc activate $tier QPKG activating activated || return
					;;
				addon)
					for action in install reinstall upgrade activate; do
						QPKGs-ISenabled:Exist Entware && ipks_upgrade=true
						QPKGs-AC${action}-to:IsAny && ipks_install=true
					done

					if QPKGs-ISenabled:Exist Entware; then
						ModPathToEntware
						Action:Proc upgrade $tier IPK upgrading upgraded || return
						Action:Proc install $tier IPK installing installed || return

						pips_install=true
						Action:Proc install $tier PIP installing installed || return
					fi
			esac
		done

		if OS.IsSupportSignedPackages; then
			Action:Proc sign all QPKG '"signing"' '"signed"' || return
		fi
	fi

	EraseThisLine

	[[ $opts_check = true ]] && ShowAsDone 'check complete'

	if [[ ${opts_debug:-false} = true ]]; then
#		PIPs.Actions:List
		IPKs.Actions:List
		QPKGs.Actions:List
	fi

	[[ $opts_verbose = true ]] && QPKGs.States:List rebuild		# rebuild these after processing QPKGs to get current states
	Func:Exit

	}

Action:Proc()
	{

	# Run a single action on an entire tier of packages, asynchronously where possible

	# input:
	#   $1 = $TARGET_ACTION					e.g. `activate`, `reactivate` ...
	#   $2 = $TIER							e.g. `standalone`, `dependent`, `addon`, `all`
	#   $3 = $PACKAGE_TYPE					e.g. `QPKG`, `IPK`, `PIP`
	#   $4 = $ACTION_PRESENT_MSG			e.g. `activating` ...
	#   $5 = $ACTION_PAST_MSG				e.g. `activated` ...

	Func:Entry
	local -r PACKAGE_TYPE=${3:?null}
	local -r TARGET_ACTION=${1:-null}
	total_count=0
	local package=''
	local state=''
	local group=''
	local msg1_key=''
	local msg1_value=''
	local msg2_key=''
	local msg2_value=''
	local -i package_index=0
	local -a target_packages=()
	local -r TIER=${2:?null}
	local -r ACTION_PRESENT_MSG=${4:?null}
	local -r ACTION_PAST=${5:?null}
	local original_colourful=$colourful
	local -r ACTION_TIMES_PATHFILE="$ACTION_TIMES_PATH/$TARGET_ACTION.milliseconds"
	local buffer=''

	case $PACKAGE_TYPE in
		QPKG)
			TARGET_OBJECT_NAME="AC${TARGET_ACTION}-to"

			if [[ $TIER = all ]]; then  # process all tiers
				target_packages=($(${PACKAGE_TYPE}s-$TARGET_OBJECT_NAME:Array))
			else						# process a single tier only
				for package in $(${PACKAGE_TYPE}s-$TARGET_OBJECT_NAME:Array); do
					${PACKAGE_TYPE}s-SC${TIER}:Exist "$package" && target_packages+=("$package")
				done
			fi

			total_count=${#target_packages[@]}
			DebugVar total_count

			ShowAsProc "$ACTION_PRESENT_MSG $([[ $TIER != all ]] && echo "$TIER ")$(Uppercase "$PACKAGE_TYPE")$(Pluralise "$total_count")"

			if [[ $total_count -eq 0 ]]; then
				DebugInfo 'nothing to process'
				Func:Exit; return
			fi

			AdjustMaxForks "$TARGET_ACTION"
			InitForkCounts
			OpenActionMsgPipe

			re=\\bEntware\\b		# bash 3.2 regex with word boundaries: https://stackoverflow.com/a/9793094

			if [[ $TARGET_ACTION = uninstall && ${target_packages[*]} =~ $re ]]; then
				Keystrokes:Show		# enable this before removing Entware & GNU `stty`
			fi

			_ActionForks:Launch_ "_${PACKAGE_TYPE}:${TARGET_ACTION}_" "${target_packages[@]}" &
			fork_pid=$!

			# read message pipe and process QPKGs and actions as-per requests contained within
			while [[ ${#target_packages[@]} -gt 0 ]]; do
				ReadMsgFromActionPipe msg1_key msg1_value msg2_key msg2_value

				case $msg1_key in
					env)			# change the state of the sherpa environment
						eval "$msg1_value"	# run this as executable
						;;
					change)			# change the state of a single QPKG in the parent shell
						while true; do
							for group in "${USER_QPKG_SC_GROUPS[@]}"; do
								case $msg1_value in
									"SC${group}")
										[[ $(type -t QPKGs-SCNT${group}:Init) = function ]] && QPKGs-SCNT${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-SC${group}:Init) = function ]] && QPKGs-SC${group}:Add "$msg2_value"
										break 2
								esac
							done

							for group in "${USER_QPKG_SCNT_GROUPS[@]}"; do
								case $msg1_value in
									"SCNT${group}")
										[[ $(type -t QPKGs-SC${group}:Init) = function ]] && QPKGs-SC${group}:Remove "$msg2_value"
										[[ $(type -t QPKGs-SCNT${group}:Init) = function ]] && QPKGs-SCNT${group}:Add "$msg2_value"
										break 2
								esac
							done

							for state in "${QPKG_IS_STATES[@]}"; do
								case $msg1_value in
									"IS${state}")
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Add "$msg2_value"
										break 2
								esac
							done

							for state in "${QPKG_ISNT_STATES[@]}"; do
								case $msg1_value in
									"ISNT${state}")
										[[ $(type -t QPKGs-IS${state}:Init) = function ]] && QPKGs-IS${state}:Remove "$msg2_value"
										[[ $(type -t QPKGs-ISNT${state}:Init) = function ]] && QPKGs-ISNT${state}:Add "$msg2_value"
										break 2
								esac
							done

							DebugAsWarn "unidentified change in message queue: '$msg1_value'"
							break
						done
						;;
					status)			# update the status of a single action fork in the parent shell
						case $msg1_value in
							ok)		# completed OK (wonderful)
								((ok_count++))
								;;
							so)		# action was skipped, but this is normal (no-big-deal)
								((skip_ok_count++))
								;;
							sk)		# action was skipped (and there's a good reason for it)
								((skip_count++))
								;;
							se)		# action was skipped due to error prior to action being tried (might be a big-deal)
								((skip_error_count++))
								;;
							er)		# action failed (uh-oh)
								((fail_count++))
						esac

						case $msg1_value in
							ok|so|sk|se|er)
								[[ $(type -t QPKGs-AC${TARGET_ACTION}-to:Init) = function ]] && QPKGs-AC${TARGET_ACTION}-to:Remove "$msg2_value"
								[[ $(type -t QPKGs-AC${TARGET_ACTION}-${msg1_value}:Init) = function ]] && QPKGs-AC${TARGET_ACTION}-${msg1_value}:Add "$msg2_value"
								;;
							ex)		# action is about to exit
								for package_index in "${!target_packages[@]}"; do
									if [[ ${target_packages[package_index]} = "$msg2_value" ]]; then
										unset 'target_packages[package_index]'
										break
									fi
								done
								;;
							*)
								DebugAsWarn "unidentified status in message queue: '$msg1_value'"
						esac
						;;
					*)
						DebugAsWarn "unidentified key in message queue: '$msg1_key'"
				esac
			done

			[[ $ok_count -gt 0 ]] && opts_show_packages_ok=true
			[[ $skip_count -gt 0 || $skip_error_count -gt 0 ]] && opts_show_packages_skipped=true
			[[ $fail_count -gt 0 ]] && opts_show_packages_failed=true

			[[ ${#target_packages[@]} -gt 0 ]] && KillActiveFork		# should only be needed if an action fork didn't exit properly
			wait 2>/dev/null
			CloseActionMsgPipe

			# sort QPKG action times - longest duration first

			if [[ -e $ACTION_TIMES_PATHFILE && -e $GNU_SORT_CMD && -L /opt/etc/passwd ]]; then	# try to ensure Entware is active before using this utility
				buffer=$($GNU_SORT_CMD -t'|' -k2 -r -h < "$ACTION_TIMES_PATHFILE")
				echo "$buffer" > "$ACTION_TIMES_PATHFILE"
			fi

			;;
		IPK|PIP)
			ShowAsProc "$ACTION_PRESENT_MSG $([[ $TIER != all ]] && echo "$TIER ")$(Uppercase "$PACKAGE_TYPE")s"

			InitForkCounts
			${PACKAGE_TYPE}s:${TARGET_ACTION}	# only process these packages in groups, not individually
	esac

	# show completed line in colour if colour was enabled earlier, as ANSI codes create a longer onscreen message (due to extra characters used). Showing completed line without colour means part of previous onscreen message may not be blanked.

	if [[ $original_colourful = true && $colourful = false ]]; then
		colourful=true
		ShowAsActionResult "$TIER" "$PACKAGE_TYPE" "$ok_count" "$total_count" "$ACTION_PAST"
		colourful=false
	else
		ShowAsActionResult "$TIER" "$PACKAGE_TYPE" "$ok_count" "$total_count" "$ACTION_PAST"
	fi

	ShowAsActionResultDetail "$TIER" "$TARGET_ACTION" "$PACKAGE_TYPE"

	EraseForkCountPaths
	Func:Exit
	Self.Error:IsNt

	}

OpenActionMsgPipe()
	{

	# create a message pipe, so action forks can send data back to parent

	[[ -p $ACTION_MSG_PIPE ]] && rm -f "$ACTION_MSG_PIPE"
	[[ ! -p $ACTION_MSG_PIPE ]] && mknod "$ACTION_MSG_PIPE" p

	# create a file descriptor to store original stdin FD
	backup_stdin_fd=$(FindNextFD)
	DebugVar backup_stdin_fd

	# backup original stdin file descriptor so it can be restored later
	eval "exec $backup_stdin_fd>&0"

	# create another file descriptor to use in message pipe
	msg_pipe_fd=$(FindNextFD)
	DebugVar msg_pipe_fd

	# open a 2-way channel to message pipe
	[[ $msg_pipe_fd != none ]] && eval "exec $msg_pipe_fd<>$ACTION_MSG_PIPE"

	}

CloseActionMsgPipe()
	{

	# restore original file descriptors, and remove message pipe

	# restore stdin FD
	[[ $backup_stdin_fd != none ]] && eval "exec 0>&$backup_stdin_fd"

	# release backup of stdin FD
	[[ $backup_stdin_fd != none ]] && eval "exec $backup_stdin_fd>&-"

	# release message pipe FD
	[[ $msg_pipe_fd != none ]] && eval "exec $msg_pipe_fd>&-"

	# delete message pipe
	[[ -p $ACTION_MSG_PIPE ]] && rm -f "$ACTION_MSG_PIPE"

	}

AdjustMaxForks()
	{

	# input:
	#   $1 = action

	# output:
	#   $max_forks (global)

	max_forks=$CONCURRENCY
	local reason=''

	# no-point running actions async in debug mode: their stdout will make a confusing mess of the screen

	if [[ $opts_debug = true ]]; then
		max_forks=1
		reason='debug mode is active'
	else
		case ${1:-} in
			clean)						# precautionary: don't make too-many calls to PyPI at the same time
				max_forks=$(((max_forks+1)/2))
				reason="'$1'"
				;;
			install|reinstall|upgrade)	# don't execute these actions async: installer for each package eventually aborts (looks like QPKGs can only be managed one-at-a-time, else packages overwrite each other, and package source files end-up in the wrong install paths)
				max_forks=1
				reason="'$1'"
				;;
			sign)						# precautionary: don't create multiple writes to the certificate database at the same time
				max_forks=1
				reason="'$1'"
				;;
			backup|deactivate|disable|download|enable|status|uninstall)		# low-resource actions, so force multiple forks, even on ARMv5
				max_forks=4
				reason="'$1'"
		esac

		[[ -n $reason ]] && reason+=' action was requested'
	fi

	[[ -n $reason ]] && DebugInfo "limiting \$max_forks to $max_forks because $reason"
	DebugVar max_forks

	}

ParseArgs()
	{

	# basic argument syntax:
	#   scriptname [action] [groups] [options]

	Func:Entry
	DebugVar USER_ARGS_RAW

	local user_args_fixed=$(Lowercase "${USER_ARGS_RAW//,/ }")
	local -a user_args=(${user_args_fixed/--/})
	local arg=''
	local arg_identified=false
	local action=''
	local action_force=false
	local group=''
	local group_identified=false
	local package=''

	for arg in "${user_args[@]}"; do
		arg_identified=false

		# identify action: every time action changes, must clear group too
		case $arg in
		# these cases use only a single word to specify a single action
			backup|clean|enable|disable|reassign|rebuild|reinstall|restore)
				action=${arg}
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			paste)
				# shellcheck disable=2209
				action=paste
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=true
				;;
		# all cases below can use multiple words or chars to specify a single action
			activate|start)
				action=activate
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			add|install)
				action=install
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			c|check)
				action=check
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			deactivate|stop)
				action=deactivate
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			decrease-timeout|decrease-timeouts|revert-timeout|revert-timeouts)
				action=reverttimeout
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=true
				;;
			display|help|list|show|view)
				action=help
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=true
				;;
			increase-timeout|increase-timeouts)
				action=increasetimeout
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=true
				;;
			reactivate|restart)
				action=reactivate
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			rm|remove|uninstall)
				action=uninstall
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
				;;
			s|status|statuses)
				action=status
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
 				skip_package_actions=false
				;;
			update|upgrade)
				action=upgrade
				arg_identified=true
				group=''
				group_identified=false
				hide_title=false
				skip_package_actions=false
		esac

		# identify group in two stages: stage 1 for when user didn't supply an action before group, stage 2 is after an action has been defined.

		# stage 1

		if [[ -z $action ]]; then
			case $arg in
				a|abs|action|actions|actions-all|alias|aliases|all-actions|b|backups|deps|dependent|dependents|disabled|enabled|failed|groups|indeps|independent|independents|installable|installed|l|last|log|missing|not-installed|ok|option|options|p|package|packages|problems|r|repo|repos|results|skipped|standalone|standalones|tail|tips|updatable|updateable|upgradable|v|version|versions|whole)
					action=help
					arg_identified=true
					group=''
					group_identified=false
					skip_package_actions=true
			esac

			DebugVar action
		fi

		# stage 2

		if [[ -n $action ]]; then
			case $arg in
			# these cases use only a single word or char to specify a single group
				backedup|installable|installed|missing|ok|problems|results|skipped|tail|tips)
					group=${arg}
					;;
				not-backedup)
					group=NTbackedup
					;;
				not-installed)
					group=NTinstalled
					;;
				failed)
					group=NTok
					;;
			# all cases below can use multiple words or chars to specify a single group
				a|abs|alias|aliases)
					group=abs
					;;
				actions-all|all-actions)
					group=all-actions
					;;
				action|actions)
					group=actions
					;;
				all|entire|everything)
					group=all
					;;
				b|backups)
					group=backups
					;;
				deps|dependent|dependents)
					group=dependent
					;;
				group|groups)
					group=groups
					;;
				l|last)
					group=last
					;;
				log|whole)
					group=log
					;;
				option|options)
					group=options
					;;
				p|package|packages)
					group=packages
					;;
				r|repo|repos)
					group=repos
					;;
				standalone|standalones|indeps|independent|independents)
					group=standalone
					;;
				updatable|updateable|upgradable)
					group=upgradable
					;;
				v|version|versions)
					group=versions
			esac

			if [[ -n $group ]]; then
				group_identified=true
				arg_identified=true
			fi
		fi

		# identify options
		case $arg in
			debug|dbug|verbose)
				arg_identified=true
				group_identified=true
				;;
			force)
				action_force=true
				arg_identified=true
		esac

		# identify package
		package=$(QPKG.MatchAbbrv "$arg")

		if [[ -n $package ]]; then
			group_identified=true
			arg_identified=true
		fi

		[[ $arg_identified = false ]] && ARGs-unknown:Add "$arg"

		case $action in
			activate|backup|clean|deactivate|disable|enable|install|reactivate|reassign|rebuild|reinstall|restore|upgrade)
				case $group in
					all|dependent|standalone|upgradable)
						QPKGs.AC${action}.SC${group}:Set
						group=''
						;;
					installed)
						QPKGs.AC${action}.IS${group}:Set
						group=''
						;;
					*)
						QPKGs-AC${action}-to:Add "$package"
				esac
				;;
			check)
				opts_check=true
				;;
			help)
				case $group in
					abs)
						opts_show_abbreviations=true
						;;
					actions)
						opts_show_actions=true
						;;
					all-actions|all)
						opts_show_actions_all=true
						;;
					backedup|installed|NTbackedup|NTinstalled)
						QPKGs.AClist.IS${group}:Set
						hide_title=true
						;;
					backups)
						opts_show_backups=true
						;;
					dependent|installable|standalone|upgradable)
						QPKGs.AClist.SC${group}:Set
						hide_title=true
						;;
					failed)
						opts_show_packages_failed=true
						;;
					groups)
						opts_show_groups=true
						;;
					last)
						opts_show_log_last=true
						hide_title=true
						;;
					log)
						opts_show_log_tail=true
						hide_title=true
						;;
					ok)
						opts_show_packages_ok=true
						;;
					options)
						opts_show_options=true
						;;
					packages)
						opts_show_packages=true
						;;
					problems)
						opts_show_problems=true
						;;
					reassign)
						opts_show_reassign=true
						;;
					repos)
						opts_show_repos=true
						;;
					results)
						opts_show_results=true
						;;
					skipped)
						opts_show_packages_skipped=true
						;;
					status)
						opts_show_status=true
						;;
					tips)
						opts_show_tips=true
						;;
					versions)
						opts_show_versions=true
						hide_title=true
				esac

				skip_package_actions=true
				;;
			increasetimeout)
				opts_increase_qpkg_timeouts=true
				;;
			paste)
				case $group in
					all|log|tail)
						opts_paste_log_tail=true
						action=''
						;;
					last)
						opts_paste_log_last=true
						action=''
				esac

				skip_package_actions=true
				;;
			reverttimeout)
				opts_revert_qpkg_timeouts=true
				;;
			status)
				opts_show_status=true

				case $group in
					all|dependent|standalone|upgradable)
						QPKGs.AC${action}.SC${group}:Set
						group=''
						;;
					installed)
						QPKGs.AC${action}.IS${group}:Set
						group=''
						;;
					*)
						QPKGs-AC${action}-to:Add "$package"
				esac
				;;
			uninstall)
				case $group in
					all)		# this group is dangerous, so make `force` a requirement
						if [[ $action_force = true ]]; then
							QPKGs.AC${action}.SC${group}:Set
							group=''
							action_force=false
						fi
						;;
					dependent|standalone)
						QPKGs.AC${action}.SC${group}:Set
						group=''
						action_force=false
						;;
					installed)	# this group is dangerous, so make `force` a requirement
						if [[ $action_force = true ]]; then
							QPKGs.AC${action}.IS${group}:Set
							group=''
							action_force=false
						fi
						;;
					upgradable)
						QPKGs.AC${action}.IS${group}:Set
						group=''
						action_force=false
						;;
					*)
						QPKGs-AC${action}-to:Add "$package"
				esac
		esac
	done

	# when an action has been determined, but no group was found, then show default information. This will usually be the help screen.

	if [[ -n $action && $group_identified = false ]]; then
		case $action in
			help|paste)
				opts_show_basic_help=true
		esac
	fi

	if [[ $opts_show_status = true ]] && QPKGs-ACstatus-to:IsNone; then		# if user specifies `status` without a scope, then scope is `all`.
		QPKGs.ACstatus.SCall:Set
	fi

	if ARGs-unknown:IsAny; then
		opts_show_basic_help=true
		skip_package_actions=true
		hide_title=false
	fi

	Func:Exit

	}

ArgSuggestions:Show()
	{

	Func:Entry
	local arg=''

	if ARGs-unknown:IsAny; then
		ShowAsError "unknown argument$(Pluralise "$(ARGs-unknown:Count)"): \"$(ARGs-unknown:List)\". Please check the argument list again"

		for arg in $(ARGs-unknown:Array); do
			case $arg in
				all)
					DisplayAsProjSynExam "please provide a valid $(FormatAsAction) before 'all' like" 'activate all'
					opts_show_basic_help=false
					;;
				all-backup|backup-all)
					DisplayAsProjSynExam 'to backup all installed package configurations, use' 'backup all'
					opts_show_basic_help=false
					;;
				dependent)
					DisplayAsProjSynExam "please provide a valid $(FormatAsAction) before 'dependent' like" 'activate dependents'
					opts_show_basic_help=false
					;;
				all-reactivate|reactivate-all)
					DisplayAsProjSynExam 'to reactivate all packages, use' 'reactivate all'
					opts_show_basic_help=false
					;;
				all-restore|restore-all)
					DisplayAsProjSynExam 'to restore all installed package configurations, use' 'restore all'
					opts_show_basic_help=false
					;;
				standalone)
					DisplayAsProjSynExam "please provide a valid $(FormatAsAction) before 'standalone' like" 'activate standalones'
					opts_show_basic_help=false
					;;
				all-activate|activate-all)
					DisplayAsProjSynExam 'to activate all packages, use' 'activate all'
					opts_show_basic_help=false
					;;
				all-stop|stop-all)
					DisplayAsProjSynExam 'to stop all packages, use' 'stop all'
					opts_show_basic_help=false
					;;
				all-uninstall|all-remove|uninstall-all|remove-all)
					DisplayAsProjSynExam 'to uninstall all packages, use' 'force uninstall all'
					opts_show_basic_help=false
					;;
				all-upgrade|upgrade-all)
					DisplayAsProjSynExam 'to upgrade all packages, use' 'upgrade all'
					opts_show_basic_help=false
			esac
		done
	fi

	Func:Exit

	}

AllocGroupPacksToAcs()
	{

	Func:Entry
	local action=''
	local group=''
	local state=''
	local prospect=''
	local found=false		# group or state has been found

	for action in "${USER_QPKG_ACTIONS[@]}"; do
		# process group-based user-options

		for group in "${USER_QPKG_SC_GROUPS[@]}"; do
			found=false

			if QPKGs.AC${action}.SC${group}:IsSet; then
				case $action in
					clean)
						case $group in
							all|dependent|standalone)
								found=true

								for prospect in $(QPKGs-SC${group}:Array); do
									QPKG.IsCanClean "$prospect" && QPKGs-AC${action}-to:Add "$prospect"
								done
								;;
							*)
								DebugAsWarn "specified group $group has no handler for specified action $action"
						esac
						;;
					install)
						case $group in
							all|dependent|standalone)
								found=true

								QPKGs-AC${action}-to:Add "$(QPKGs-SC${group}:Array)"
								;;
							*)
								DebugAsWarn "specified group $group has no handler for specified action $action"
						esac
						;;
					activate|deactivate|enable|disable|reactivate|status|stop|uninstall)
						case $group in
							all|dependent|standalone)
								found=true

								for prospect in $(QPKGs-SC${group}:Array); do
									QPKGs-ISinstalled:Exist "$prospect" && QPKGs-AC${action}-to:Add "$prospect"
								done
								;;
							*)
								DebugAsWarn "specified group $group has no handler for specified action $action"
						esac
						;;
					rebuild)
						case $group in
							all|dependent|standalone)
								found=true

								for prospect in $(QPKGs-SC${group}:Array); do
									QPKGs-SCcanbackup:Exist "$prospect" && QPKGs-AC${action}-to:Add "$prospect"
								done
								;;
							*)
								DebugAsWarn "specified group $group has no handler for specified action $action"
						esac
						;;
					upgrade)
						case $group in
							all|dependent|standalone|upgradable)
								found=true

								QPKGs-AC${action}-to:Add "$(QPKGs-SCupgradable:Array)"

								for prospect in $(QPKGs-SC${group}:Array); do
									QPKGs-SCcanrestarttoupdate:Exist "$prospect" && QPKGs-AC${action}-to:Add "$prospect"
								done

								QPKGs-ACreactivate-to:Remove "$(QPKGs-ACupgrade-to:Array)"
								;;
							*)
								DebugAsWarn "specified group $group has no handler for specified action $action"
						esac
				esac

				if [[ $found = false ]]; then
					QPKGs-AC${action}-to:Add "$(QPKGs-SC${group}:Array)"
				fi

				if QPKGs-AC${action}-to:IsAny; then
					DebugAsDone "action: '$action', group: '$group': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any packages to $(Lowercase "$action")"
				fi
			fi
		done

		for group in "${USER_QPKG_SCNT_GROUPS[@]}"; do
			found=false

			if QPKGs.AC${action}.SCNT${group}:IsSet; then
				if [[ $found = false ]]; then
					QPKGs-AC${action}-to:Add "$(QPKGs-SCNT${group}:Array)"
				fi

				if QPKGs-AC${action}-to:IsAny; then
					DebugAsDone "action: '$action', group: 'NT${group}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any packages to $(Lowercase "$action")"
				fi
			fi
		done

		# process state-based user-options

		for state in "${USER_QPKG_IS_STATES[@]}"; do
			found=false

			if QPKGs.AC${action}.IS${state}:IsSet; then
				case $action in
					backup|clean|uninstall|upgrade)
						case $state in
							active|backedup|cleaned|downloaded|enabled|installed)
								found=true
								QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
								;;
							inactive)
								found=true
								QPKGs-AC${action}-to:Add "$(QPKGs-ISNTactive:Array)"
						esac
						;;
					install)
						case $state in
							active|enabled|inactive|installed)
								found=true
						esac
				esac

				if [[ $found = false ]]; then
					QPKGs-AC${action}-to:Add "$(QPKGs-IS${state}:Array)"
				fi

				if QPKGs-AC${action}-to:IsAny; then
					DebugAsDone "action: '$action', state: '$state': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any packages to $(Lowercase "$action")"
				fi
			fi
		done

		for state in "${USER_QPKG_ISNT_STATES[@]}"; do
			if QPKGs.AC${action}.ISNT${state}:IsSet; then
				case $action in
					active|backup|clean|install|uninstall)
						case $state in
							active|installed)
								found=true
								QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
								;;
							inactive)
								found=true
								QPKGs-AC${action}-to:Add "$(QPKGs-ISactive:Array)"
						esac
				esac

				if [[ $found = false ]]; then
					QPKGs-AC${action}-to:Add "$(QPKGs-ISNT${state}:Array)"
				fi

				if QPKGs-AC${action}-to:IsAny; then
					DebugAsDone "action: '$action', state: 'NT${state}': found $(QPKGs-AC${action}-to:Count) package$(Pluralise "$(QPKGs-AC${action}-to:Count)") to process"
				else
					ShowAsWarn "unable to find any packages to $(Lowercase "$action")"
				fi
			fi
		done
	done

	Func:Exit

	}

ResetArchivedLogs()
	{

	if [[ -n $LOGS_PATH && -d $LOGS_PATH ]]; then
		rm -rf "${LOGS_PATH:?}"/*
		echo 'log reset' > "$sess_active_pathfile"
		ShowAsDone 'all logs cleared'
	fi

	return 0

	}

ResetCachePath()
	{

	if [[ -n $CACHE_PATH && -d $CACHE_PATH ]]; then
		rm -rf "${CACHE_PATH:?}"/*
		ShowAsDone 'package cache cleared'
	fi

	return 0

	}

Quiz()
	{

	# input:
	#   $1 = prompt

	# output:
	#   $? = 0 if "y", 1 if anything else

	local prompt=${1:?null}
	local response=''

	ShowAsQuiz "$prompt"
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD igncr	# ignore CR to prevent an onscreen linefeed (which disrupts same-line rewrite used later, and looks bad)
	read -rn1 response
	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD -igncr	# re-allow CR
	DebugVar response

	ShowAsQuizDone "$prompt: $response"

	case ${response:0:1} in
		y|Y)
			return 0
			;;
		*)
			return 1
	esac

	}

PatchEntwareService()
	{

	local -r TAB=$'\t'
	local -r PREFIX='# the following line was inserted by sherpa: https://git.io/sherpa'
	local -r PACKAGE_INIT_PATHFILE=$(QPKG.ServicePathFile Entware)
	local find=''
	local insert=''

	if $GREP_CMD -q 'opt.orig' "$PACKAGE_INIT_PATHFILE"; then
		DebugInfo 'patch: do the "/opt shuffle" - already done'
	else
		# ensure existing files are moved out of the way before creating /opt symlink
		find='# sym-link $QPKG_DIR to /opt'
		insert='opt_path="/opt"; opt_backup_path="/opt.orig"; [[ -d "$opt_path" \&\& ! -L "$opt_path" \&\& ! -e "$opt_backup_path" ]] \&\& mv "$opt_path" "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${TAB}${PREFIX}\n${TAB}${insert}\n|" "$PACKAGE_INIT_PATHFILE"

		# ... then restored after creating /opt symlink
		find='/bin/ln -sf $QPKG_DIR /opt'
		insert='[[ -L "$opt_path" \&\& -d "$opt_backup_path" ]] \&\& cp "$opt_backup_path"/* --target-directory "$opt_path" \&\& rm -r "$opt_backup_path"'
		$SED_CMD -i "s|$find|$find\n\n${TAB}${PREFIX}\n${TAB}${insert}\n|" "$PACKAGE_INIT_PATHFILE"

		DebugAsDone 'patch: do the "opt shuffle"'
	fi

	return 0

	}

UpdateEntwarePackageList()
	{

	if IsNtSysFileExist $OPKG_CMD; then
		DisplayAsProjSynExam 'try reactivating Entware' 'reactivate ew'
		return 1
	fi

	[[ ${ENTWARE_PACKAGE_LIST_UPTODATE:-false} = true ]] && return 0

	local -i result_code=0

	# if Entware package list was recently updated, don't update again

	if ! IsThisFileRecent "$EXTERNAL_PACKAGES_ARCHIVE_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES" || [[ ! -f $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE || $opts_check = true ]]; then
		DebugAsProc "updating $(FormatAsPackName Entware) package list"

		RunAndLog "$OPKG_CMD update" "$LOGS_PATH/Entware.$UPDATE_LOG_FILE" log:failure-only
		result_code=$?

		if [[ $result_code -eq 0 ]]; then
			DebugAsDone "updated $(FormatAsPackName Entware) package list"
			CloseIpkArchive
		else
			DebugAsWarn "Unable to update $(FormatAsPackName Entware) package list $(FormatAsExitcode "$result_code")"
			# no-big-deal
		fi
	else
		DebugInfo "$(FormatAsPackName Entware) package list was updated less-than $FILE_CHANGE_THRESHOLD_MINUTES minutes ago: skipping update"
	fi

	[[ -f $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE && ! -f $EXTERNAL_PACKAGES_PATHFILE ]] && OpenIpkArchive
	readonly ENTWARE_PACKAGE_LIST_UPTODATE=true

	return 0

	}

IsThisFileRecent()
	{

	# input:
	#   $1 = pathfilename: file to examine change time of
	#   $2 = integer (optional): threshold in minutes - default is `1440` = 1 day

	# output:
	#   $? = true/false

	# examine `change` time as this is updated even if file content isn't modified

	if [[ -e $1 && -e $GNU_FIND_CMD ]]; then
		if [[ -z $($GNU_FIND_CMD "$1" -cmin +${2:-1440}) ]]; then	# no-output if last `change` was less than $2 minutes ago
			return 0
		fi
	fi

	return 1	# file not found, GNU `find` unavailable or file `change` time was more than $2 minutes ago

	}

SavePackageLists()
	{

	$PIP_CMD freeze > "$PREV_PIP_LIST" 2>/dev/null && DebugAsDone "saved current PIP module list to $(FormatAsFileName "$PREV_PIP_LIST")"
	$OPKG_CMD list-installed > "$PREV_IPK_LIST" 2>/dev/null && DebugAsDone "saved current $(FormatAsPackName Entware) IPK list to $(FormatAsFileName "$PREV_IPK_LIST")"

	}

CalcIpkDepsToInstall()
	{

	# From a specified list of IPK names, find all dependent IPKs, exclude those already installed, then generate a list to download

	IsNtSysFileExist $GNU_GREP_CMD && return 1

	Func:Entry
	local -a this_list=()
	local -a dep_acc=()
	local -i requested_count=0
	local -i pre_exclude_count=0
	local -i iterations=0
	local -r ITERATION_LIMIT=20
	local req_list=''
	local pre_exclude_list=''
	local element=''
	local complete=false

	# remove duplicate entries
	req_list=$(DeDupeWords "$(IPKs-ACinstall-to:List)")
	this_list=($req_list)
	requested_count=$($WC_CMD -w <<< "$req_list")

	if [[ $requested_count -eq 0 ]]; then
		DebugAsWarn 'no IPKs requested'
		Func:Exit 1; return
	fi

	ShowAsProc 'calculating IPK dependencies'
	DebugInfo "$requested_count IPK$(Pluralise "$requested_count") requested" "'$req_list' "

	while [[ $iterations -lt $ITERATION_LIMIT ]]; do
		((iterations++))

		local ipk_titles=$(printf '^Package: %s$\|' "${this_list[@]}")
		ipk_titles=${ipk_titles%??}		# remove last 2 characters

		this_list=($($GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator '^Package:\|^Depends:' "$EXTERNAL_PACKAGES_PATHFILE" | $GNU_GREP_CMD -vG '^Section:\|^Version:' | $GNU_GREP_CMD --word-regexp --after-context 1 --no-group-separator "$ipk_titles" | $GNU_GREP_CMD -vG "$ipk_titles" | $GNU_GREP_CMD -vG '^Package: ' | $SED_CMD 's|^Depends: ||;s|, |\n|g' | $SORT_CMD | $UNIQ_CMD))

		if [[ ${#this_list[@]} -eq 0 ]]; then
			complete=true
			break
		else
			dep_acc+=(${this_list[*]})
		fi
	done

	if [[ $complete = true ]]; then
		DebugAsDone "dependency calculation complete in $iterations iteration$(Pluralise "$iterations")"
	else
		DebugAsError "dependency calculation incomplete in $iterations iteration$(Pluralise "$iterations"), consider raising \$ITERATION_LIMIT [$ITERATION_LIMIT]"
		show_suggest_raise_issue=true
	fi

	# exclude already installed IPKs
	pre_exclude_list=$(DeDupeWords "$req_list ${dep_acc[*]}")
	pre_exclude_count=$($WC_CMD -w <<< "$pre_exclude_list")

	if [[ $pre_exclude_count -gt 0 ]]; then
		DebugInfo "$pre_exclude_count IPK$(Pluralise "$pre_exclude_count") required (including dependencies)" "'$pre_exclude_list' "

		DebugAsProc 'excluding IPKs already installed'

		for element in $pre_exclude_list; do
			# KLUDGE: silently exclude these packages from being installed:
			#   KLUDGE: `ca-certs` appears to be a bogus meta-package.
			#   KLUDGE: `python3-gdbm` is not available, but can be requested as per https://forum.qnap.com/viewtopic.php?p=806031#p806031 (don't know why).

			if [[ $element != 'ca-certs' && $element != 'python3-gdbm' ]]; then
				# KLUDGE: `libjpeg` appears to have been replaced by `libjpeg-turbo`, but many packages still have `libjpeg` as a dependency, so replace it with `libjpeg-turbo`.

				if [[ $element != 'libjpeg' ]]; then
					if ! $OPKG_CMD status "$element" | $GREP_CMD -q "Status:.*installed"; then
						IPKs-ACdownload-to:Add "$element"
					fi
				elif ! $OPKG_CMD status 'libjpeg-turbo' | $GREP_CMD -q "Status:.*installed"; then
					IPKs-ACdownload-to:Add 'libjpeg-turbo'
				fi
			fi
		done
	else
		DebugAsDone 'no IPKs to exclude'
	fi

	Func:Exit

	}

CalcIpkDownloadSize()
	{

	# calculate size of required IPKs

	Func:Entry
	local -a size_array=()
	local -i size_count=0
	size_count=$(IPKs-ACdownload-to:Count)

	if [[ $size_count -gt 0 ]]; then
		DebugAsDone "$size_count IPK$(Pluralise "$size_count") to download: '$(IPKs-ACdownload-to:List)'"
		DebugAsProc "calculating size of IPK$(Pluralise "$size_count") to download"
		size_array=($($GNU_GREP_CMD -w '^Package:\|^Size:' "$EXTERNAL_PACKAGES_PATHFILE" | $GNU_GREP_CMD --after-context 1 --no-group-separator ": $($SED_CMD 's/ /$ /g;s/\$ /\$\\\|: /g' <<< "$(IPKs-ACdownload-to:List)")" | $GREP_CMD '^Size:' | $SED_CMD 's|^Size: ||'))
		IPKs-ACdownload-to:Size = "$(IFS=+; echo "$((${size_array[*]}))")"		# a nifty sizing shortcut found here https://stackoverflow.com/a/13635566/6182835
		DebugAsDone "$(FormatAsThous "$(IPKs-ACdownload-to:Size)") bytes ($(FormatAsIsoBytes "$(IPKs-ACdownload-to:Size)")) to download"
	else
		DebugAsDone 'no IPKs to size'
	fi

	Func:Exit

	}

IPKs:upgrade()
	{

	# upgrade all installed IPKs

	[[ $ipks_upgrade = false ]] && return
	QPKGs-ISNTinstalled:Exist Entware && return
	QPKGs-ISNTenabled:Exist Entware && return
	UpdateEntwarePackageList
	Self.Error:IsSet && return

	Func:Entry
	local -i result_code=0
	IPKs-ACupgrade-to:Init
	IPKs-ACdownload-to:Init

	IPKs-ACupgrade-to:Add "$($OPKG_CMD list-upgradable | cut -f1 -d' ')"
	IPKs-ACdownload-to:Add "$(IPKs-ACupgrade-to:Array)"

	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		local desc="$total_count IPK module$(Pluralise "$total_count")"
		local log_pathfile=$LOGS_PATH/ipks.$UPGRADE_LOG_FILE
		ShowAsProc "upgrading $desc: "

		_DirSize:Monitor_ "$IPK_DL_PATH" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD upgrade --force-overwrite $(IPKs-ACdownload-to:List) --cache $IPK_CACHE_PATH --tmp-dir $IPK_DL_PATH" "$log_pathfile" log:failure-only
		result_code=$?

		KillActiveFork

		if [[ $result_code -eq 0 ]]; then
			ok_count=$total_count		# assume they all passed
			NoteIpkAcAsOk "$(IPKs-ACupgrade-to:Array)" upgrade
			DebugAsDone "upgraded $desc"
			SaveActionResultToLog IPK "$desc" upgrade ok "$result_code"
		else
			ShowAsFail "upgrade $total_count IPK$(Pluralise "$total_count") failed $(FormatAsExitcode "$result_code")"
			NoteIpkAcAsEr "$(IPKs-ACupgrade-to:Array)" upgrade
			SaveActionResultToLog IPK "$desc" upgrade failed "$result_code"
		fi
	fi

	Func:Exit

	}

IPKs:install()
	{

	# install IPKs required to support QPKGs

	[[ $ipks_install = false ]] && return
	QPKGs-ISNTinstalled:Exist Entware && return
	QPKGs-ISNTenabled:Exist Entware && return
	UpdateEntwarePackageList
	Self.Error:IsSet && return

	Func:Entry
	local -i index=0
	local -i result_code=0
	IPKs-ACinstall-to:Init
	IPKs-ACdownload-to:Init

	QPKGs-ACinstall-ok:Exist Entware && IPKs-ACinstall-to:Add "$ESSENTIAL_IPKS"

	if QPKGs.ACinstall.SCall:IsSet; then
		for index in "${!QPKG_NAME[@]}"; do
			IPKs-ACinstall-to:Add "${QPKG_REQUIRES_IPKS[$index]}"
		done
	else
		for index in "${!QPKG_NAME[@]}"; do
			if QPKGs-ACinstall-to:Exist "${QPKG_NAME[$index]}" || QPKGs-ISinstalled:Exist "${QPKG_NAME[$index]}" || QPKGs-ACreinstall-to:Exist "${QPKG_NAME[$index]}" || (QPKGs-ACactivate-to:Exist "${QPKG_NAME[$index]}" && (QPKGs-ACinstall-to:Exist "${QPKG_NAME[$index]}" || QPKGs-ISinstalled:Exist "${QPKG_NAME[$index]}" || QPKGs-ACreinstall-to:Exist "${QPKG_NAME[$index]}")); then
				QPKG.MinRAM "${QPKG_NAME[$index]}" &>/dev/null || continue
				IPKs-ACinstall-to:Add "${QPKG_REQUIRES_IPKS[$index]}"
			fi
		done
	fi

	CalcIpkDepsToInstall
	CalcIpkDownloadSize
	total_count=$(IPKs-ACdownload-to:Count)

	if [[ $total_count -gt 0 ]]; then
		local desc="$total_count addon IPK module$(Pluralise "$total_count")"
		local log_pathfile=$LOGS_PATH/ipks.$INSTALL_LOG_FILE
		ShowAsProc "installing $desc: "

		_DirSize:Monitor_ "$IPK_DL_PATH" "$(IPKs-ACdownload-to:Size)" &
		fork_pid=$!

		RunAndLog "$OPKG_CMD install --force-overwrite $(IPKs-ACdownload-to:List) --cache $IPK_CACHE_PATH --tmp-dir $IPK_DL_PATH" "$log_pathfile" log:failure-only
		result_code=$?

		KillActiveFork

		if [[ $result_code -eq 0 ]]; then
			ok_count=$total_count		# assume they all passed
			NoteIpkAcAsOk "$(IPKs-ACdownload-to:Array)" install
			DebugAsDone "installed $desc"
			SaveActionResultToLog IPK "$desc" install ok "$result_code"
			Keystrokes:Hide
			UpdateColourisation
		else
			fail_count=$total_count		# assume they all failed
			ShowAsFail "install $desc failed $(FormatAsExitcode "$result_code")"
			NoteIpkAcAsEr "$(IPKs-ACdownload-to:Array)" install
			SaveActionResultToLog IPK "$desc" install failed "$result_code"
		fi
	fi

	Func:Exit

	}

PIPs:install()
	{

	[[ $pips_install = false ]] && return
	QPKGs-ISNTinstalled:Exist Entware && return
	QPKGs-ISNTenabled:Exist Entware && return
	! $OPKG_CMD status python3-pip | $GREP_CMD -q "Status:.*installed" && return
	Self.Error:IsSet && return

	Func:Entry
	local exec_cmd=''
	local -i result_code=0
	local -r PACKAGE_TYPE='PyPI group'
	local -r RUNTIME=long

	if [[ $opts_check = true ]] || IPKs-ACinstall-ok:Exist python3-pip; then
		((total_count++))
		ShowAsActionProgress '' "$PACKAGE_TYPE" "$ok_count" "$skip_count" "$fail_count" "$total_count" installing "$RUNTIME"

		exec_cmd="$PIP_CMD install --upgrade --no-input $ESSENTIAL_PIPS --cache-dir $PIP_CACHE_PATH 2> >($GREP_CMD -v \"Running pip as the 'root' user\") >&2"
		local desc="addon PyPI modules"
		local log_pathfile=$LOGS_PATH/pypi.$INSTALL_LOG_FILE
		ShowAsProc "installing $desc: "
		RunAndLog "$exec_cmd" "$log_pathfile" log:failure-only
		result_code=$?

		if [[ $result_code -eq 0 ]]; then
			((ok_count++))
			DebugAsDone "installed $desc"
			SaveActionResultToLog PIP "$desc" install ok "$result_code"
		else
			((fail_count++))
			ShowAsFail "install $desc failed $(FormatAsResult "$result_code")"
			SaveActionResultToLog PIP "$desc" install failed "$result_code"
		fi

		ShowAsActionProgress '' "$PACKAGE_TYPE" "$ok_count" "$skip_count" "$fail_count" "$total_count" installing "$RUNTIME"
	fi

	Func:Exit $result_code

	}

OpenIpkArchive()
	{

	# unpack the package list file used by `opkg`

	# output:
	#   $? = 0 if successful or 1 if failed

	if [[ ! -e $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE ]]; then
		ShowAsError 'unable to locate the IPK list file'
		return 1
	fi

	RunAndLog "/usr/local/sbin/7z e -o$($DIRNAME_CMD "$EXTERNAL_PACKAGES_PATHFILE") $EXTERNAL_PACKAGES_ARCHIVE_PATHFILE" "$CACHE_PATH/ipk.archive.extract" log:failure-only

	if [[ ! -e $EXTERNAL_PACKAGES_PATHFILE ]]; then
		ShowAsError 'unable to open the IPK list file'
		return 1
	fi

	return 0

	}

CloseIpkArchive()
	{

	rm -f "$EXTERNAL_PACKAGES_PATHFILE"

	}

_ActionForks:Launch_()
	{

	# Execute actions concurrently, but only as many as $max_forks will allow given the circumstances

	# * This function runs as a background process *

	# inputs: (local)
	#   $1 = the target function action to be applied to each QPKG in $target_packages()
	#   $2 = an array of QPKG names to process with $1

	# inputs: (global)
	#   $fork_count = number of currently running forks
	#   $max_forks = maximum number of permitted concurrent forks given the current environment

	local package=''
	local target_function=${1:-function null}

	shift   # `shift` all arguments one position to the left
	local -a target_packages=("$@")

	for package in "${target_packages[@]}"; do
		while [[ $fork_count -ge $max_forks ]]; do  # don't fork until an empty spot becomes available
			sleep .2
			UpdateForkProgress
		done

		IncForkProgressIndex
		MarkThisActionForkAsStarted 	# must create runfile here, as it takes too long to happen in background function
		$target_function "$package" &
		DebugAsDone "forked $target_function() for '$package'"
		UpdateForkProgress
	done

	# all action forks have launched, just need to wait for them to exit

	while [[ $fork_count -gt 0 ]]; do
		sleep .2
		UpdateForkProgress	# update display while running forks complete
	done

	# all forks have exited
	sleep 1

	EraseThisLine

	}

_DirSize:Monitor_()
	{

	# * This function runs autonomously *

	# input:
	#   $1 = directory to monitor the size of
	#   $2 = total target bytes (100%) for specified path

	# output:
	#   stdout = "percentage downloaded (downloaded bytes/total expected bytes)"

	[[ -z ${1:?path null} || ! -d ${1:-} || -z ${2:?total bytes null} || ${2:-} -eq 0 ]] && exit
	IsNtSysFileExist $GNU_FIND_CMD && exit

	local -i current_bytes=-1
	local -i total_bytes=$2
	local -i last_bytes=0
	local -i stall_seconds=0
	local -i stall_seconds_threshold=4
	local perc_msg=''
	local progress_msg=''
	local stall_msg=''

	InitProgress

	while [[ $current_bytes -lt $total_bytes ]]; do
		current_bytes=$($GNU_FIND_CMD "$1" -type f -name '*.ipk' -exec $DU_CMD --bytes --total --apparent-size {} + 2>/dev/null | $GREP_CMD total$ | cut -f1)
		[[ -z $current_bytes ]] && current_bytes=0

		if [[ $current_bytes -ne $last_bytes ]]; then
			stall_seconds=0
			last_bytes=$current_bytes
		else
			((stall_seconds++))
		fi

		perc_msg="$((200*(current_bytes)/(total_bytes)%2+100*(current_bytes)/(total_bytes)))%"
		[[ $current_bytes -lt $total_bytes && $perc_msg = '100%' ]] && perc_msg='99%'	# ensure we don't hit 100% until the last byte is downloaded
		progress_msg="$perc_msg ($(ColourTextBrightWhite "$(FormatAsIsoBytes "$current_bytes")")/$(ColourTextBrightWhite "$(FormatAsIsoBytes "$total_bytes")"))"

		if [[ $stall_seconds -ge $stall_seconds_threshold ]]; then
			# append a message showing stalled time
			stall_msg=' stalled for '

			if [[ $stall_seconds -lt 60 ]]; then
				stall_msg+="$stall_seconds seconds"
			else
				stall_msg+="$(FormatSecsToHoursMinutesSecs "$stall_seconds")"
			fi

			# add a suggestion to cancel if download has stalled for too long

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg+=': cancel with CTRL+C and try again later'
			fi

			# colourise as-required

			if [[ $stall_seconds -ge 90 ]]; then
				stall_msg=$(ColourTextBrightRed "$stall_msg")
			elif [[ $stall_seconds -ge 45 ]]; then
				stall_msg=$(ColourTextBrightOrange "$stall_msg")
			elif [[ $stall_seconds -ge 20 ]]; then
				stall_msg=$(ColourTextBrightYellow "$stall_msg")
			fi

			progress_msg+=$stall_msg
		fi

		[[ ! -e $DISPLAY_INHBIT_PATHFILE ]] || return
		WriteMsgInPlace "$progress_msg"
		sleep 1
	done

	[[ -n $progress_msg ]] && WriteMsgInPlace 'done!'

	}

WriteMsgInPlace()
	{

	# input:
	#   $1 = message to display

	# output:
	#   stdout = "$1" with all whitespace squeezed.
	#   $prev_clean_msg = the message provided in $1, but with all whitespace squeezed, and with ANSI codes removed.

	local -i blanking_length=0
	local squeezed_msg=$(tr -s ' ' <<< "${1:-}")
	local clean_msg=$(StripANSI "$squeezed_msg")

	if [[ $clean_msg != "$prev_clean_msg" ]]; then
		if [[ ${#clean_msg} -lt ${#prev_clean_msg} ]]; then
			blanking_length=$((${#clean_msg}-${#prev_clean_msg}))
			# backspace to start of previous msg, print new msg, add additional spaces, then backspace to end of new msg
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$squeezed_msg"; printf "%${blanking_length}s"; printf "%${blanking_length}s" | tr ' ' '\b'
		else
			# backspace to start of previous msg, print new msg
			printf "%${#prev_clean_msg}s" | tr ' ' '\b'; echo -en "$squeezed_msg"
		fi

		prev_clean_msg=$clean_msg
	fi

	}

KillActiveFork()
	{

	if [[ -n ${fork_pid:-} && ${fork_pid:-0} -gt 0 && -d /proc/$fork_pid ]]; then
		sleep .2
		set +m		# disable job control
		kill -9 "$fork_pid"
		set -m		# re-enable job control
		wait
	fi

	} &>/dev/null

IsQNAP()
	{

	# is this a QNAP NAS?

	if [[ ! -e /etc/init.d/functions ]]; then
		ShowAsAbort 'QNAP functions not found ... is this a QNAP NAS?'
		return 1
	fi

	return 0

	}

IsSU()
	{

	# running as superuser?

	if [[ $EUID -ne 0 ]]; then
		if [[ -e /usr/bin/sudo ]]; then
			ShowAsError 'this utility must be run with superuser privileges. Try again as:'

			echo "${CHARS_SUDO_PROMPT}sherpa $USER_ARGS_RAW" >&2
		else
			ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
		fi

		return 1
	fi

	return 0

	}

IsReset()
	{

	local re=''
	re=\\breset\\b		# bash 3.2 regex with word boundaries: https://stackoverflow.com/a/9793094

	if [[ $USER_ARGS_RAW =~ $re ]]; then
		ResetArchivedLogs
		ResetCachePath
		ArchiveActiveSessLog
		ResetActiveSessLog
		exit 0
	fi

	}

IsVerbose()
	{

	local re=''
	re=\\bverbose\\b

	if [[ $USER_ARGS_RAW =~ $re ]]; then
		Display >&2
		Self.Verbose:Enable
	fi

	}

IsDebug()
	{

	local re=''

	for re in \\bdebug\\b \\bdbug\\b; do
		if [[ $USER_ARGS_RAW =~ $re ]]; then
			EnableDebugToArchiveAndFile
			break
		fi
	done

	}

TerminalDimensions:Load()
	{

	if [[ -e $GNU_STTY_CMD && -t 0 ]]; then
		local terminal_dimensions=$($GNU_STTY_CMD size)
		readonly SESS_ROWS=${terminal_dimensions% *}
		readonly SESS_COLS=${terminal_dimensions#* }
	else
		readonly SESS_ROWS=40
		readonly SESS_COLS=156
	fi

	return 0

	}

GetPython3Ver()
	{

	GetPythonVer "${1:-python3}"

	}

GetPythonVer()
	{

	GetThisBinPath ${1:-python} &>/dev/null && ${1:-python} -V 2>&1 | $SED_CMD 's|^Python ||'

	}

GetPerlVer()
	{

	GetThisBinPath ${1:-perl} &>/dev/null && ${1:-perl} -e 'print "$^V\n"' 2>/dev/null | $SED_CMD 's|v||'

	}

GetThisBinPath()
	{

	[[ -n ${1:?null} ]] && command -v "$1" 2>&1

	}

DebugBinPathVerAndMinVer()
	{

	# input:
	#	$1 = binary filename
	#	$2 = current version found
	#	$3 = minimum version required

	[[ -n ${1:-} ]] || return

	local bin_path=$(GetThisBinPath "$1")

	if [[ -n $bin_path ]]; then
		DebugUserspace ok "'$1' path" "$bin_path"
	else
		DebugUserspace warning "'$1' path" '<not present>'
	fi

	if [[ -n ${2:-} ]]; then
		if [[ ${2//./} -ge ${3//./} ]]; then
			DebugUserspace ok "'$1' version" "$2"
		else
			DebugUserspace warning "'$1' version" "$2"
		fi
	else
		DebugUserspace warning "'$1' version" '<unknown>'
	fi

	return 0

	}

IsSysFileExist()
	{

	# input:
	#   $1 = pathfile to check

	# output:
	#   $? = 0 (exists) or 1 (not exists)

	if ! [[ -f ${1:?pathfile null} || -L ${1:?pathfile null} ]]; then
		ShowAsAbort "a required NAS system file is missing $(FormatAsFileName "$1")"
		return 1
	fi

	return 0

	}

IsNtSysFileExist()
	{

	# input:
	#   $1 = pathfile to check

	# output:
	#   $? = 0 (not exists) or 1 (exists)

	! IsSysFileExist "${1:?pathfile null}"

	}

LenANSIDiff()
	{

	local stripped=$(StripANSI "${1:-}")
	echo "$((${#1}-${#stripped}))"

	return 0

	}

DisplayAsProjSynExam()
	{

	# display as project syntax example

	# input:
	#	$1 = description
	#	$2 = example syntax

	DisplayLineSpaceIfNoneAlready

	printf "${CHARS_SPECIAL}%s" "$(Capitalise "${1:-}")"
	[[ ${1: -1} != '!' ]] && printf ':'

	printf "\n%${HELP_SYNTAX_INDENT}s${help_syntax_sudo_prefix}%s\n" '' "sherpa ${2:-}"
	linespace_visible=false

	}

DisplayAsProjSynIndentExam()
	{

	# display as project syntax indented example

	# input:
	#	$1 = description
	#	$2 = example syntax

	if [[ -n $1	]]; then
		printf "\n%${HELP_DESC_INDENT}s%s" '' "$(Capitalise "${1:-}")"
		[[ ${1: -1} != '!' ]] && printf ':'
		printf '\n'
	fi

	printf "%${HELP_SYNTAX_INDENT}s${help_syntax_sudo_prefix}%s\n" '' "sherpa ${2:-}"
	linespace_visible=false

	}

DisplayAsSynExam()
	{

	# display as syntax example

	# input:
	#	$1 = description
	#	$2 = example syntax

	printf "\n${CHARS_SPECIAL}%s:\n%${HELP_SYNTAX_INDENT}s${help_syntax_prefix}%s\n" "$(Capitalise "${1:-}")" '' "${2:-}"
	linespace_visible=false

	}

DisplayAsHelpTitleNameAuthorDesc()
	{

	# input:
	#	$1 = package tier

	local package_name_msg=''
	local package_author_msg=''
	local package_description_msg=''

	DisplayLineSpaceIfNoneAlready

	# column 1: package name

	if [[ $maxcols -ge 1 ]]; then
		package_name_msg="${CHARS_SPECIAL}$1 QPKGs:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package author

	if [[ $maxcols -ge 2 ]]; then
		package_author_msg="${CHARS_SPECIAL}QPKG author:"
		printf "%-$((PACKAGE_AUTHOR_COL_WIDTH+2+$(LenANSIDiff "$package_author_msg")))s" "$package_author_msg"
	fi

	# column 3: package description

	if [[ $maxcols -ge 3 ]]; then
		package_description_msg="${CHARS_SPECIAL}QPKG description:"
		printf "%-$((PACKAGE_DESCRIPTION_COL_WIDTH+2+$(LenANSIDiff "$package_description_msg")))s" "$package_description_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpNameAuthorDesc()
	{

	# input:
	#	$1 = 'normal/highlighted/muted'
	#	$2 = package name
	#	$3 = author
	#	$4 = description
	#	$5 = notes (optional)
	#	$6 = true/false = "not installable"

	local package_name=${2:-}
	local package_name_msg="${CHARS_NORMAL}${package_name}"
	local package_author=${3:-}
	local package_author_msg="${CHARS_BLANK}${package_author}"
	local package_description=${4:-}
	local package_description_msg="${CHARS_BLANK}${package_description}"
	local package_notes=${5:-}
	local package_notes_msg="$(ColourTextCyan "${CHARS_NOTE}${package_notes}")"
	local package_not_installable=${6:-false}

	case $1 in
		muted)
			if [[ $package_not_installable = true ]]; then
				package_name_msg=$(ColourTextDarkGrey "${CHARS_ALERT}${package_name}")
			else
				package_name_msg=$(ColourTextDarkGrey "${CHARS_NORMAL}${package_name}")
			fi

			package_author_msg="$(ColourTextDarkGrey "$package_author")"
			package_description_msg="$(ColourTextDarkGrey "${CHARS_NORMAL}${package_description}")"
			;;
		highlighted)
			package_name_msg=$(ColourTextBrightRed "${CHARS_NORMAL}${package_name}")

			if [[ -n $package_author ]]; then
				case $package_author in
					missing)
						package_author_msg="$(ColourTextBrightRedBlink "${CHARS_ALERT}${package_author}")"
				esac
			fi
	esac

	# column 1: package name

	if [[ $maxcols -ge 1 && -n $package_name_msg ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package author

	if [[ $maxcols -ge 2 && -n $package_author ]]; then
		printf "%-$((PACKAGE_AUTHOR_COL_WIDTH+$(LenANSIDiff "$package_author_msg")))s" "$package_author_msg"
	fi

	# column 3: package description

	if [[ $maxcols -ge 3 && -n $package_description ]]; then
		printf "%-$((PACKAGE_DESCRIPTION_COL_WIDTH+$(LenANSIDiff "$package_description_msg")))s" "$package_description_msg"

		if [[ -n $package_notes ]]; then
			printf "\n%$((${#CHARS_BLANK}+PACKAGE_NAME_COL_WIDTH+PACKAGE_AUTHOR_COL_WIDTH))s${CHARS_DROPEND}%s" '' "$package_notes_msg"
		fi
	fi

	printf '\n'
	linespace_visible=false

	}

CalcMaxStatusColsToDisplay()
	{

	local col1_width=$((${#CHARS_SPECIAL}+PACKAGE_NAME_COL_WIDTH))
	local col2_width=$((${#CHAR_SPACER}+${#CHARS_SPECIAL}+PACKAGE_STATUS_COL_WIDTH))
	local col3_width=$((${#CHAR_SPACER}+${#CHARS_SPECIAL}+PACKAGE_VER_COL_WIDTH))
	local col4_width=$((${#CHAR_SPACER}+${#CHARS_SPECIAL}+PACKAGE_PATH_COL_WIDTH))

	# add width to include " (new)" string to QPKG version title
	if QPKGs-SCupgradable:IsAny; then
		package_ver_final_col_width=$((PACKAGE_VER_COL_WIDTH+6))
		((col3_width+6))
	else
		package_ver_final_col_width=$PACKAGE_VER_COL_WIDTH
	fi

	if [[ $((col1_width+col2_width)) -ge $SESS_COLS ]]; then
		maxcols=1
	elif [[ $((col1_width+col2_width+col3_width)) -ge $SESS_COLS ]]; then
		maxcols=2
	elif [[ $((col1_width+col2_width+col3_width+col4_width)) -ge $SESS_COLS ]]; then
		maxcols=3
	else
		maxcols=4
	fi

	return 0

	}

DisplayAsHelpTitleNameStatusVerPath()
	{

	# input:
	#	$1 = package tier

	local package_name_msg=''
	local package_status_msg=''
	local package_version_msg=''
	local package_path_msg=''

	DisplayLineSpaceIfNoneAlready

	# column 1: package name

	if [[ $maxcols -ge 1 ]]; then
		package_name_msg="${CHARS_SPECIAL}$1 QPKGs:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package statuses

	if [[ $maxcols -ge 2 ]]; then
		package_status_msg="${CHARS_SPECIAL}QPKG statuses:"
		printf "%-$((PACKAGE_STATUS_COL_WIDTH+2+$(LenANSIDiff "$package_status_msg")))s" "$package_status_msg"
	fi

	# column 3: package version

	if [[ $maxcols -ge 3 ]]; then
		if QPKGs-SCupgradable:IsNone; then
			package_version_msg="${CHARS_SPECIAL}QPKG version:"
		else
			package_version_msg="${CHARS_SPECIAL}QPKG version ($(ColourTextBrightOrange new)):"
		fi

		printf "%-$((package_ver_final_col_width+2+$(LenANSIDiff "$package_version_msg")))s" "$package_version_msg"
	fi

	# column 4: package installation path

	if [[ $maxcols -ge 4 ]]; then
		package_path_msg="${CHARS_SPECIAL}installation path:"
		printf "%-$((PACKAGE_PATH_COL_WIDTH+2+$(LenANSIDiff "$package_path_msg")))s" "$package_path_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpNameStatusVerPath()
	{

	# input:
	#	$1 = `normal/highlighted/muted`
	#	$2 = package name
	#	$3 = package status (optional) - only if installed
	#	$4 = package last result (optional)
	#	$5 = package current version number (optional) - only if installed
	#	$6 = package avilable/upgradable version number (optional)
	#	$7 = package installation path (optional) - only if installed

	local package_name=${2:-}
	local package_name_msg=''
	local package_status=${3:-}
	local package_status_msg=''
	local package_last_result=${4:-}
	local package_last_result_msg=''
	local package_installed_version=${5:-}
	local package_version_msg=''
	local package_upgrade_version=${6:-}
	local package_upgrade_version_msg=''
	local package_path=${7:-}
	local package_path_msg="${CHARS_BLANK}${package_path}"
	local patt=''

	case $1 in
		normal)
			package_name_msg="${CHARS_BLANK}$package_name"

			if [[ -n $package_status ]]; then
				patt=\\benabled\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightGreen enabled)"

				patt=\\bdisabled\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightRed disabled)"

				patt=\\bactive\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightGreen active)"

				patt=\\bslow\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightOrange slow)"

				patt=\\binactive\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightRed inactive)"

				patt=\\bstarting\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightOrange starting)"

				patt=\\bstopping\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightOrange stopping)"

				patt=\\bunknown\\b
				[[ $package_status =~ $patt ]] && package_status_msg+=" $(ColourTextBrightOrange unknown)"

				if [[ -n $package_status_msg ]]; then
					package_status_msg="${package_status_msg#* }"		# remove leading whitespace
					package_status_msg="${package_status_msg%* }"		# remove trailing whitespace
					package_status_msg="${package_status_msg// /, }"	# insert separators
				else
					package_status_msg="$package_status"
				fi

				package_status_msg="${CHARS_NORMAL}${package_status_msg}"
			else
				package_status_msg="$(ColourTextBrightOrange "${CHARS_NOTE}unknown")"
			fi

			package_version_msg=${CHARS_BLANK}$package_installed_version

			if [[ -n $package_upgrade_version && $package_installed_version != "$package_upgrade_version" ]]; then
				package_version_msg+=" ($(ColourTextBrightOrange "$package_upgrade_version"))"
				package_name_msg="${CHARS_BLANK}$(ColourTextBrightOrange "$package_name")"
			fi
			;;
		muted)
			package_name_msg="$(ColourTextDarkGrey "${CHARS_BLANK}$package_name")"
			package_version_msg="${CHARS_BLANK}$(ColourTextDarkGrey "$package_upgrade_version")"
			package_path_msg=''

			if [[ -n $package_status ]]; then
				if [[ $package_status =~ 'not installable' ]]; then
					package_status_msg="$(ColourTextDarkGrey "${CHARS_NORMAL}${package_status}")"
					package_version_msg=''
				else
					package_status_msg="$(ColourTextDarkGrey "${CHARS_NORMAL}${package_status}")"
				fi
			fi
			;;
		highlighted)
			patt=\\bmissing\\b

			if [[ $package_status =~ $patt ]]; then
				package_name_msg="${CHARS_BLANK}$(ColourTextBrightRed "$package_name")"
				package_status_msg="$(ColourTextBrightRedBlink "${CHARS_ALERT}${package_status}")"
				package_version_msg="${CHARS_BLANK}$(ColourTextBrightRedBlink "$package_installed_version")"
				package_path_msg="${CHARS_BLANK}$(ColourTextBrightRedBlink "$package_path")"
			else
				package_name_msg="${CHARS_BLANK}$(ColourTextBrightOrange "$package_name")"
				package_status_msg="$(ColourTextBrightOrange "${CHARS_NOTE}${package_status}")"
			fi
	esac

	# column 1: package name

	if [[ $maxcols -ge 1 && -n $package_name ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package statuses

	if [[ $maxcols -ge 2 && -n $package_status ]]; then
		printf "%-$((PACKAGE_STATUS_COL_WIDTH+$(LenANSIDiff "$package_status_msg")))s" "$package_status_msg"
	fi

	# column 3: package version

	if [[ $maxcols -ge 3 && -n $package_version_msg ]]; then
		printf "%-$((package_ver_final_col_width+$(LenANSIDiff "$package_version_msg")))s" "$package_version_msg"
	fi

	# column 4: package installation path

	if [[ $maxcols -ge 4 && -n $package_path_msg ]]; then
		printf "%-$((PACKAGE_PATH_COL_WIDTH+$(LenANSIDiff "$package_path_msg")))s" "$package_path_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpTitleNameDateRepo()
	{

	# input:
	#	$1 = package tier

	local package_name_msg=''
	local package_install_date_msg=''
	local package_repo_msg=''

	DisplayLineSpaceIfNoneAlready

	# column 1: package name

	if [[ $maxcols -ge 1 ]]; then
		package_name_msg="${CHARS_SPECIAL}$1 QPKGs:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package installation date

	if [[ $maxcols -ge 2 ]]; then
		package_install_date_msg="${CHARS_SPECIAL}install date:"
		printf "%-$((PACKAGE_INSTALL_DATE_COL_WIDTH+2+$(LenANSIDiff "$package_install_date_msg")))s" "$package_install_date_msg"
	fi

	# column 3: package repository

	if [[ $maxcols -ge 3 ]]; then
		package_repo_msg="${CHARS_SPECIAL}repository:"
		printf "%-$((PACKAGE_REPO_COL_WIDTH+2+$(LenANSIDiff "$package_repo_msg")))s" "$package_repo_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpNameDateRepo()
	{

	# input:
	#	$1 = 'normal/highlighted/muted'
	#	$2 = package name
	#	$3 = assigned repository
	#	$4 = package installation date

	local package_name=${2:-}
	local package_name_msg=${CHARS_BLANK}$package_name
	local assigned_repo=${3:-}
	local assigned_repo_msg="${CHARS_NORMAL}${assigned_repo}"
	local package_install_date=${4:-}
	local package_install_date_msg=${CHARS_BLANK}$package_install_date

	case $1 in
		normal)
			case $assigned_repo in
				sherpa)
					assigned_repo_msg="${CHARS_NORMAL}$(ColourTextBrightGreen "$assigned_repo")"
					;;
				unassigned)
					assigned_repo_msg="${CHARS_NORMAL}$(ColourTextBrightOrange "$assigned_repo")"
			esac
			;;
		muted)
			package_name_msg=${CHARS_BLANK}$(ColourTextDarkGrey "$package_name")
			package_install_date_msg="${CHARS_BLANK}$(ColourTextDarkGrey "$assigned_repo")"
			assigned_repo_msg=''
			;;
		highlighted)
			if [[ -n $assigned_repo ]]; then
				case $assigned_repo in
					missing)
						package_name_msg=${CHARS_BLANK}$(ColourTextBrightRed "$package_name")
						package_install_date_msg="${CHARS_BLANK}$(ColourTextBrightRedBlink "$assigned_repo")"
						assigned_repo_msg="$(ColourTextBrightRedBlink "${CHARS_ALERT}${assigned_repo}")"
						;;
					*)
						package_name_msg=${CHARS_BLANK}$(ColourTextBrightOrange "$package_name")
						assigned_repo_msg="$(ColourTextBrightOrange "${CHARS_NOTE}${assigned_repo}")"
				esac
			fi
	esac

	# column 1: package name

	if [[ $maxcols -ge 1 && -n $package_name_msg ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package installation date

	if [[ $maxcols -ge 2 && -n $package_install_date_msg ]]; then
		printf "%-$((PACKAGE_INSTALL_DATE_COL_WIDTH+$(LenANSIDiff "$package_install_date_msg")))s" "$package_install_date_msg"
	fi

	# column 3: package repository

	if [[ $maxcols -ge 3 && -n $assigned_repo_msg ]]; then
		printf "%-$((PACKAGE_REPO_COL_WIDTH+$(LenANSIDiff "$assigned_repo_msg")))s" "$assigned_repo_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpTitleNameAbs()
	{

	# input:
	#	$1 = package tier title

	local package_name_msg=''
	local package_abs_msg=''

	DisplayLineSpaceIfNoneAlready

	# column 1: package name

	if [[ $maxcols -ge 1 ]]; then
		package_name_msg="${CHARS_SPECIAL}$1 QPKGs:"
		printf "%-$((PACKAGE_NAME_COL_WIDTH+2+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package abbreviations

	if [[ $maxcols -ge 2 ]]; then
		package_abs_msg="${CHARS_SPECIAL}acceptable QPKG name abbreviations and aliases:"
		printf "%-$((PACKAGE_ABBS_COL_WIDTH+2+$(LenANSIDiff "$package_abs_msg")))s" "$package_abs_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpNameAbs()
	{

	# input:
	#	$1 = 'normal/highlighted/muted'
	#	$2 = package name
	#	$3 = acceptable package abbreviations

	local package_name=${2:-}
	local package_name_msg=${CHARS_BLANK}$package_name
	local package_abs=${3:-}
	local package_abs_msg="${CHARS_NORMAL}${package_abs}"

	case $1 in
		normal)
			case $package_abs in
				sherpa)
					package_abs_msg="${CHARS_NORMAL}$(ColourTextBrightGreen "$package_abs")"
					;;
				unassigned)
					package_abs_msg="${CHARS_NORMAL}$(ColourTextBrightOrange "$package_abs")"
			esac
			;;
		muted)
			package_name_msg="${CHARS_BLANK}$(ColourTextDarkGrey "$package_name")"
			package_abs_msg="$(ColourTextDarkGrey "${CHARS_NORMAL}${package_abs}")"
			;;
		highlighted)
			if [[ -n $package_abs ]]; then
				case $package_abs in
					missing)
						package_name_msg=$(ColourTextBrightRed "${CHARS_ALERT}${package_name}")
						package_abs_msg="$(ColourTextBrightRedBlink "${CHARS_ALERT}${package_abs}")"
						;;
					*)
						package_name_msg=${CHARS_NORMAL}$(ColourTextBrightOrange "$package_name")
						package_abs_msg="$(ColourTextBrightOrange "${CHARS_NOTE}${package_abs}")"
				esac
			fi
	esac

	# column 1: package name

	if [[ $maxcols -ge 1 && -n $package_name_msg ]]; then
		printf "%-$((PACKAGE_NAME_COL_WIDTH+$(LenANSIDiff "$package_name_msg")))s" "$package_name_msg"
	fi

	# column 2: package repository

	if [[ $maxcols -ge 2 && -n $package_abs_msg ]]; then
		printf "%-$((PACKAGE_ABBS_COL_WIDTH+$(LenANSIDiff "$package_abs_msg")))s" "$package_abs_msg"
	fi

	printf '\n'
	linespace_visible=false

	}

DisplayAsHelpTitleFileNamePlusSomething()
	{

	# input:
	#	$1 = file name title
	#	$2 = second column title

	DisplayLineSpaceIfNoneAlready

	printf "${CHARS_SPECIAL}%-${FILE_NAME_COL_WIDTH}s ${CHARS_SPECIAL}%s\n" "$(Capitalise "${1:-}"):" "$(Capitalise "${2:-}"):"
	linespace_visible=false

	}

DisplayAsHelpTitle()
	{

	# input:
	#	$1 = text

	DisplayLineSpaceIfNoneAlready

	printf "${CHARS_SPECIAL}%s\n" "$(Capitalise "${1:-}" | tr -s ' ')"
	linespace_visible=false

	}

DisplayAsHelpTitleHighlighted()
	{

	# input:
	#	$1 = text

	DisplayLineSpaceIfNoneAlready

	# shellcheck disable=2059
	printf "$(ColourTextBrightOrange "${CHARS_SPECIAL}%s\n")" "$(Capitalise "${1:-}")"
	linespace_visible=false

	}

DisplayAsActionResultNtLastLine()
	{

	# input:
	#	$1 = text

	printf "%${ACTION_RESULT_INDENT}s${CHARS_DROPTHRU}%s\n" '' "$1"
	linespace_visible=false

	}

DisplayAsActionResultLastLine()
	{

	# input:
	#	$1 = text

	printf "%${ACTION_RESULT_INDENT}s${CHARS_DROPEND}%s\n" '' "$1"
	linespace_visible=false

	}

DisplayAsIndentPrefixActionResultDurationReason()
	{

	# input:
	#	$1 = prefix message (optional)
	#	$2 = action
	#	$3 = result message
	#	$4 = duration in milliseconds (optional)
	#	$5 = reason message (optional)

	local duration=''

	[[ -n ${4:-} ]] && duration="$(FormatMillisecsToMinutesSecs "$4")"

	printf "%${ACTION_RESULT_INDENT}s" ''

	if [[ -z ${5:-} ]]; then
		printf "%s%s %s%s" "${1:-}" "$(Lowercase "${2:-}")" "${3:-}" "$([[ -n $duration ]] && printf ' in %s' "$duration")"
	else
		printf "%s%s %s%s\n%${ACTION_RESULT_INDENT}s${CHARS_DROPEND}%s" "${1:-}" "$(Lowercase "${2:-}")" "${3:-}" "$([[ -n $duration ]] && printf ' in %s' "$duration")" '' "$5"
	fi

	printf '\n'
	linespace_visible=false

	}

EraseThisLine()
	{

	# reset cursor to start-of-line, erasing entire line

	[[ ${opts_verbose:-false} = true ]] && return

	printf '\033[2K\r'

	} >&2

Display()
	{

	echo -e "${1:-}"
	linespace_visible=false

	}

DisplayWait()
	{

	printf '%s' "${1:-}"

	}

Help.Actions:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle "$(FormatAsAction) usage examples:"
	DisplayAsProjSynIndentExam 'show package statuses' status
	DisplayAsProjSynIndentExam '' s
	DisplayAsProjSynIndentExam 'show current package repository assignments' repos
	DisplayAsProjSynIndentExam '' r
	DisplayAsProjSynIndentExam 'ensure all application dependencies are installed' check
	DisplayAsProjSynIndentExam '' c
	DisplayAsProjSynIndentExam 'install these packages' "install $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'uninstall these packages' "uninstall $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'reinstall these packages' "reinstall $(FormatAsPackages)"
	DisplayAsProjSynIndentExam "rebuild these packages ('install' packages, then 'restore' configuration backups)" "rebuild $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'upgrade these packages (this will upgrade internal applications where-supported)' "upgrade $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'enable these packages' "enable $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'disable these packages (disabling will prevent them activating on reboot)' "disable $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'enable, then activate these packages (this will upgrade internal applications where-supported)' "activate $(FormatAsPackages)"
	DisplayAsProjSynIndentExam '' "start $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'deactivate these packages' "deactivate $(FormatAsPackages)"
	DisplayAsProjSynIndentExam '' "stop $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'reactivate these packages (this will upgrade internal applications where-supported)' "reactivate $(FormatAsPackages)"
	DisplayAsProjSynIndentExam '' "restart $(FormatAsPackages)"
	Help.Action.Reassign:Show
	DisplayAsProjSynIndentExam 'clear local repository files from these packages' "clean $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'backup these application configurations to the backup location' "backup $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'restore these application configurations from the backup location' "restore $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'show application backup files' 'list backups'
	DisplayAsProjSynIndentExam '' b
	DisplayAsProjSynIndentExam "list $(FormatAsTitle) object version numbers" 'list versions'
	DisplayAsProjSynIndentExam '' v
	DisplayAsProjSynExam "$(FormatAsAction)s to affect all packages can be seen with" 'all-actions'
	DisplayAsProjSynExam "multiple $(FormatAsAction)s are supported like this" "$(FormatAsAction) $(FormatAsPackages) $(FormatAsAction) $(FormatAsPackages)"
	DisplayAsProjSynIndentExam '' 'install sabnzbd sickgear reactivate transmission uninstall lazy nzbget upgrade nzbtomedia'

	return 0

	}

Help.Action.Reassign:Show()
	{

	DisplayAsProjSynIndentExam "reassign packages to $(FormatAsTitle). Use this action to detach QPKGs previously installed via an online respository from further management by that repository" "reassign $(FormatAsPackages)"

	}

Help.ActionsAll:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle "the 'all' group applies to all installed packages. If $(FormatAsAction) is 'install all' then all available packages will be installed."
	DisplayAsHelpTitle "$(FormatAsAction) $(FormatAsGroup) usage examples:"
	DisplayAsProjSynIndentExam 'install everything!' 'install all'
	DisplayAsProjSynIndentExam 'uninstall everything!' 'force uninstall all'
	DisplayAsProjSynIndentExam 'reinstall all installed packages' 'reinstall all'
	DisplayAsProjSynIndentExam "rebuild all packages with backups ('install' packages and 'restore' backups)" 'rebuild all'
	DisplayAsProjSynIndentExam 'upgrade all installed packages (and internal applications where-supported)' 'upgrade all'
	DisplayAsProjSynIndentExam 'enable all installed packages (allow them to activate on reboot)' 'enable all'
	DisplayAsProjSynIndentExam 'disable all installed packages (prevent them activating on reboot)' 'disable all'
	DisplayAsProjSynIndentExam 'enable, then activate all installed packages (this will upgrade internal applications where-supported)' 'activate all'
	DisplayAsProjSynIndentExam '' 'start all'
	DisplayAsProjSynIndentExam 'deactivate all installed packages' 'deactivate all'
	DisplayAsProjSynIndentExam '' 'stop all'
	DisplayAsProjSynIndentExam 'reactivate packages (this will upgrade internal applications where-supported)' 'reactivate all'
	DisplayAsProjSynIndentExam '' 'restart all'
	DisplayAsProjSynIndentExam 'clear local repository files from all packages' 'clean all'
	DisplayAsProjSynIndentExam 'list all available packages' 'list all'
	DisplayAsProjSynIndentExam 'list only installed packages' 'list installed'
	DisplayAsProjSynIndentExam '' installed
	DisplayAsProjSynIndentExam 'list only packages that can be installed' 'list installable'
	DisplayAsProjSynIndentExam '' installable
	DisplayAsProjSynIndentExam 'list only packages that are not installed' 'list not-installed'
	DisplayAsProjSynIndentExam '' not-installed
	DisplayAsProjSynIndentExam 'list only upgradable packages' 'list upgradable'
	DisplayAsProjSynIndentExam '' upgradable
	DisplayAsProjSynIndentExam 'backup all application configurations to the backup location' 'backup all'
	DisplayAsProjSynIndentExam 'restore all application configurations from the backup location' 'restore all'

	return 0

	}

Help.BackupLocation:Show()
	{

	DisplayAsSynExam 'the backup location can be accessed by running' "cd $QPKG_BU_PATH"

	return 0

	}

Help.Basic:Show()
	{

	DisplayAsHelpTitle "Usage: sherpa $(FormatAsAction) $(FormatAsPackages) $(FormatAsGroup) $(FormatAsOptions)"

	return 0

	}

Help.Basic.Example:Show()
	{

	DisplayAsProjSynIndentExam "to list available $(FormatAsAction)s" 'list actions'
	DisplayAsProjSynIndentExam "to list available $(FormatAsPackages)" 'list packages'
	DisplayAsProjSynIndentExam '' p
	DisplayAsProjSynIndentExam "to list available $(FormatAsGroup)s" 'list groups'
	DisplayAsProjSynIndentExam "or, for more $(FormatAsOptions)" 'list options'
	DisplayAsHelpTitle "More in the wiki: $(FormatAsURL "https://github.com/OneCDOnly/sherpa/wiki")"

	return 0

	}

Help.Groups:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle "$(FormatAsGroup) usage examples:"
	DisplayAsProjSynIndentExam 'select every package' "$(FormatAsAction) all"
	DisplayAsProjSynIndentExam 'select only standalone packages (these do not depend on other QPKGs)' "$(FormatAsAction) standalone"
	DisplayAsProjSynIndentExam 'select only dependent packages (these require another QPKG to be installed and active)' "$(FormatAsAction) dependent"
	DisplayAsProjSynIndentExam '' "$(FormatAsAction) deps"
	DisplayAsProjSynIndentExam 'select only active packages' "$(FormatAsAction) active"
	DisplayAsProjSynIndentExam '' "$(FormatAsAction) started"
	DisplayAsProjSynIndentExam 'select only inactive packages' "$(FormatAsAction) inactive"
	DisplayAsProjSynIndentExam '' "$(FormatAsAction) stopped"
	DisplayAsProjSynIndentExam 'select only installed packages' "$(FormatAsAction) installed"
	DisplayAsProjSynIndentExam 'select only packages that are not installed' "$(FormatAsAction) not-installed"
	DisplayAsProjSynIndentExam 'select only packages that are backed-up' "$(FormatAsAction) backedup"
	DisplayAsProjSynIndentExam 'select only packages that are not backed-up' "$(FormatAsAction) not-backedup"
	DisplayAsProjSynIndentExam 'select only packages that are upgradable' "$(FormatAsAction) upgradable"
	DisplayAsProjSynIndentExam 'select only missing packages (these are partly installed and broken)' "$(FormatAsAction) missing"
	DisplayAsProjSynExam 'multiple groups are supported like this' "$(FormatAsAction) $(FormatAsGroup) $(FormatAsGroup)"

	return 0

	}

Help.Issue:Show()
	{

	DisplayAsHelpTitle "please consider creating a new issue for this on GitHub:\n\thttps://github.com/OneCDOnly/sherpa/issues"
	DisplayAsHelpTitle "alternatively, post on the QNAP NAS Community Forum:\n\thttps://forum.qnap.com/viewtopic.php?f=320&t=132373"
	DisplayAsProjSynIndentExam "view only the most recent $(FormatAsTitle) session log" last
	DisplayAsProjSynIndentExam "view the entire $(FormatAsTitle) session log" log
	DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(FormatAsTitle) log to the $(FormatAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
	DisplayAsHelpTitleHighlighted "If you need help, please include a copy of your $(FormatAsTitle) $(ColourTextBrightOrange "log for analysis!")"

	return 0

	}

Actions.Results:Show()
	{

	# input:
	#	$1 = `ok`, `skipped`, `failed`

	local -i datetime=0
	local action=''
	local package_name=''
	local result=''
	local -i duration=0
	local reason=''
	local package_type=''
	local found=false

	ShowAsProc 'writing report'

		{

		if [[ -e $SESS_ACTIONS_RESULTS_PATHFILE ]]; then
			local IFS='|'

			while read -r datetime action package_name result duration reason package_type; do
				if [[ $display_last_action_datetime = true ]]; then
					DisplayAsHelpTitle "the following package actions were run: $(/bin/date -d @"$datetime")"
					display_last_action_datetime=false
				fi

				if [[ $result = "$1" ]] || [[ $1 = skipped && $result = 'skipped-error' ]]; then
					case $result in
						ok)
							[[ $found = false ]] && DisplayAsHelpTitle "these package actions completed $(ColourTextBrightGreen OK):"
							;;
						skipped|skipped-ok|skipped-error)
							[[ $found = false ]] && DisplayAsHelpTitle "these package actions were $(ColourTextBrightOrange skipped):"
							;;
						failed)
							[[ $found = false ]] && DisplayAsHelpTitle "these package actions $(ColourTextBrightRed failed):"
					esac

					ShowAsActionLogDetail "$datetime" "$package_name" "$action" "$result" "$duration" "$reason"
					found=true
				fi
			done < "$SESS_ACTIONS_RESULTS_PATHFILE"
		fi

		if [[ $found = false ]]; then
			case $1 in
				ok)
					DisplayAsHelpTitle "No package actions completed $(ColourTextBrightGreen OK)."
					;;
				skipped)
					DisplayAsHelpTitle "No package actions were $(ColourTextBrightOrange skipped)."
					;;
				failed)
					DisplayAsHelpTitle "No package actions $(ColourTextBrightRed failed)."
			esac
		fi

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"

	return 0

	}

Help.Options:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle "$(FormatAsOptions) usage examples:"
	DisplayAsProjSynIndentExam 'show package statuses' status
	DisplayAsProjSynIndentExam '' s
	DisplayAsProjSynIndentExam 'show package repositories' repos
	DisplayAsProjSynIndentExam '' r
	DisplayAsProjSynIndentExam 'show live debugging information, and record it to file' "$(FormatAsAction) $(FormatAsPackages) verbose"
	DisplayAsProjSynIndentExam 'record debugging information to file-only' "$(FormatAsAction) $(FormatAsPackages) debug"

	return 0

	}

Help.Problems:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle 'usage examples for dealing with problems:'
	DisplayAsProjSynIndentExam 'show package statuses' status
	DisplayAsProjSynIndentExam '' s
	DisplayAsProjSynIndentExam 'show live debugging information, and record it to file' "$(FormatAsAction) $(FormatAsPackages) verbose"
	DisplayAsProjSynIndentExam 'record debugging information to file-only' "$(FormatAsAction) $(FormatAsPackages) debug"
	DisplayAsProjSynIndentExam 'ensure all dependencies exist for installed packages' check
	DisplayAsProjSynIndentExam '' c
	DisplayAsProjSynIndentExam 'clear local repository files from these packages' "clean $(FormatAsPackages)"
	DisplayAsProjSynIndentExam "remove all cached $(FormatAsTitle) items and logs" reset
	DisplayAsProjSynIndentExam 'reactivate all installed packages (upgrades internal applications where-supported)' 'reactivate all'
	DisplayAsProjSynIndentExam 'enable then activate these packages' "activate $(FormatAsPackages)"
	DisplayAsProjSynIndentExam 'stop then disable these packages (disabling will prevent them starting on reboot)' "stop $(FormatAsPackages)"
	DisplayAsProjSynIndentExam "view only the most recent $(FormatAsTitle) session log" last
	DisplayAsProjSynIndentExam '' l
	DisplayAsProjSynIndentExam "view the entire $(FormatAsTitle) session log" log
	DisplayAsProjSynIndentExam "increase the default $(GetQnapOS) QPKG timeout for all packages to $((QPKG_EXTENDED_TIMEOUT_SECONDS/60)) minutes" 'increase-timeout'
	DisplayAsProjSynIndentExam "revert the default $(GetQnapOS) QPKG timeout for all packages to 3 minutes" 'revert-timeout'
	DisplayAsProjSynIndentExam "upload the most-recent session in your $(FormatAsTitle) log to the $(FormatAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste last'
	DisplayAsProjSynIndentExam "upload the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(FormatAsTitle) log to the $(FormatAsURL 'https://termbin.com') public pastebin. A URL will be generated afterward" 'paste log'
	DisplayAsHelpTitleHighlighted "If you need help, please include a copy of your $(FormatAsTitle) $(ColourTextBrightOrange "log for analysis!")"

	return 0

	}

Help.Tips:Show()
	{

	DisableDebugToArchiveAndFile
	Help.Basic:Show
	DisplayAsHelpTitle 'helpful tips and shortcuts:'
	DisplayAsProjSynIndentExam "install all available $(FormatAsTitle) packages" 'install all'
	DisplayAsProjSynIndentExam 'package abbreviations and aliases also work. To see these' 'list abs'
	DisplayAsProjSynIndentExam '' a
	DisplayAsProjSynIndentExam 'reactivate all installed packages (upgrades internal applications where-supported)' 'reactivate all'
	DisplayAsProjSynIndentExam 'list only packages that can be installed' 'list installable'
	DisplayAsProjSynIndentExam "view only the most recent $(FormatAsTitle) session log" last
	DisplayAsProjSynIndentExam '' l
	DisplayAsProjSynIndentExam 'activate all inactive packages' 'activate inactive'
	DisplayAsProjSynIndentExam 'upgrade the internal applications only' "reactivate $(FormatAsPackages)"
	Help.BackupLocation:Show

	return 0

	}

Log.Last:View()
	{

	# view only the last session log

	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail

	if [[ -e $SESS_LAST_PATHFILE ]]; then
		if [[ -e $GNU_LESS_CMD ]]; then
			LESSseCURE=1 $GNU_LESS_CMD +G --quit-on-intr --tilde --LINE-NUMBERS --prompt ' use arrow-keys to scroll up-down left-right, press Q to quit' "$SESS_LAST_PATHFILE"
		elif [[ -e $LESS_CMD ]]; then
			$LESS_CMD -N~ "$SESS_LAST_PATHFILE"
		else
			$CAT_CMD --number "$SESS_LAST_PATHFILE"
		fi
	else
		ShowAsError 'no last session log to display'
	fi

	return 0

	}

Log.Tail:View()
	{

	# view only the last session log

	DisableDebugToArchiveAndFile
	ExtractTailFromLog

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		if [[ -e $GNU_LESS_CMD ]]; then
			LESSseCURE=1 $GNU_LESS_CMD +G --quit-on-intr --tilde --LINE-NUMBERS --prompt ' use arrow-keys to scroll up-down left-right, press Q to quit' "$SESS_TAIL_PATHFILE"
		elif [[ -e $LESS_CMD ]]; then
			$LESS_CMD -N~ "$SESS_TAIL_PATHFILE"
		else
			$CAT_CMD --number "$SESS_TAIL_PATHFILE"
		fi
	else
		ShowAsError 'no session log tail to display'
	fi

	return 0

	}

Log.Last:Paste()
	{

	local link=''
	DisableDebugToArchiveAndFile
	ExtractPrevSessFromTail

	if [[ -e $SESS_LAST_PATHFILE ]]; then
		if Quiz "Press 'Y' to post the most-recent session in your $(FormatAsTitle) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "uploading $(FormatAsTitle) log"
			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$SESS_LAST_PATHFILE" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(FormatAsTitle) log is now online at $(FormatAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(FormatAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_zero_qpkgs=false
			return 1
		fi
	else
		ShowAsError 'no last session log found'
	fi

	return 0

	}

Log.Tail:Paste()
	{

	local link=''
	DisableDebugToArchiveAndFile
	ExtractTailFromLog

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		if Quiz "Press 'Y' to post the most-recent $(FormatAsThous "$LOG_TAIL_LINES") lines in your $(FormatAsTitle) log to a public pastebin, or any other key to abort"; then
			ShowAsProc "uploading $(FormatAsTitle) log"
			# with thanks to https://github.com/solusipse/fiche
			link=$($CAT_CMD --number "$SESS_TAIL_PATHFILE" | (exec 3<>/dev/tcp/termbin.com/9999; $CAT_CMD >&3; $CAT_CMD <&3; exec 3<&-))

			if [[ $? -eq 0 ]]; then
				ShowAsDone "your $(FormatAsTitle) log is now online at $(FormatAsURL "$link") and will be deleted in 1 month"
			else
				ShowAsFail "a link could not be generated. Most likely a problem occurred when talking with $(FormatAsURL 'https://termbin.com')"
			fi
		else
			DebugInfoMinSepr
			DebugScript 'user abort'
			show_zero_qpkgs=false
			return 1
		fi
	else
		ShowAsError 'no session log tail found'
	fi

	return 0

	}

GetLogSessStartLine()
	{

	# input:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*started:' "$SESS_TAIL_PATHFILE" | $TAIL_CMD -n${1:-1} | $HEAD_CMD -n1 | cut -d':' -f1)-1))
	[[ $linenum -lt 1 ]] && linenum=1
	echo $linenum

	}

GetLogSessFinishLine()
	{

	# input:
	#	$1 = how many sessions back? (optional) default = 1

	local -i linenum=$(($($GREP_CMD -n 'SCRIPT:.*finished:' "$SESS_TAIL_PATHFILE" | $TAIL_CMD -n${1:-1} | cut -d':' -f1)+2))
	[[ $linenum -eq 2 ]] && linenum=3
	echo $linenum

	}

ArchiveActiveSessLog()
	{

	[[ -n ${sess_active_pathfile:-} && -e $sess_active_pathfile ]] && $CAT_CMD "$sess_active_pathfile" >> "$SESS_ARCHIVE_PATHFILE"

	}

ArchivePriorSessLogs()
	{

	# check for incomplete previous session logs (crashed, interrupted?) and save to archive

	local log_pathfile=''

	for log_pathfile in "$THIS_PACKAGE_PATH/session."*".active.log"; do
		if [[ -f $log_pathfile && $log_pathfile != "$sess_active_pathfile" ]]; then
			$CAT_CMD "$log_pathfile" >> "$SESS_ARCHIVE_PATHFILE"
			rm -f "$log_pathfile"
		fi
	done

	}

ResetActiveSessLog()
	{

	rm -f "$sess_active_pathfile"

	}

ExtractPrevSessFromTail()
	{

	local -i start_line=0
	local -i end_line=0
	local -i old_session=1

	# don't try to find "started:" further back than this many sessions
	local -i old_session_limit=12

	ExtractTailFromLog

	if [[ -e $SESS_TAIL_PATHFILE ]]; then
		end_line=$(GetLogSessFinishLine "$old_session")
		start_line=$((end_line+1))	# ensure an invalid condition, to be solved by the loop

		while [[ $start_line -ge $end_line ]]; do
			start_line=$(GetLogSessStartLine "$old_session")

			((old_session++))
			[[ $old_session -gt $old_session_limit ]] && break
		done

		$SED_CMD "$start_line,$end_line!d" "$SESS_TAIL_PATHFILE" > "$SESS_LAST_PATHFILE"
	else
		rm -f "$SESS_LAST_PATHFILE"
	fi

	return 0

	}

ExtractTailFromLog()
	{

	if [[ -e $SESS_ARCHIVE_PATHFILE ]]; then
		$TAIL_CMD -n${LOG_TAIL_LINES} "$SESS_ARCHIVE_PATHFILE" > "$SESS_TAIL_PATHFILE"	# trim main log first so there's less to `grep`
	else
		rm -f "$SESS_TAIL_PATHFILE"
	fi

	return 0

	}

Self.Vers:Show()
	{

	DisableDebugToArchiveAndFile

	Display "QPKG: ${THIS_PACKAGE_VER:-unknown}"
	Display "manager: ${THIS_SCRIPT_VER:-unknown}"
	Display "loader: ${LOADER_SCRIPT_VER:-unknown}"
	Display "objects: ${OBJECTS_VER:-unknown}"
	Display "packages: ${PACKAGES_VER:-unknown}"

	return 0

	}

InitForkCounts()
	{

	# create directories so background processes can be monitored

	PROC_COUNTS_PATH=$($MKTEMP_CMD -d /var/run/"${FUNCNAME[1]}"_XXXXXX)
	[[ -n ${PROC_COUNTS_PATH:?undefined proc counts path} ]] || return

	EraseForkCountPaths

	proc_fork_count_path=${PROC_COUNTS_PATH}/fork.count
	proc_ok_count_path=${PROC_COUNTS_PATH}/ok.count
	proc_skip_ok_count_path=${PROC_COUNTS_PATH}/skip.ok.count
	proc_skip_count_path=${PROC_COUNTS_PATH}/skip.count
	proc_skip_error_count_path=${PROC_COUNTS_PATH}/skip.error.count
	proc_fail_count_path=${PROC_COUNTS_PATH}/fail.count

	mkdir -p "$proc_fork_count_path"
	mkdir -p "$proc_ok_count_path"
	mkdir -p "$proc_skip_ok_count_path"
	mkdir -p "$proc_skip_count_path"
	mkdir -p "$proc_skip_error_count_path"
	mkdir -p "$proc_fail_count_path"

	InitProgress

	}

IncForkProgressIndex()
	{

	((progress_index++))
	local formatted_index="$(printf '%02d' "$progress_index")"

	proc_fork_pathfile="$proc_fork_count_path/$formatted_index"
	proc_ok_pathfile="$proc_ok_count_path/$formatted_index"
	proc_skipok_pathfile="$proc_skip_ok_count_path/$formatted_index"
	proc_skip_pathfile="$proc_skip_count_path/$formatted_index"
	proc_skip_error_pathfile="$proc_skip_error_count_path/$formatted_index"
	proc_fail_pathfile="$proc_fail_count_path/$formatted_index"

	}

RefreshForkCounts()
	{

	fork_count="$(ls -A -1 "$proc_fork_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"
	ok_count="$(ls -A -1 "$proc_ok_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"
	skip_ok_count="$(ls -A -1 "$proc_skip_ok_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"
	skip_count="$(ls -A -1 "$proc_skip_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"
	skip_error_count="$(ls -A -1 "$proc_skip_error_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"
	fail_count="$(ls -A -1 "$proc_fail_count_path" | $WC_CMD -l | $SED_CMD 's|^ *||' 2>/dev/null)"

	}

EraseForkCountPaths()
	{

	[[ -d ${PROC_COUNTS_PATH:?undefined proc counts path} ]] && rm -r "$PROC_COUNTS_PATH" &>/dev/null

	}

InitProgress()
	{

	progress_index=0
	prev_clean_msg=''

	RefreshForkCounts

	}

UpdateForkProgress()
	{

	# all input vars are global

	local msg=': '

	RefreshForkCounts
	[[ $opts_verbose = true ]] && return		# don't display progress, it's impossible to view it with so-many other writes to the screen
	[[ ! -e $DISPLAY_INHBIT_PATHFILE ]] || return

	msg+="$(PercFrac "$ok_count" "$((skip_count+skip_ok_count+skip_error_count))" "$fail_count" "$total_count")"

	if [[ $ok_count -gt 0 ]]; then
		[[ -n $msg ]] && msg+=': '
		msg+="$(ColourTextBrightGreen "$ok_count") OK"
	fi

	if [[ $skip_count -gt 0 || $skip_error_count -gt 0 ]]; then		# don't include skipped packages that were OK
		[[ -n $msg ]] && msg+=': '
		msg+="$(ColourTextBrightOrange "$((skip_count+skip_error_count))") skipped"
	fi

	if [[ $fail_count -gt 0 ]]; then
		[[ -n $msg ]] && msg+=': '
		msg+="$(ColourTextBrightRed "$fail_count") failed"
	fi

	if [[ $fork_count -gt 0 ]]; then
		[[ -n $msg ]] && msg+=': '
		msg+="$(ColourTextBrightYellow "$fork_count") in-progress"
	fi

	[[ -n $msg ]] && WriteMsgInPlace "$msg"

	return 0

	}

QPKGs.Missing:Show()
	{

	local package=''

	[[ $hide_title = false ]] || return
	QPKGs.States:Build

	[[ $(QPKGs-ISmissing:Count) -eq 0 ]] && return 1

	EraseThisLine
	DisplayLineSpaceIfNoneAlready

	for package in $(QPKGs-ISmissing:Array); do
		ShowAsFail "the $(ColourTextBrightOrange "$package") QPKG is missing or broken. Please reinstall it."
	done

	return 0

	}

QPKGs.NewVers:Show()
	{

	# Check installed QPKGs and compare versions against upgradable array. If new versions are available, advise on-screen.

	# output:
	#	$? = 0 if all packages are up-to-date
	#	$? = 1 if one-or-more packages can be upgraded

	local -a upgradable_packages=()
	local -i index=0
	local names_formatted=''
	local msg=''

	[[ $hide_title = false ]] || return
	QPKGs.States:Build

	if [[ $(QPKGs-SCupgradable:Count) -eq 0 ]]; then
		return 0
	else
		upgradable_packages+=($(QPKGs-SCupgradable:Array))
	fi

	for ((index=0; index<=((${#upgradable_packages[@]}-1)); index++)); do
		names_formatted+=$(ColourTextBrightOrange "${upgradable_packages[$index]}")

		if [[ $((index+2)) -lt ${#upgradable_packages[@]} ]]; then
			names_formatted+=', '
		elif [[ $((index+2)) -eq ${#upgradable_packages[@]} ]]; then
			names_formatted+=' & '
		fi
	done

	if [[ ${#upgradable_packages[@]} -eq 1 ]]; then
		msg='a new QPKG is'
	else
		msg='new QPKGs are'
	fi

	ShowAsInfo "$msg available for $names_formatted"
	return 1

	}

QPKGs.Conflicts:Check()
	{

	local package=''

	if [[ -n ${BASE_QPKG_CONFLICTS_WITH:-} ]]; then
		# shellcheck disable=2068
		for package in "${BASE_QPKG_CONFLICTS_WITH[@]}"; do
			if QPKG.IsEnabled "$package"; then
				ShowAsError "the '$package' QPKG is enabled. $(FormatAsTitle) is incompatible with this package. Please consider 'stop'ing this QPKG in your App Center"
				return 1
			fi
		done
	fi

	return 0

	}

QPKGs.Warnings:Check()
	{

	local package=''

	if [[ -n ${BASE_QPKG_WARNINGS:-} ]]; then
		# shellcheck disable=2068
		for package in "${BASE_QPKG_WARNINGS[@]}"; do
			if QPKG.IsEnabled "$package"; then
				ShowAsWarn "the '$package' QPKG is enabled. This may cause problems with $(FormatAsTitle) applications. Please consider 'stop'ing this QPKG in your App Center"
			fi
		done
	fi

	return 0

	}

PIPs.Actions:List()
	{

	[[ $opts_debug = true ]] || return

	Func:Entry
	local action=''
	DebugInfoMinSepr

	for action in "${PIP_ACTIONS[@]}"; do
		PIPs-AC${action}-ok:IsAny && DebugPipInfo "AC${action}-ok" "($(PIPs-AC${action}-ok:Count)) $(PIPs-AC${action}-ok:ListCSV) "
		PIPs-AC${action}-er:IsAny && DebugPipError "AC${action}-er" "($(PIPs-AC${action}-er:Count)) $(PIPs-AC${action}-er:ListCSV) "
	done

	DebugInfoMinSepr
	Func:Exit

	}

IPKs.Actions:List()
	{

	[[ $opts_debug = true ]] || return

	Func:Entry
	local action=''
	local border_shown=false

	for action in "${IPK_ACTIONS[@]}"; do
		if IPKs-AC${action}-ok:IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk info "AC${action}-ok" "($(IPKs-AC${action}-ok:Count)) $(IPKs-AC${action}-ok:ListCSV) "
		fi

		if IPKs-AC${action}-er:IsAny; then
			if [[ $border_shown = false ]]; then
				DebugInfoMinSepr
				border_shown=true
			fi
			DebugIpk error "AC${action}-er" "($(IPKs-AC${action}-er:Count)) $(IPKs-AC${action}-er:ListCSV) "
		fi
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr
	Func:Exit

	}

QPKGs.Actions:List()
	{

	[[ $opts_debug = true ]] || return

	Func:Entry
	local action=''
	local prefix=''
	local border_shown=false

	for action in "${QPKG_ACTIONS[@]}"; do
		for prefix in ok er sk; do
			if QPKGs-AC${action}-${prefix}:IsAny; then
				if [[ $border_shown = false ]]; then
					DebugInfoMinSepr
					border_shown=true
				fi

				case $prefix in
					ok)
						DebugQpkg info "AC${action}-${prefix}" "($(QPKGs-AC${action}-${prefix}:Count)) $(QPKGs-AC${action}-${prefix}:ListCSV) "
						;;
					sk)
						DebugQpkg warning "AC${action}-${prefix}" "($(QPKGs-AC${action}-${prefix}:Count)) $(QPKGs-AC${action}-${prefix}:ListCSV) "
						;;
					er)
						DebugQpkg error "AC${action}-${prefix}" "($(QPKGs-AC${action}-${prefix}:Count)) $(QPKGs-AC${action}-${prefix}:ListCSV) "
				esac
			fi
		done
	done

	[[ $border_shown = true ]] && DebugInfoMinSepr
	Func:Exit

	}

QPKGs.Actions:ListAll()
	{

	# only used when debugging

	Func:Entry
	local action=''
	local prefix=''
	DebugInfoMinSepr

	for action in "${QPKG_ACTIONS[@]}"; do
		[[ $action = enable || $action = disable ]] && continue  # no objects for these as `activate` and `stop` do the same jobs

		for prefix in to ok er sk; do
			if QPKGs-AC${action}-${prefix}:IsAny; then
				DebugQpkg info "AC${action}=${prefix}" "($(QPKGs-AC${action}-${prefix}:Count)) $(QPKGs-AC${action}-${prefix}:ListCSV) "
			fi
		done
	done

	DebugInfoMinSepr
	Func:Exit

	}

QPKGs.States:List()
	{

	# input:
	#	$1 (optional passthrough) = `rebuild` - clear existing lists and rebuild them from scratch

	[[ $opts_debug = true ]] || return

	Func:Entry
	local state=''
	local prefix=''

	QPKGs.States:Build "${1:-}"
	DebugInfoMinSepr

	for state in "${QPKG_IS_STATES[@]}" "${QPKG_SERVICE_RESULTS[@]}"; do
		if [[ $state = installed ]]; then
			continue
		elif [[ $state = unknown ]]; then
			QPKGs-IS${state}:IsAny && DebugQpkg warning "IS${state}" "($(QPKGs-IS${state}:Count)) $(QPKGs-IS${state}:ListCSV) "
		else
			QPKGs-IS${state}:IsAny && DebugQpkg info "IS${state}" "($(QPKGs-IS${state}:Count)) $(QPKGs-IS${state}:ListCSV) "
		fi
	done

	for state in "${QPKG_ISNT_STATES[@]}" "${QPKG_SERVICE_RESULTS[@]}"; do
		if [[ $state = installed ]]; then
			continue
		elif [[ $state = ok ]]; then
			QPKGs-ISNT${state}:IsAny && DebugQpkg error "ISNT${state}" "($(QPKGs-ISNT${state}:Count)) $(QPKGs-ISNT${state}:ListCSV) "
		elif [[ $state = backedup ]]; then
			QPKGs-ISNT${state}:IsAny && DebugQpkg warning "ISNT${state}" "($(QPKGs-ISNT${state}:Count)) $(QPKGs-ISNT${state}:ListCSV) "
		else
			QPKGs-ISNT${state}:IsAny && DebugQpkg info "ISNT${state}" "($(QPKGs-ISNT${state}:Count)) $(QPKGs-ISNT${state}:ListCSV) "
		fi
	done

	for state in "${QPKG_STATES_TRANSIENT[@]}"; do
		# shellcheck disable=2043
		QPKGs-IS${state}:IsAny && DebugQpkg info "IS${state}" "($(QPKGs-IS${state}:Count)) $(QPKGs-IS${state}:ListCSV) "
	done

	DebugInfoMinSepr
	Func:Exit

	}

QPKGs.StandaloneDependent:Build()
	{

	# There are three tiers of package: `standalone`, `addon` and `dependent`
	# ... but only two tiers of QPKG: `standalone` and `dependent`

	# `standalone` QPKGs don't depend-on other QPKGs, but may be required for other QPKGs. They should be installed/activated before any `dependent` QPKGs.
	# `dependent` QPKGs depend-on other QPKGs. They should be installed/activated after all `standalone` QPKGs.

	local package=''

	for package in "${QPKG_NAME[@]}"; do
		if QPKG.IsDependent "$package"; then
			QPKGs-SCdependent:Add "$package"
		else
			QPKGs-SCstandalone:Add "$package"
		fi
	done

	return 0

	}

QPKGs.States:Build()
	{

	# Builds several lists of QPKGs:
	#   - can be installed or reinstalled by the user
	#   - are installed or not
	#   - can be upgraded
	#   - are enabled or disabled in [/etc/config/qpkg.conf]
	#   - are active or inactive
	#   - have backup files in backup location
	#   - have config blocks in [/etc/config/qpkg.conf], but no files on-disk
	#   - those in the process of starting, stopping, or restarting

	# input:
	#	$1 (optional) = `rebuild` - clear existing lists and rebuild them from scratch

	local state=''

	if [[ ${1:-} = rebuild ]]; then
		DebugAsProc 'clearing existing state lists'

		for state in "${USER_QPKG_IS_STATES[@]}" "${QPKG_STATES_TRANSIENT[@]}"; do
			QPKGs-IS${state}:Init
		done

		for state in "${USER_QPKG_ISNT_STATES[@]}"; do
			QPKGs-ISNT${state}:Init
		done

		DebugAsDone 'cleared existing state lists'
		qpkgs_states_built=false
	fi

	[[ ${qpkgs_states_built:=false} = true ]] && return

	Func:Entry
	local -i index=0
	local package=''
	local prev=''
	OS.IsStarting && ShowAsWarn "$(GetQnapOS) is starting-up. QPKG statuses are in-flux. Try checking again in a few minutes"
	OS.IsStopping && ShowAsWarn "$(GetQnapOS) is shutting-down. All QPKGs are in the process of being stopped"
	ShowAsProc 'package states'

	for index in "${!QPKG_NAME[@]}"; do
		package="${QPKG_NAME[$index]}"
		[[ $package = "$prev" ]] && continue || prev=$package

		if QPKG.IsInstalled "$package"; then
			QPKGs-ISinstalled:Add "$package"

			if [[ ! -d $(QPKG.InstallationPath "$package") ]]; then
				QPKGs-ISmissing:Add "$package"
			fi

			if [[ $(QPKG.Local.Ver "$package") != "${QPKG_VERSION[$index]}" ]]; then
				QPKGs-SCupgradable:Add "$package"
			else
				QPKGs-SCNTupgradable:Add "$package"
			fi

			if QPKG.IsEnabled "$package"; then
				QPKGs-ISenabled:Add "$package"
			else
				QPKGs-ISNTenabled:Add "$package"
			fi

			if [[ -e /var/run/$package.last.operation ]]; then
				case $(</var/run/$package.last.operation) in
					starting)
						QPKGs-ISstarting:Add "$package"
						;;
					restarting)
						QPKGs-ISrestarting:Add "$package"
						;;
					stopping)
						QPKGs-ISstopping:Add "$package"
						;;
					failed)
						QPKGs-ISNTok:Add "$package"
						;;
					ok)
						QPKGs-ISok:Add "$package"
				esac
			fi
		else
			QPKGs-ISNTinstalled:Add "$package"

			if [[ -n ${QPKG_ABBRVS[$index]} ]] && [[ ${QPKG_ARCH[$index]} = all || ${QPKG_ARCH[$index]} = "$NAS_QPKG_ARCH" ]]; then
				if [[ ${QPKG_MIN_RAM_KB[$index]} = none || $NAS_RAM_KB -ge ${QPKG_MIN_RAM_KB[$index]} ]]; then
					QPKGs-SCinstallable:Add "$package"
				fi
			fi
		fi

		if QPKG.IsCanBackup "$package"; then
			if QPKG.IsBackupExist "$package"; then
				QPKGs-ISbackedup:Add "$package"
			else
				QPKGs-ISNTbackedup:Add "$package"
			fi
		fi
	done

	qpkgs_states_built=true
	[[ ${FUNCNAME[1]} != Self:LogEnv ]] && EraseThisLine		# prevent empty line appearing briefly when starting-up

	if [[ ${1:-} != rebuild ]]; then
		QPKGs.Missing:Show
		QPKGs.NewVers:Show
	fi

	Func:Exit

	}

QPKGs.IsCanBackup:Build()
	{

	# Build a list of QPKGs that support `backup` and `restore` actions

	Func:Entry
	local package=''

	for package in $(QPKGs-SCall:Array); do
		QPKG.IsCanBackup "$package" && QPKGs-SCcanbackup:Add "$package"
	done

	Func:Exit

	}

QPKGs.IsCanRestartToUpdate:Build()
	{

	# Build a list of QPKGs that support application update on QPKG restart

	Func:Entry
	local package=''

	for package in $(QPKGs-SCall:Array); do
		QPKG.IsCanRestartToUpdate "$package" && QPKGs-SCcanrestarttoupdate:Add "$package"
	done

	Func:Exit

	}

QPKGs.IsCanClean:Build()
	{

	# Build a list of QPKGs that support `clean` actions

	Func:Entry
	local package=''

	for package in $(QPKGs-SCall:Array); do
		QPKG.IsCanClean "$package" && QPKGs-SCcanclean:Add "$package"
	done

	Func:Exit

	}

QPKGs.IsTimeoutsIncreased()
	{

	[[ -e /usr/local/sbin/qpkg_service.orig ]]

	}

QPKGs.Abbreviations:Show()
	{

	Func:Entry
	local tier=''
	local package_name=''
	local abs=''
	maxcols=2

	DisableDebugToArchiveAndFile
	ShowAsProc 'writing report'

		{

		Help.Basic:Show
		DisplayAsHelpTitle "$(FormatAsTitle) can recognise various abbreviations and aliases as $(FormatAsPackages)"

		for tier in "${PACKAGE_TIERS[@]}"; do
			[[ $tier = addon ]] && continue		# don't need to see addons

			DisplayAsHelpTitleNameAbs "$tier"

			for package_name in $(QPKGs-SC${tier}:Array); do
				abs=$(QPKG.Abbrvs "$package_name")

				if [[ -n $abs ]]; then
					if ! QPKG.URL "$package_name" &>/dev/null; then
						DisplayAsHelpNameAbs muted "$package_name" 'not installable (incompatible arch)'
					elif ! QPKG.MinRAM "$package_name" &>/dev/null; then
						DisplayAsHelpNameAbs muted "$package_name" 'not installable (insufficient RAM)'
					elif QPKGs-ISmissing:Exist "$package_name" &>/dev/null; then
						DisplayAsHelpNameAbs highlighted "$package_name" missing
					elif QPKGs-ISNTinstalled:Exist "$package_name"; then
						DisplayAsHelpNameAbs muted "$package_name" "${abs// /, }"
					else
						DisplayAsHelpNameAbs normal "$package_name" "${abs// /, }"
					fi
				fi
			done
		done

		DisplayAsProjSynExam "example: to install $(FormatAsPackName SABnzbd), $(FormatAsPackName Mylar3) and $(FormatAsPackName nzbToMedia) all-at-once" 'install sab my nzb2'

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"
	linespace_visible=false

	Func:Exit

	}

QPKGs.Backups:Show()
	{

	Func:Entry
	local epochtime=0	# allow float as seconds have a fractional component
	local filename=''
	local highlight_older_than='2 weeks ago'
	local format=''

	DisableDebugToArchiveAndFile
	ShowAsProc 'writing report'

		{

		DisplayAsHelpTitle "the location for $(FormatAsTitle) backups is: $QPKG_BU_PATH"

		if [[ -e $GNU_FIND_CMD ]]; then
			DisplayAsHelpTitle "backups are listed oldest-first, and those $(ColourTextBrightRed 'in red') were last updated more than $highlight_older_than"
			DisplayAsHelpTitleFileNamePlusSomething 'backup file' 'last backup date'

			while read -r epochtime filename; do
				[[ -z $epochtime || -z $filename ]] && break

				if [[ ${epochtime%.*} -lt $(/bin/date --date="$highlight_older_than" +%s) ]]; then
					format="$(ColourTextBrightRed "%${HELP_DESC_INDENT}s%-${FILE_NAME_COL_WIDTH}s - %s\n")"
				else
					format="%${HELP_DESC_INDENT}s%-${FILE_NAME_COL_WIDTH}s - %s\n"
				fi

				# shellcheck disable=2059
				printf "$format" '' "$filename" "$(/bin/date -d @"$epochtime" +%c)"
			done <<< "$($GNU_FIND_CMD "$QPKG_BU_PATH"/*.config.tar.gz -maxdepth 1 -printf '%C@ %f\n' 2>/dev/null | $SORT_CMD)"

		else
			DisplayAsHelpTitle 'backups are listed oldest-first'
			Display

			(cd "$QPKG_BU_PATH" && ls -1 ./*.config.tar.gz 2>/dev/null)
		fi

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"

	Func:Exit

	}

QPKGs.Repos:Show()
	{

	Func:Entry
	local tier=''
	local package_name=''
	local package_store_id=''
	local package_repo_URL=''
	local package_install_date=''
	maxcols=3

	DisableDebugToArchiveAndFile
	QPKGs.States:Build
	ShowAsProc 'writing report'

		{

		for tier in "${PACKAGE_TIERS[@]}"; do
			[[ $tier = addon ]] && continue		# don't need to see addons

			DisplayAsHelpTitleNameDateRepo "$tier"

			for package_name in $(QPKGs-SC$tier:Array); do
				if ! QPKG.URL "$package_name" &>/dev/null; then
					DisplayAsHelpNameDateRepo muted "$package_name" 'not installable (incompatible arch)'
				elif ! QPKG.MinRAM "$package_name" &>/dev/null; then
					DisplayAsHelpNameDateRepo muted "$package_name" 'not installable (insufficient RAM)'
				elif QPKGs-ISmissing:Exist "$package_name" &>/dev/null; then
					DisplayAsHelpNameDateRepo highlighted "$package_name" missing
				elif QPKGs-ISNTinstalled:Exist "$package_name"; then
					DisplayAsHelpNameDateRepo muted "$package_name" 'not installed'
				else
					package_store_id=$(QPKG.StoreID "$package_name")
					package_install_date=$(QPKG.InstallDate "$package_name")

					if [[ -z $package_store_id ]]; then
						DisplayAsHelpNameDateRepo normal "$package_name" unassigned "$package_install_date"
					elif [[ $package_store_id = sherpa ]]; then
						DisplayAsHelpNameDateRepo normal "$package_name" "$package_store_id" "$package_install_date"
					else
						DisplayAsHelpNameDateRepo highlighted "$package_name" "$(GetRepoURLFromStoreID "$package_store_id")" "$package_install_date"
					fi
				fi
			done
		done

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"
	QPKGs.Actions:List
	QPKGs.States:List

	Func:Exit

	}

QPKGs:List:Show()
	{

	local tier=''
	local package_name=''
	maxcols=3

	DisableDebugToArchiveAndFile
	ShowAsProc 'writing report'

		{

		Help.Basic:Show
		DisplayAsHelpTitle "One-or-more $(FormatAsPackages) may be specified at-once"

		for tier in "${PACKAGE_TIERS[@]}"; do
			[[ $tier = addon ]] && continue		# don't need to see addons

			DisplayAsHelpTitleNameAuthorDesc "$tier"

			for package_name in $(QPKGs-SC${tier}:Array); do
				if QPKGs-ISmissing:Exist "$package_name" &>/dev/null; then
					DisplayAsHelpNameAuthorDesc highlighted "$package_name" missing "$(QPKG.Desc "$package_name")" "$(QPKG.Note "$package_name")"
				elif QPKGs-ISNTinstalled:Exist "$package_name"; then
					if ! QPKG.URL "$package_name" &>/dev/null; then
						DisplayAsHelpNameAuthorDesc muted "$package_name" "$(QPKG.Author "$package_name")" "$(QPKG.Desc "$package_name")" "$(QPKG.Note 	"$package_name")" true
					elif ! QPKG.MinRAM "$package_name" &>/dev/null; then
						DisplayAsHelpNameAuthorDesc muted "$package_name" "$(QPKG.Author "$package_name")" "$(QPKG.Desc "$package_name")" "$(QPKG.Note 	"$package_name")" true
					else
						DisplayAsHelpNameAuthorDesc muted "$package_name" "$(QPKG.Author "$package_name")" "$(QPKG.Desc "$package_name")" "$(QPKG.Note "$package_name")"
					fi
				else
					DisplayAsHelpNameAuthorDesc normal "$package_name" "$(QPKG.Author "$package_name")" "$(QPKG.Desc "$package_name")" "$(QPKG.Note "$package_name")"
				fi
			done
		done

		DisplayAsProjSynExam "abbreviations and aliases may also be used to specify $(FormatAsPackages). To list these" 'list abs'
		DisplayAsProjSynIndentExam '' a

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"
	linespace_visible=false

	return 0

	}

QPKGs.Statuses:Show()
	{

	Func:Entry
	local tier=''
	local package_name=''
	local package_status_msg=''
	local package_result_msg=''

	CalcMaxStatusColsToDisplay
	DisableDebugToArchiveAndFile
	QPKGs.States:Build
	ShowAsProc 'writing report'

		{

		for tier in "${PACKAGE_TIERS[@]}"; do
			[[ $tier != addon ]] || continue		# don't need to see addons

			DisplayAsHelpTitleNameStatusVerPath "$tier"

			for package_name in $(QPKGs-SC$tier:Array); do
				if QPKGs-ISNTinstalled:Exist "$package_name"; then
					if ! QPKG.URL "$package_name" &>/dev/null; then
						DisplayAsHelpNameStatusVerPath muted "$package_name" 'not installable (incompatible arch)'
					elif ! QPKG.MinRAM "$package_name" &>/dev/null; then
						DisplayAsHelpNameStatusVerPath muted "$package_name" 'not installable (insufficient RAM)'
					else
						DisplayAsHelpNameStatusVerPath muted "$package_name" 'not installed' '' '' "$(QPKG.Avail.Ver "$package_name")"
					fi
				else
					if QPKGs-ISmissing:Exist "$package_name"; then
						DisplayAsHelpNameStatusVerPath highlighted "$package_name" missing '' "$(QPKG.Local.Ver "$package_name")" '' "$(QPKG.InstallationPath "$package_name")"
					else
						# state

						if QPKGs-ISenabled:Exist "$package_name"; then
							package_status_msg=enabled
						elif QPKGs-ISNTenabled:Exist "$package_name"; then
							package_status_msg=disabled
						fi

						# package/process: active/slow or inactive?

						if QPKGs-ACstatus-ok:Exist "$package_name"; then
							if QPKGs-ISactive:Exist "$package_name"; then
								package_status_msg+=' active'
							elif QPKGs-ISslow:Exist "$package_name"; then
								package_status_msg+=' slow'
							elif QPKGs-ISstarting:Exist "$package_name"; then
								package_status_msg+=' starting'
							elif QPKGs-ISstopping:Exist "$package_name"; then
								package_status_msg+=' stopping'
							elif QPKGs-ISrestarting:Exist "$package_name"; then
								package_status_msg+=' restarting'
							elif QPKGs-ISunknown:Exist "$package_name"; then
								package_status_msg+=' unknown'
							else
								package_status_msg+=' inactive'
							fi
						else
							package_status_msg+=' unknown'
						fi

						DisplayAsHelpNameStatusVerPath normal "$package_name" "$package_status_msg" "$package_result_msg" "$(QPKG.Local.Ver "$package_name")" "$(QPKG.Avail.Ver "$package_name")" "$(QPKG.InstallationPath "$package_name")"
					fi

					package_status_msg=''
					package_result_msg=''
				fi
			done
		done

		} > "$REPORT_PATHFILE"

	EraseThisLine		# clear the "proc:" message shown earlier
	[[ -e $REPORT_PATHFILE ]] && $CAT_CMD "$REPORT_PATHFILE"
	QPKGs.Actions:List
	QPKGs.States:List

	Func:Exit

	}

QPKGs.Timeouts:Increase()
	{

	Func:Entry
	local target_utility_pathfile=/usr/local/sbin/qpkg_service
	local backup_utility_pathfile=/usr/local/sbin/qpkg_service.orig

	if [[ ! -e $target_utility_pathfile ]]; then
		ShowAsError 'original utility not found'
		Func:Exit 1
		return 1
	fi

	if [[ -e $backup_utility_pathfile ]]; then
		ShowAsInfo 'default QPKG timeouts have already been increased'
	else
		mv "$target_utility_pathfile" "$backup_utility_pathfile"

		/bin/cat > "$target_utility_pathfile" << EOF
#!/usr/bin/env bash
#* this script was added by sherpa: https://git.io/sherpa
#* increase the default timeout for qpkg_service to $((QPKG_EXTENDED_TIMEOUT_SECONDS/60)) minutes
#* subsequent specification of -t values will override this value
$backup_utility_pathfile -t $QPKG_EXTENDED_TIMEOUT_SECONDS "\$@"
EOF

		/bin/chmod +x "$target_utility_pathfile"
		ShowAsDone "default QPKG timeouts have been increased to $((QPKG_EXTENDED_TIMEOUT_SECONDS/60)) minutes"
	fi

	qpkg_timeouts_increased=true

	Func:Exit

	}

QPKGs.Timeouts:Decrease()
	{

	Func:Entry
	local target_utility_pathfile=/usr/local/sbin/qpkg_service
	local backup_utility_pathfile=/usr/local/sbin/qpkg_service.orig

	if [[ ! -e $backup_utility_pathfile ]]; then
		ShowAsInfo 'default QPKG timeouts are in-effect'
	else
		mv -f "$backup_utility_pathfile" "$target_utility_pathfile"
		ShowAsDone 'default QPKG timeouts have been reverted to 3 minutes'
	fi

	qpkg_timeouts_increased=false

	Func:Exit

	}

QPKGs.IsBackedUp:Show()
	{

	local package=''
	DisableDebugToArchiveAndFile
	QPKGs.States:Build

	for package in $(QPKGs-ISbackedup:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.IsNtBackedUp:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-ISNTbackedup:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.IsInstalled:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-ISinstalled:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.ScInstallable:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-SCinstallable:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.IsNtInstalled:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-ISNTinstalled:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.IsActive:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-ISactive:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.IsNtActive:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-ISNTactive:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.ScUpgradable:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-SCupgradable:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.ScStandalone:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-SCstandalone:Array); do
		Display "$package"
	done

	return 0

	}

QPKGs.ScDependent:Show()
	{

	local package=''
	QPKGs.States:Build
	DisableDebugToArchiveAndFile

	for package in $(QPKGs-SCdependent:Array); do
		Display "$package"
	done

	return 0

	}

SendParentChangeEnv()
	{

	# Send a message into message stream to change a sherpa parent environment variable or variables
	# This function is only called from within background functions

	# input:
	#   $1 = action request

	WriteMsgToActionPipe env "$1" '' ''

	}

SendPackageStateChange()
	{

	# Send a message into message stream to change the state of this QPKG to $1 in sherpa parent environment
	# This might be: `isinstalled`, `isntenabled`, `isstarted`, `scntupgradable`, etc ...
	# This function is only called from within background functions

	# input:
	#   $1 = action request

	WriteMsgToActionPipe change "$1" package "$PACKAGE_NAME"

	}

SendActionStatus()
	{

	# send a message into message stream to update sherpa parent environment with the status of this action for $PACKAGE_NAME
	# This can be: `ok`, `skipped`, `failed`, `exit`
	# This function is only called from within background functions

	# input:
	#   $1 = status update

	WriteMsgToActionPipe status "$1" package "$PACKAGE_NAME"

	}

WriteMsgToActionPipe()
	{

	# send a message into message stream to update sherpa parent shell environment

	[[ $msg_pipe_fd != none && -e /proc/$$/fd/$msg_pipe_fd ]] && echo "$1|$2|$3|$4" >&$msg_pipe_fd

	}

ReadMsgFromActionPipe()
	{

	local _msg1_key
	local _msg1_value
	local _msg2_key
	local _msg2_value

	IFS='|' read -r _msg1_key _msg1_value _msg2_key _msg2_value

	eval "$1='$_msg1_key' $2='$_msg1_value' $3='$_msg2_key' $4='$_msg2_value'"

	return 0

	} <&$msg_pipe_fd

FindNextFD()
	{

	# find next available file descriptor: https://stackoverflow.com/a/41603891

	local -i fd=-1

	for fd in {10..100}; do
		if [[ ! -e /proc/$$/fd/$fd ]]; then
			echo "$fd"
			return 0
		fi
	done

	return 1

	}

MarkThisActionForkAsStarted()
	{

	[[ -n ${proc_fork_pathfile:-} ]] && $TOUCH_CMD "$proc_fork_pathfile"

	}

MarkThisActionForkAsOk()
	{

	[[ -n ${proc_fork_pathfile:-} && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_ok_pathfile"
	SendActionStatus ok

	}

MarkThisActionForkAsSkippedOk()
	{

	[[ -n ${proc_fork_pathfile:-} && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skipok_pathfile"
	SendActionStatus so

	}

MarkThisActionForkAsSkipped()
	{

	[[ -n ${proc_fork_pathfile:-} && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_pathfile"
	SendActionStatus sk

	}

MarkThisActionForkAsSkippedError()
	{

	[[ -n ${proc_fork_pathfile:-} && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_skip_error_pathfile"
	SendActionStatus se

	}

MarkThisActionForkAsFailed()
	{

	[[ -n ${proc_fork_pathfile:-} && -e $proc_fork_pathfile ]] && mv "$proc_fork_pathfile" "$proc_fail_pathfile"
	SendActionStatus er

	}

NoteIpkAcAsOk()
	{

	# move specified IPK package name from `to` action array into associated `ok` array

	# input:
	#   $1 = package name
	#   $2 = action

	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-ok:Add "$1"

	return 0

	}

NoteIpkAcAsEr()
	{

	# move specified IPK package name from `to` action array into associated `er` array

	# input:
	#   $1 = package name
	#   $2 = action
	#   $3 = reason (optional)

	local msg="failing request to $2 $(FormatAsPackName "$1")"

	[[ -n ${3:-} ]] && msg+=" as $3"
	DebugAsError "$msg" >&2
	IPKs-AC"$2"-to:Remove "$1"
	IPKs-AC"$2"-er:Add "$1"

	return 0

	}

ModPathToEntware()
	{

	local -r OPKG=/opt/bin:/opt/sbin
	local temp=''

	if QPKGs-ISenabled:Exist Entware; then
		! [[ $PATH =~ $OPKG ]] || return
		temp="$($SED_CMD "s|$OPKG:||" <<< "$PATH:")"	# append colon prior to searching, then remove existing Entware paths
		export PATH="$OPKG:${temp%:}"				# ... now prepend Entware paths and remove trailing colon
		DebugAsDone 'prepended Entware to $PATH'
	else
		[[ $PATH =~ $OPKG ]] || return
		temp="$($SED_CMD "s|$OPKG:||" <<< "$PATH:")"	# append colon prior to searching, then remove existing Entware paths
		export PATH="${temp%:}"								# ... now remove trailing colon
		DebugAsDone 'removed Entware from $PATH'
	fi

	DebugVar PATH

	return 0

	}

GetCPUInfo()
	{

	# QTS 4.5.1 & BusyBox 1.01 don't support `-m` option for `grep`, so extract first mention the hard-way with `head`

	if $GREP_CMD -q '^model name' /proc/cpuinfo; then
		$GREP_CMD '^model name' /proc/cpuinfo | $HEAD_CMD -n1 | $SED_CMD 's|^.*: ||'
	elif $GREP_CMD -q '^Processor name' /proc/cpuinfo; then
		$GREP_CMD '^Processor name' /proc/cpuinfo | $HEAD_CMD -n1 | $SED_CMD 's|^.*: ||'
	else
		echo unknown
		return 1
	fi

	return 0

	}

GetArch()
	{

	$UNAME_CMD -m

	}

GetKernel()
	{

	$UNAME_CMD -r

	}

GetPlatform()
	{

	/sbin/getcfg '' Platform -d unknown -f /etc/platform.conf

	}

GetDefVol()
	{

	/sbin/getcfg SHARE_DEF defVolMP -f /etc/config/def_share.info

	}

OS.IsCompatibleWithSigned()
	{

	# QTS builds released over these 6 days don't allow unsigned QPKGs to run at-all
	[[ $NAS_FIRMWARE_DATE -lt 20201015 || $NAS_FIRMWARE_DATE -gt 20201020 ]]

	}

OS.IsSupported()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 400 ]]

	}

OS.IsSupportSecureDownload()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 426 ]]

	}

OS.IsSupportQpkgTimeout()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 430 ]]

	}

OS.IsSupportSignedPackages()
	{

	[[ ${NAS_FIRMWARE_VER//.} -ge 435 ]]

	}

OS.IsAllowUnsignedPackages()
	{

	[[ $(/sbin/getcfg 'QPKG Management' Ignore_Cert) = TRUE ]]

	}

OS.IsStarting()
	{

	ps | $GREP_CMD -F '/bin/sh /etc/init.d/rcS' | $GREP_CMD -v grep

	} &>/dev/null

OS.IsStopping()
	{

	ps | $GREP_CMD -F '/bin/sh /etc/init.d/rcK' | $GREP_CMD -v grep

	} &>/dev/null

GetRepoURLFromStoreID()
	{

	# input:
	#	$1 = store ID to lookup repo URL for

	[[ -n ${1:-} ]] || return

	/sbin/getcfg "$1" u -d unknown -f /etc/config/3rd_pkg_v2.conf

	}

GetUptime()
	{

	raw=$(</proc/uptime)
	FormatSecsToHoursMinutesSecs "${raw%%.*}"

	}

GetTimeInShell()
	{

	local duration=0

	if [[ -n ${LOADER_SCRIPT_PPID:-} ]]; then
		duration=$(ps -o pid,etime | $GREP_CMD $LOADER_SCRIPT_PPID | $HEAD_CMD -n1)
	fi

	FormatLongMinutesSecs "${duration:6}"

	}

GetSysLoadAverages()
	{

	$UPTIME_CMD | $SED_CMD 's|.*load average: ||' | $AWK_CMD -F', ' '{print "1m:"$1", 5m:"$2", 15m:"$3}'

	}

GetCPUCores()
	{

	local num=$($GREP_CMD -c '^processor' /proc/cpuinfo)
	[[ $num -eq 0 ]] && num=$($GREP_CMD -c '^Processor' /proc/cpuinfo)
	echo "$num"

	}

GetInstalledRAM()
	{

	$GREP_CMD MemTotal /proc/meminfo | $SED_CMD 's|.*: ||;s|kB||;s| ||g'

	}

GetFirmwareVer()
	{

	/sbin/getcfg System Version -f /etc/config/uLinux.conf

	}

GetFirmwareBuild()
	{

	/sbin/getcfg System Number -f /etc/config/uLinux.conf

	}

GetFirmwareDate()
	{

	/sbin/getcfg System 'Build Number' -f /etc/config/uLinux.conf

	}

GetQnapOS()
	{

	if $GREP_CMD -q zfs /proc/filesystems; then
		echo 'QuTS hero'
	else
		echo QTS
	fi

	}

GetQpkgArch()
	{

	# translate arch from QTS-to-sherpa notation

	case $NAS_ARCH in
		x86_64)
			[[ ${NAS_FIRMWARE_VER//.} -ge 430 ]] && echo i64 || echo i86
			;;
		i686|x86)
			echo i86
			;;
		armv5tel)
			echo a19
			;;
		armv7l)
			case $NAS_PLATFORM in
				ARM_MS)
					echo a31
					;;
				ARM_AL)
					echo a41
					;;
				*)
					echo none
			esac
			;;
		aarch64)
			echo a64
			;;
		*)
			echo none
	esac

	}

GetEntwareType()
	{

	if QPKG.IsInstalled Entware; then
		if [[ -e /opt/etc/passwd ]]; then
			if [[ -L /opt/etc/passwd ]]; then
				echo std
			else
				echo alt
			fi
		else
			echo none
		fi
	fi

	} 2>/dev/null

GetSudoUID()
	{

	echo "${SUDO_UID:-<undefined>}"

	}

Self.Error:Set()
	{

	skip_package_actions=true
	Self.Error:IsSet && return
	_script_error_flag_=true
	DebugVar _script_error_flag_

	}

Self.Error:IsSet()
	{

	[[ ${_script_error_flag_:-} = true ]]

	}

Self.Error:IsNt()
	{

	[[ ${_script_error_flag_:-} != true ]]

	}

ShowZeroQpkgs()
	{

	local state=''
	local action=''

	for state in "${USER_QPKG_IS_STATES[@]}"; do
		for action in "${USER_QPKG_ACTIONS[@]}"; do
			case $action in
				disable|enable|list)
					continue	# action results lists are unavailable for these
			esac

			QPKGs.AC${action}.IS${state}:IsSet && QPKGs-AC${action}-ok:IsNone && ShowAsWarn "no QPKGs were able to $(Lowercase "$action")"
		done
	done

	return 0

	}

Self.LockFile:Claim()
	{

	readonly LOCK_PATHFILE=/var/run/sherpa.lock
	local re=\\bsherpa.manager.sh\\b

	if [[ -e $LOCK_PATHFILE && -d /proc/$(<"$LOCK_PATHFILE") && $(</proc/"$(<"$LOCK_PATHFILE")"/cmdline) =~ $re ]]; then
		ShowAsAbort "another instance is running (PID: $(<"$LOCK_PATHFILE"))"
		return 1
	fi

	echo "$$" > "$LOCK_PATHFILE"
	return 0

	}

Self.LockFile:Release()
	{

	rm -f "$LOCK_PATHFILE"

	}

Self.Verbose:Enable()
	{

	opts_verbose=true
	Keystrokes:Show
	Cursor:Show
	EnableDebugToArchiveAndFile

	}

EnableDebugToArchiveAndFile()
	{

	self_debug_archive_afterward=true
	opts_debug=true

	}

DisableDebugToArchiveAndFile()
	{

	self_debug_archive_afterward=false
	opts_debug=false

	}

SaveActionResultToLog()
	{

	# Write package type, package name, datetime in seconds, action, result, reason to actions logfile, and into actions durations file

	# input:						example:
	#   $1 = package type			`QPKG`, `IPK`, `PIP`
	#   $2 = package or group name	`SABnzbd`, `essential`
	#   $3 = action					`download`, `activate`
	#   $4 = result					`ok`, `skipped-ok`, `skipped`, `failed`
	#   $5 = reason (optional)		"file already exists in local cache"

	# calculate duration here

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}
	local -r PACKAGE_TYPE=${1:?package type empty}
	local -r PACKAGE_NAME=${2:?package name empty}
	local -r ACTION=${3:?action empty}
	local -r CLEAN_ACTION=${ACTION//\"/}
	local -r RESULT=${4:?result empty}
	local -r REASON=${5:-}
	local -r DURATION="$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")"
	local -r ACTION_TIMES_PATHFILE="$ACTION_TIMES_PATH/$CLEAN_ACTION.milliseconds"

	# write new action results entry
	echo "$(/bin/date +%s)|$ACTION|$PACKAGE_NAME|$RESULT|$DURATION|$REASON|$PACKAGE_TYPE" >> "$SESS_ACTIONS_RESULTS_PATHFILE"

	# remove previous action duration entry if one exists

	if [[ -e $ACTION_TIMES_PATHFILE ]] && $GREP_CMD -q "^$PACKAGE_NAME|" < "$ACTION_TIMES_PATHFILE"; then
		$SED_CMD -i "/^$PACKAGE_NAME|/d" "$ACTION_TIMES_PATHFILE"
	fi

	# add new action duration entry
	echo "$PACKAGE_NAME|$DURATION" >> "$ACTION_TIMES_PATHFILE"

	case $4 in
		ok|skipped-ok)
			DebugAsInfo "$REASON"
			;;
		skipped)
			DebugAsWarn "$REASON"
			;;
		failed|skipped-error)
			DebugAsError "$REASON"
	esac

	return 0

	}

_QPKG:reassign_()
	{

	# * This function runs autonomously *
	# Removes the `storeid` assignment for the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0

	if ! QPKGs-ISinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign skipped 'not installed'
		result_code=2
	elif [[ $(QPKG.StoreID "$PACKAGE_NAME") = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign skipped 'already assigned to sherpa'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "reassigning $(FormatAsPackName "$PACKAGE_NAME")"
	RunAndLog "$SETCFG_CMD -e $PACKAGE_NAME store -f /etc/config/qpkg.conf" "$LOGS_PATH/$PACKAGE_NAME.$REASSIGN_LOG_FILE" log:failure-only
	result_code=$?

	if [[ $result_code -eq 0 ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reassign failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:download_()
	{

	# * This function runs autonomously *
	# Downloads the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local -r REMOTE_URL=$(QPKG.URL "$PACKAGE_NAME")
	local -r REMOTE_FILENAME=$($BASENAME_CMD "$REMOTE_URL")
	local -r REMOTE_MD5=$(QPKG.MD5 "$PACKAGE_NAME")
	local -r LOCAL_PATHFILE=$QPKG_DL_PATH/$REMOTE_FILENAME
	local -r LOCAL_FILENAME=$($BASENAME_CMD "$LOCAL_PATHFILE")
	local -r LOG_PATHFILE=$LOGS_PATH/$LOCAL_FILENAME.$DOWNLOAD_LOG_FILE

	if [[ -z $REMOTE_URL || -z $REMOTE_MD5 ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" download skipped 'NAS is unsupported'
		MarkThisActionForkAsSkipped
		result_code=2
	elif [[ -f $LOCAL_PATHFILE ]]; then
		if FileMatchesMD5 "$LOCAL_PATHFILE" "$REMOTE_MD5"; then
			SaveActionResultToLog QPKG "$PACKAGE_NAME" download skipped-ok "existing file $(FormatAsFileName "$LOCAL_FILENAME") checksum correct"
			MarkThisActionForkAsSkippedOk
			FuncFork:Exit 0
		else
			DebugInfo "deleting $(FormatAsFileName "$LOCAL_FILENAME") as checksum is incorrect"
			rm -f "$LOCAL_PATHFILE"
		fi
	fi

	if [[ $result_code -gt 0 ]]; then
		FuncFork:Exit $result_code
	fi

	if [[ ! -f $LOCAL_PATHFILE ]]; then
		DebugAsProc "downloading $(FormatAsFileName "$REMOTE_FILENAME")"

		rm -f "$LOG_PATHFILE"

		RunAndLog "$CURL_CMD${curl_insecure_arg} --location --output $LOCAL_PATHFILE $REMOTE_URL" "$LOG_PATHFILE" log:failure-only
		result_code=$?

		if [[ $result_code -eq 0 ]]; then
			if FileMatchesMD5 "$LOCAL_PATHFILE" "$REMOTE_MD5"; then
				[[ $(Lowercase "${LOCAL_PATHFILE##*.}") = zip ]] && $UNZIP_CMD -nq "$LOCAL_PATHFILE" -d "$QPKG_DL_PATH"
				SaveActionResultToLog QPKG "$PACKAGE_NAME" download ok
				SendPackageStateChange ISdownloaded
				MarkThisActionForkAsOk
			else
				SaveActionResultToLog QPKG "$PACKAGE_NAME" download failed "downloaded file $(FormatAsFileName "$LOCAL_FILENAME") has incorrect checksum"
				SendPackageStateChange ISNTdownloaded
				result_code=1
				MarkThisActionForkAsFailed
			fi
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" download failed "$result_code"
			result_code=1   # remap to 1 (last time I checked, 'curl' had 92 return codes)
			MarkThisActionForkAsFailed
		fi
	fi

	FuncFork:Exit $result_code

	}

_QPKG:install_()
	{

	# * This function runs autonomously *
	# Installs the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'already installed'
		result_code=2
	elif ! QPKG.URL "$PACKAGE_NAME" &>/dev/null; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'NAS is unsupported'
		result_code=2
	elif ! QPKG.MinRAM "$PACKAGE_NAME" &>/dev/null; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped 'NAS has insufficient RAM'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	local local_pathfile=$(QPKG.PathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install skipped-error 'no local file found for processing: please report this issue'
		MarkThisActionForkAsSkippedError
		FuncFork:Exit 2
	fi

	if [[ $PACKAGE_NAME = Entware ]] && ! QPKGs-ISinstalled:Exist Entware && QPKGs-ACinstall-to:Exist Entware; then
		local -r OPT_PATH=/opt
		local -r OPT_BU_PATH=/opt.orig

		if [[ -d $OPT_PATH && ! -L $OPT_PATH && ! -e $OPT_BU_PATH ]]; then
			DebugAsProc 'backup original /opt'
			mv "$OPT_PATH" "$OPT_BU_PATH"
			DebugAsDone complete
		fi
	fi

	local target_path=''

	DebugAsProc "installing $(FormatAsPackName "$PACKAGE_NAME")"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	[[ ${QPKGs_were_installed_name[*]:-} = *"$PACKAGE_NAME"* ]] && target_path="QINSTALL_PATH=$(QPKG.OriginalPath "$PACKAGE_NAME") "
	RunAndLog "${debug_cmd}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$INSTALL_LOG_FILE" log:failure-only 10
	result_code=$?

	if [[ $result_code -eq 0 || $result_code -eq 10 ]]; then
		QPKG.ServiceStatus:Log
		SendPackageStateChange ISinstalled

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		SaveActionResultToLog QPKG "$PACKAGE_NAME" install ok "version $(QPKG.Local.Ver "$PACKAGE_NAME")"

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			PatchEntwareService

			# shift all files from original [/opt] into new [/opt]

			if [[ -L ${OPT_PATH:-} && -d ${OPT_BU_PATH:-} ]]; then
				DebugAsProc 'restoring original /opt'
				mv "$OPT_BU_PATH"/* "$OPT_PATH" && rm -rf "$OPT_BU_PATH"
				DebugAsDone complete
			fi
		fi

		SendParentChangeEnv "QPKGs-ACsign-to:Add $PACKAGE_NAME"
		result_code=0   # remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK)
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" install failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:reinstall_()
	{

	# * This function runs autonomously *
	# Reinstalls the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if ! QPKGs-ISinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped "not installed, please use 'install' instead"
		MarkThisActionForkAsSkipped
		FuncFork:Exit 2
	fi

	local local_pathfile=$(QPKG.PathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall skipped-error 'no local file found for processing, please report this issue'
		MarkThisActionForkAsSkippedError
		FuncFork:Exit 2
	fi

	local target_path=''

	DebugAsProc "reinstalling $(FormatAsPackName "$PACKAGE_NAME")"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	QPKG.IsInstalled "$PACKAGE_NAME" && target_path="QINSTALL_PATH=$($DIRNAME_CMD "$(QPKG.InstallationPath $PACKAGE_NAME)") "
	RunAndLog "${debug_cmd}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$REINSTALL_LOG_FILE" log:failure-only 10
	result_code=$?

	if [[ $result_code -eq 0 || $result_code -eq 10 ]]; then
		QPKG.ServiceStatus:Log

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		local current_ver=$(QPKG.Local.Ver "$PACKAGE_NAME")
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall ok "version $current_ver"
		SendParentChangeEnv "QPKGs-ACsign-to:Add $PACKAGE_NAME"
		result_code=0   # remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK)
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reinstall failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:upgrade_()
	{

	# * This function runs autonomously *
	# Upgrades the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if ! QPKGs-ISinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped 'not installed'
		result_code=2
	elif ! QPKGs-SCupgradable:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped 'no new package is available'
		result_code=2
	fi

	if [[ $(QPKG.StoreID "$PACKAGE_NAME") != sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped "assigned to another repository, please 'reassign' it first"
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	local local_pathfile=$(QPKG.PathFilename "$PACKAGE_NAME")

	if [[ -z $local_pathfile || ! -e $local_pathfile ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade skipped-error 'no local file found for processing, please report this issue'
		MarkThisActionForkAsSkippedError
		FuncFork:Exit 2
	fi

	local prev_ver=$(QPKG.Local.Ver "$PACKAGE_NAME")
	local target_path=''

	DebugAsProc "upgrading $(FormatAsPackName "$PACKAGE_NAME")"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	QPKG.IsInstalled "$PACKAGE_NAME" && target_path="QINSTALL_PATH=$($DIRNAME_CMD "$(QPKG.InstallationPath "$PACKAGE_NAME")") "
	RunAndLog "${debug_cmd}${target_path}${SH_CMD} $local_pathfile" "$LOGS_PATH/$($BASENAME_CMD "$local_pathfile").$UPGRADE_LOG_FILE" log:failure-only 10
	result_code=$?

	if [[ $result_code -eq 0 || $result_code -eq 10 ]]; then
		QPKG.ServiceStatus:Log
		SendPackageStateChange SCNTupgradable

		if QPKG.IsEnabled "$PACKAGE_NAME"; then
			SendPackageStateChange ISenabled
		else
			SendPackageStateChange ISNTenabled
		fi

		local current_ver=$(QPKG.Local.Ver "$PACKAGE_NAME")

		if [[ $current_ver = "$prev_ver" ]]; then
			SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade ok "version $current_ver"
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade ok "upgraded from version $prev_ver to version $current_ver"
		fi

		SendParentChangeEnv "QPKGs-ACsign-to:Add $PACKAGE_NAME"
		result_code=0   # remap to zero (0 or 10 from a QPKG install/reinstall/upgrade is OK)
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" upgrade failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:uninstall_()
	{

	# * This function runs autonomously *
	# Uninstalls the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall skipped 'not installed'
		result_code=2
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall skipped "it's needed here! 😉"
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	local -r QPKG_UNINSTALLER_PATHFILE=$(QPKG.InstallationPath "$PACKAGE_NAME")/.uninstall.sh

	[[ $PACKAGE_NAME = Entware ]] && SavePackageLists

	if [[ -e $QPKG_UNINSTALLER_PATHFILE ]]; then
		DebugAsProc "uninstalling $(FormatAsPackName "$PACKAGE_NAME")"
		[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

		RunAndLog "${debug_cmd}${SH_CMD} $QPKG_UNINSTALLER_PATHFILE" "$LOGS_PATH/$PACKAGE_NAME.$UNINSTALL_LOG_FILE" log:failure-only
		result_code=$?

		if [[ $result_code -eq 0 ]]; then
			[[ -e /sbin/qpkg_cli ]] && /sbin/qpkg_cli --remove "$PACKAGE_NAME" &>/dev/null
			SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall ok
			/sbin/rmcfg "$PACKAGE_NAME" -f /etc/config/qpkg.conf
			DebugAsDone 'removed icon information from App Center'

			if [[ $PACKAGE_NAME = Entware ]]; then
				SendParentChangeEnv ModPathToEntware
				UpdateColourisation
			fi

			SendPackageStateChange ISNTinstalled
			SendPackageStateChange ISNTactive
			SendPackageStateChange ISNTenabled
			MarkThisActionForkAsOk
		else
			SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall failed "$result_code"

			result_code=1   # remap to 1
			MarkThisActionForkAsFailed
		fi
	else
		# standard QPKG `.uninstall.sh` was not found, so can't continue with uninstallation (maybe force this instead with `rm -r` ?)
		SaveActionResultToLog QPKG "$PACKAGE_NAME" uninstall failed '.uninstall.sh script is missing'
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:reactivate_()
	{

	# * This function runs autonomously *
	# Restarts/reactivates the service script for the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate skipped 'not installed'
		MarkThisActionForkAsSkipped
		FuncFork:Exit 2
	fi

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$REACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_RESTART_TIMEOUT_SECONDS"

	DebugAsProc "reactivating $(FormatAsPackName "$PACKAGE_NAME")"

	if [[ $opts_debug = true ]]; then
		debug_cmd='DEBUG_QPKG=true '
		RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) restart" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	elif QPKG.IsCanLog; then		# use `qpkg_service` if-possible, so package icon in App Center will dynamically update
		RunAndLog "/sbin/qpkg_service${timeout} restart $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && result_code=0 || result_code=1
	else
		RunAndLog "$(QPKG.ServicePathFile) restart" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	fi

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate ok
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" reactivate failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi
	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:activate_()
	{

	# * This function runs autonomously *
	# Starts/activates the service script for the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate skipped 'not installed'
		MarkThisActionForkAsSkipped
		FuncFork:Exit 2
	fi

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$ACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_START_TIMEOUT_SECONDS"

	DebugAsProc "activating $(FormatAsPackName "$PACKAGE_NAME")"

	if [[ $opts_debug = true ]]; then
		debug_cmd='DEBUG_QPKG=true '
		RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) start" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	elif QPKG.IsCanLog; then		# use `qpkg_service` if-possible, so package icon in App Center will dynamically update
		RunAndLog "/sbin/qpkg_service${timeout} start $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && result_code=0 || result_code=1
	else
		RunAndLog "$(QPKG.ServicePathFile) start" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	fi

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate ok

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			UpdateColourisation
		fi

		SendPackageStateChange ISactive
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" activate failed "$result_code"
		SendPackageStateChange ISNTactive
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:deactivate_()
	{

	# * This function runs autonomously *
	# Stops/deactivates the service script for the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped 'not installed'
		result_code=2
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate skipped "it's needed here! 😉"
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$DEACTIVATE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_STOP_TIMEOUT_SECONDS"

	DebugAsProc "deactivating $(FormatAsPackName "$PACKAGE_NAME")"

	if [[ $opts_debug = true ]]; then
		debug_cmd='DEBUG_QPKG=true '
		RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) stop" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	elif QPKG.IsCanLog; then		# use `qpkg_service` if-possible, so package icon in App Center will dynamically update
		RunAndLog "/sbin/qpkg_service${timeout} stop $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
		QPKG.LastResultWasOk && result_code=0 || result_code=1
	else
		RunAndLog "$(QPKG.ServicePathFile) stop" "$LOG_PATHFILE" log:failure-only
		result_code=$?
	fi

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate ok

		if [[ $PACKAGE_NAME = Entware ]]; then
			SendParentChangeEnv ModPathToEntware
			UpdateColourisation
		fi

		SendPackageStateChange ISNTactive
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" deactivate failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	QPKG.AppCenterNotifier:Clear
	FuncFork:Exit $result_code

	}

_QPKG:enable_()
	{

	# * This function runs autonomously *
	# Enables the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enable skipped 'not installed'
		result_code=2
	elif QPKGs-ISenabled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" enable skipped 'already enabled'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$ENABLE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_ENABLE_TIMEOUT_SECONDS"

	DebugAsProc "enabling $(FormatAsPackName "$PACKAGE_NAME")"

	RunAndLog "/sbin/qpkg_service${timeout} enable $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
	QPKG.IsEnabled "$PACKAGE_NAME" && SendPackageStateChange ISenabled
	QPKG.AppCenterNotifier:Clear
	SaveActionResultToLog QPKG "$PACKAGE_NAME" enable ok
	MarkThisActionForkAsOk
	FuncFork:Exit $result_code

	}

_QPKG:disable_()
	{

	# * This function runs autonomously *
	# Disabled the QPKG named in $1

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped 'not installed'
		result_code=2
	elif QPKGs-ISNTenabled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped 'already disabled'
		result_code=2
	elif [[ $PACKAGE_NAME = sherpa ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" disable skipped "it's needed here! 😉"
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	QPKG.ServiceStatus:Clear
	local -r LOG_PATHFILE=$LOGS_PATH/$PACKAGE_NAME.$DISABLE_LOG_FILE
	local timeout=''
	OS.IsSupportQpkgTimeout && timeout=" -t $QPKG_DISABLE_TIMEOUT_SECONDS"

	DebugAsProc "disabling $(FormatAsPackName "$PACKAGE_NAME")"

	RunAndLog "/sbin/qpkg_service${timeout} disable $PACKAGE_NAME" "$LOG_PATHFILE" log:failure-only
	! QPKG.IsEnabled "$PACKAGE_NAME" && SendPackageStateChange ISNTenabled

	QPKG.AppCenterNotifier:Clear
	SaveActionResultToLog QPKG "$PACKAGE_NAME" disable ok
	MarkThisActionForkAsOk
	FuncFork:Exit $result_code

	}

_QPKG:backup_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `backup` action

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup skipped 'not installed'
		result_code=2
	elif ! QPKG.IsCanBackup; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup skipped 'does not support backup'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "backing-up $(FormatAsPackName "$PACKAGE_NAME") configuration"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) backup" "$LOGS_PATH/$PACKAGE_NAME.$BACKUP_LOG_FILE" log:failure-only
	result_code=$?

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup ok
		SendPackageStateChange ISbackedup
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" backup failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:restore_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `restore` action

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped 'not installed'
		result_code=2
	elif ! QPKG.IsCanBackup; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore skipped 'does not support restore'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "restoring $(FormatAsPackName "$PACKAGE_NAME") configuration"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) restore" "$LOGS_PATH/$PACKAGE_NAME.$RESTORE_LOG_FILE" log:failure-only
	result_code=$?

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore ok
		SendPackageStateChange ISrestored
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" restore failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:clean_()
	{

	# * This function runs autonomously *
	# Calls the service script for the QPKG named in $1 and runs a `clean` action

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean skipped 'not installed'
		result_code=2
	elif ! QPKG.IsCanClean; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean skipped 'does not support cleaning'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "cleaning $(FormatAsPackName "$PACKAGE_NAME")"
	[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

	RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) clean" "$LOGS_PATH/$PACKAGE_NAME.$CLEAN_LOG_FILE" log:failure-only
	result_code=$?

	if [[ $result_code -eq 0 ]]; then
		QPKG.ServiceStatus:Log
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean ok
		SendPackageStateChange IScleaned
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" clean failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:sign_()
	{

	# * This function runs autonomously *
	# Modify the QTS App Center certificate dB, and add an unsigned QPKG as-if it were signed. It adds a QNAP-generated certificate and digital signature to the certificate database for the unsigned QPKG.

	# Running the code below makes the target QPKG effectively "signed", and allows user to install and run this QPKG with the 'Allow installation of applications without a valid digital signature' App Center option unticked.

	# Should only be required for QTS 4.3.5-and-later firmwares.

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	local -r PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local cert=''
	local signature=''
	local cmd=''

	if ! OS.IsSupportSignedPackages; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'not required: firmware < 4.3.5'
		result_code=2
	elif ! QPKGs-ISinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'not installed'
		result_code=2
	elif [[ ! -e $GNU_SQLITE_CMD ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'sqlite3 not installed'
		result_code=2
	elif [[ ! -e $CERT_DB_PATHFILE ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' skipped 'certificate database not found'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "\"signing\" $(FormatAsPackName "$PACKAGE_NAME")"

	# this certificate block is the same used by QNAP for LicenseCenter
	read -r -d '' cert << EOB
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIFALhDVuwwDQYJKoZIhvcNAQELBQAwgYAxCzAJBgNVBAYT
AlRXMQ8wDQYDVQQIDAZUYWl3YW4xDzANBgNVBAcMBlRhaXBlaTENMAsGA1UECgwE
UU5BUDEMMAoGA1UECwwDTkFTMRAwDgYDVQQDDAdRTkFQX0NBMSAwHgYJKoZIhvcN
AQkBFhFzZWN1cml0eUBxbmFwLmNvbTAeFw0yMjAzMTgwNzM5MTRaFw0yNTAzMTcw
NzM5MTRaMIGGMQswCQYDVQQGEwJUVzEPMA0GA1UECAwGVGFpd2FuMQ8wDQYDVQQH
DAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsMA05BUzEWMBQGA1UEAwwN
TGljZW5zZUNlbnRlcjEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlAcW5hcC5jb20w
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/bAgbZryVvBXfpBHNUKQV
sAkAfvDXjKnxa7lKHrRIcFcOnf+voUZcP1Ly9qWb782gB2eUHsUS1Xqj4CF/dUJf
FEnOBrQUo9+Q9B3x4oTRpMdky7acP4dxAbt4T92swgaReQXAewy9s9//a52HIBca
1dAA4JPwplqiZ/oh18GDCKxh84Iu9Gcu2J5e+VXEI/KUxCwKUd22aDTpv128MSoq
dYexCerCJtQbgM3cwkkMiDnFpjrsta5iFpyrNKdLoBJ7YbY3d5Onkqy4DjE8hwR7
0j7Qd+3xbMqv3FOCKeLLLn6N03IXHKP/big/MdXKY1dJQVA3/ks/knPH8mhcOM0d
AgMBAAGjPDA6MDgGA1UdHwQxMC8wLaAroCmGJ2h0dHA6Ly9kb3dubG9hZC5xbmFw
LmNvbS9jcmwvcXRzX3YxLmNybDANBgkqhkiG9w0BAQsFAAOCAQEAWlT1GDH6v8G3
laIAs2/RdxhPgtKX4aL+fnTEFNF5V2yH0G4luyq5tHQw+VCHtDM6Z3GXWhciKPAR
upbRcHq744JCFaUb6i8z1w1KVJDaQ38EVE5+JtpoPMrrnb+hKB/gGmi4PoMSpnvX
VCxLbCbBnwi19o6t/MnPbz0shvUB2NDngnal6lYQFw/F8Sr6cSjV6GAY4TOZotdu
+gunwqQtYUycEVfNyiWVk/flgED8R8oxTPl9ZoDGen+OgjkZrvgynKnqPLHyxZSd
hYSoWyWcZWkMCQ+69kOgJVvrRa7z9F9y30uAHXIUrsLV2d/dImVjApMHbZ60iALG
AVIlas0e4g==
-----END CERTIFICATE-----
EOB

	# this digital signature block is the same used by QNAP for LicenseCenter
	read -r -d '' signature << EOB
MIME-Version: 1.0
Content-Disposition: attachment; filename="smime.p7m"
Content-Type: application/pkcs7-mime; smime-type=signed-data; name="smime.p7m"
Content-Transfer-Encoding: base64

MIIGtAYJKoZIhvcNAQcCoIIGpTCCBqECAQExDTALBglghkgBZQMEAgEwIwYJKoZI
hvcNAQcBoBYEFAkoseBaFir08zCz63r2YA82DXzxoIIDxzCCA8MwggKroAMCAQIC
BQC4Q1bsMA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJUVzEPMA0GA1UECAwG
VGFpd2FuMQ8wDQYDVQQHDAZUYWlwZWkxDTALBgNVBAoMBFFOQVAxDDAKBgNVBAsM
A05BUzEQMA4GA1UEAwwHUU5BUF9DQTEgMB4GCSqGSIb3DQEJARYRc2VjdXJpdHlA
cW5hcC5jb20wHhcNMjIwMzE4MDczOTE0WhcNMjUwMzE3MDczOTE0WjCBhjELMAkG
A1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UEBwwGVGFpcGVpMQ0wCwYD
VQQKDARRTkFQMQwwCgYDVQQLDANOQVMxFjAUBgNVBAMMDUxpY2Vuc2VDZW50ZXIx
IDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAv2wIG2a8lbwV36QRzVCkFbAJAH7w14yp8Wu5Sh60
SHBXDp3/r6FGXD9S8valm+/NoAdnlB7FEtV6o+Ahf3VCXxRJzga0FKPfkPQd8eKE
0aTHZMu2nD+HcQG7eE/drMIGkXkFwHsMvbPf/2udhyAXGtXQAOCT8KZaomf6IdfB
gwisYfOCLvRnLtieXvlVxCPylMQsClHdtmg06b9dvDEqKnWHsQnqwibUG4DN3MJJ
DIg5xaY67LWuYhacqzSnS6ASe2G2N3eTp5KsuA4xPIcEe9I+0Hft8WzKr9xTgini
yy5+jdNyFxyj/24oPzHVymNXSUFQN/5LP5Jzx/JoXDjNHQIDAQABozwwOjA4BgNV
HR8EMTAvMC2gK6AphidodHRwOi8vZG93bmxvYWQucW5hcC5jb20vY3JsL3F0c192
MS5jcmwwDQYJKoZIhvcNAQELBQADggEBAFpU9Rgx+r/Bt5WiALNv0XcYT4LSl+Gi
/n50xBTReVdsh9BuJbsqubR0MPlQh7QzOmdxl1oXIijwEbqW0XB6u+OCQhWlG+ov
M9cNSlSQ2kN/BFROfibaaDzK652/oSgf4BpouD6DEqZ711QsS2wmwZ8ItfaOrfzJ
z289LIb1AdjQ54J2pepWEBcPxfEq+nEo1ehgGOEzmaLXbvoLp8KkLWFMnBFXzcol
lZP35YBA/EfKMUz5fWaAxnp/joI5Ga74Mpyp6jyx8sWUnYWEqFslnGVpDAkPuvZD
oCVb60Wu8/Rfct9LgB1yFK7C1dnf3SJlYwKTB22etIgCxgFSJWrNHuIxggKbMIIC
lwIBATCBijCBgDELMAkGA1UEBhMCVFcxDzANBgNVBAgMBlRhaXdhbjEPMA0GA1UE
BwwGVGFpcGVpMQ0wCwYDVQQKDARRTkFQMQwwCgYDVQQLDANOQVMxEDAOBgNVBAMM
B1FOQVBfQ0ExIDAeBgkqhkiG9w0BCQEWEXNlY3VyaXR5QHFuYXAuY29tAgUAuENW
7DALBglghkgBZQMEAgGggeQwGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkq
hkiG9w0BCQUxDxcNMjIxMjAyMDMwOTE3WjAvBgkqhkiG9w0BCQQxIgQgvtdZSm+m
c7QevdJma9Em5ycFr3I7Wo4aG40Vcx/mT5IweQYJKoZIhvcNAQkPMWwwajALBglg
hkgBZQMEASowCwYJYIZIAWUDBAEWMAsGCWCGSAFlAwQBAjAKBggqhkiG9w0DBzAO
BggqhkiG9w0DAgICAIAwDQYIKoZIhvcNAwICAUAwBwYFKw4DAgcwDQYIKoZIhvcN
AwICASgwDQYJKoZIhvcNAQEBBQAEggEAuInAOUj+ebOkTqlqg3cf7v2FdKeCvZZn
cunx1xRnHJRVAAvcH/UZ3t7RF6MV5NmEQdVN79NBZl0KU1x7K3zyvcXnkacNuHnI
t+6neKKKkxJmB4hh4ljeYtx9a1RBgwH+PiYyH8+58S7+MF3MVhSH8jEiomgSbvsK
BroOCFQDoYWk14K/VIXW1scmvpNvFNBWwm19pYwi977rF+lPWzMHx/0jVXspFSEd
U48h9xKvPg6CsIlyfuKetHBjZZI6iSCvh2FZOWsD1/W2oGYkkY9Hdff24B34/res
cKXk/K9/JFAONWBbXUpxtzpBCeVJlZS1wQgu4Q+Fr6imaBXJkiyiNg==
EOB

	cmd="DELETE FROM Certificate WHERE QpkgName = '$PACKAGE_NAME'; INSERT INTO Certificate (Type,QpkgName,Cert,DigitalSignature) VALUES ('qpkg','$PACKAGE_NAME','$cert','$signature');"

	$GNU_SQLITE_CMD "$CERT_DB_PATHFILE" "$cmd"
	result_code=$?

	if [[ $result_code -eq 0 ]]; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' ok
		SendPackageStateChange ISsigned
		MarkThisActionForkAsOk
	else
		SaveActionResultToLog QPKG "$PACKAGE_NAME" '"sign"' failed "$result_code"
		result_code=1   # remap to 1
		MarkThisActionForkAsFailed
	fi

	FuncFork:Exit $result_code

	}

_QPKG:status_()
	{

	# * This function runs autonomously *
	# Query a QPKG for its 'status'. Each compatible QPKG will return 0 if application process is active or ready-to-run, 0 if not.

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = none, this function executes in the background

	[[ $opts_verbose != true ]] && exec &>/dev/null
	FuncFork:Entry

	PACKAGE_NAME=${1:?package name null}
	local -i result_code=0
	local package_tests=''
	local debug_cmd=''

	if QPKGs-ISNTinstalled:Exist "$PACKAGE_NAME"; then
		SaveActionResultToLog QPKG "$PACKAGE_NAME" status skipped 'not installed'
		result_code=2
	fi

	if [[ $result_code -gt 0 ]]; then
		MarkThisActionForkAsSkipped
		FuncFork:Exit $result_code
	fi

	DebugAsProc "statusing $(FormatAsPackName "$PACKAGE_NAME")"

	if package_tests=$(QPKG.GetActiveTest "$PACKAGE_NAME"); then
		eval "$package_tests" &>/dev/null
		result_code=$?
	else
		[[ $opts_debug = true ]] && debug_cmd='DEBUG_QPKG=true '

		if [[ -e $GNU_TIMEOUT_CMD ]]; then
			$GNU_TIMEOUT_CMD "$STATUS_CHECK_TIMEOUT_SECONDS" /bin/bash -c "${debug_cmd}$(QPKG.ServicePathFile) status"
			result_code=$?
		else
			RunAndLog "${debug_cmd}$(QPKG.ServicePathFile) status" "$LOGS_PATH/$PACKAGE_NAME.$STATUS_LOG_FILE" log:failure-only
			result_code=$?
		fi
	fi

	DebugVar result_code

	case $result_code in
		0)
			SendPackageStateChange ISactive
			;;
		124)
			SendPackageStateChange ISslow
			;;
		130)
			SendPackageStateChange ISunknown
			;;
		*)
			SendPackageStateChange ISNTactive
	esac

	SaveActionResultToLog QPKG "$PACKAGE_NAME" status ok
	MarkThisActionForkAsOk

	FuncFork:Exit

	}

QPKG.AppCenterNotifier:Clear()
	{

	# input:
	#   $PACKAGE_NAME (global) = QPKG name to clear from notifier list

	# KLUDGE: `clean` QTS 4.5.1+ App Center notifier status
	[[ -e /sbin/qpkg_cli ]] && /sbin/qpkg_cli --cancel "$PACKAGE_NAME"

	QPKG.IsNtInstalled "$PACKAGE_NAME" && return 0

	# need to do this when installing QPKGs at the CLI
	$SETCFG_CMD "$PACKAGE_NAME" Status complete -f /etc/config/qpkg.conf

	return 0

	} &>/dev/null

QPKG.ServiceStatus:Clear()
	{

	# input:
	#   $PACKAGE_NAME (global) = QPKG name

	rm -f "/var/run/$PACKAGE_NAME.last.operation"

	}

QPKG.LastResultWasOk()
	{

	# returns true if last operation for this package is `ok`

	# input:
	#   $PACKAGE_NAME (global) = QPKG name

	[[ $(QPKG.GetServiceStatus "$PACKAGE_NAME") = ok ]]

	}

QPKG.ServiceStatus:Log()
	{

	# input:
	#   $PACKAGE_NAME (global) = QPKG name

	if ! local status=$(QPKG.GetServiceStatus "$PACKAGE_NAME"); then
		DebugAsWarn "unable to get status of $(FormatAsPackName "$PACKAGE_NAME") service. It may be a non-sherpa package, or a sherpa package earlier than 200816c that doesn't support service results."
		return 1
	fi

	case $status in
		starting|stopping|restarting)
			DebugInfo "$(FormatAsPackName "$PACKAGE_NAME") service is $status"
			;;
		ok)
			DebugInfo "$(FormatAsPackName "$PACKAGE_NAME") service action completed OK"
			;;
		failed)
			if [[ -e /var/log/$PACKAGE_NAME.log ]]; then
				DebugAsError "$(FormatAsPackName "$PACKAGE_NAME") service action failed. Check $(FormatAsFileName "/var/log/$PACKAGE_NAME.log") for more information"
				AddExtLogToSessLog /var/log/$PACKAGE_NAME.log
			else
				DebugAsError "$(FormatAsPackName "$PACKAGE_NAME") service action failed"
			fi
			;;
		*)
			DebugAsWarn "$(FormatAsPackName "$PACKAGE_NAME") service status is unrecognised or unsupported"
	esac

	return 0

	}

QPKG.InstallationPath()
	{

	# input:
	#   $1 = QPKG name (optional) - default is `sherpa`

	# output:
	#   stdout = the installation path to this QPKG
	#   $? = 0 if found, !0 if not

	/sbin/getcfg "${1:-sherpa}" Install_Path -f /etc/config/qpkg.conf

	}

QPKG.ServicePathFile()
	{

	# input:
	#   $PACKAGE_NAME (global) = QPKG name (default)
	#   $1 = if specified, use this as QPKG name instead

	# output:
	#   stdout = service script pathfile
	#   $? = 0 if found, !0 if not

	local qpkg_name=${PACKAGE_NAME:-}
	[[ -n ${1:-} ]] && qpkg_name=$1

	/sbin/getcfg "$qpkg_name" Shell -d unknown -f /etc/config/qpkg.conf

	}

QPKG.Avail.Ver()
	{

	# Returns the version number of an available QPKG.

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = package version
	#   $? = 0 if found, !0 if not

	local -i index=0
	local package=''
	local prev=''

	for index in "${!QPKG_NAME[@]}"; do
		package="${QPKG_NAME[$index]}"
		[[ $package = "$prev" ]] && continue || prev=$package

		if [[ $1 = "$package" ]]; then
			echo "${QPKG_VERSION[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.Local.Ver()
	{

	# Returns the version number of an installed QPKG.

	# input:
	#   $1 = QPKG name (optional) - default is `sherpa`

	# output:
	#   stdout = package version
	#   $? = 0 if found, !0 if not

	/sbin/getcfg "${1:-sherpa}" Version -d unknown -f /etc/config/qpkg.conf

	}

QPKG.StoreID()
	{

	# Returns the presently assigned repository store ID of an installed QPKG.

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = package store ID

	/sbin/getcfg "${1:?package name null}" store -d sherpa -f /etc/config/qpkg.conf

	return 0

	}

QPKG.InstallDate()
	{

	# Returns the date specified QPKG was installed.

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = package store ID

	/sbin/getcfg "${1:?package name null}" date -f /etc/config/qpkg.conf

	return 0

	}

QPKG.IsBackupExist()
	{

	# Does this QPKG have an existing `backup` file?

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 if true, 1 if false

	[[ -e $QPKG_BU_PATH/${1:?package name null}.config.tar.gz ]]

	}

QPKG.Author()
	{

	# Return the maintainer of the specified QPKG

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = QPKG author (first package found)
	#   $? = 0 if found, !0 if not

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			echo "${QPKG_AUTHOR[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.AppAuthor()
	{

	# Return the author of the application contained within the specified QPKG

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = application author (first package found)
	#   $? = 0 if found, !0 if not

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			echo "${QPKG_APP_AUTHOR[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.GetActiveTest()
	{

	# Return the tests required to determine if specified QPKG is active or not

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = bash tests
	#   $? = 0 if found, !0 if not

	local -i index=0
	local buff=''

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			buff="${QPKG_TEST_FOR_ACTIVE[$index]}"

			if [[ -n $buff ]]; then
				echo "$buff"
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.IsCanBackup()
	{

	# Does this QPKG service-script support `backup` and `restore` actions?

	# input:
	#   $PACKAGE_NAME (global) = QPKG name (default)
	#   $1 = if specified, use this as QPKG name instead

	# output:
	#   $? = 0 if true, 1 if false (first package found)

	local -i index=0
	local qpkg_name=${PACKAGE_NAME:-}
	[[ -n ${1:-} ]] && qpkg_name=$1

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "$qpkg_name" ]]; then
			if ${QPKG_CAN_BACKUP[$index]}; then
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.IsCanRestartToUpdate()
	{

	# Does this QPKG service-script support updating the internal application when the QPKG is restarted?

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 if true, 1 if false (first package found)

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			if ${QPKG_CAN_RESTART_TO_UPDATE[$index]}; then
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.IsCanClean()
	{

	# Does this QPKG service-script support cleaning of the internal application?

	# input:
	#   $PACKAGE_NAME (global) = QPKG name (default)
	#   $1 = if specified, use this as QPKG name instead

	# output:
	#   $? = 0 if true, 1 if false (first package found)

	local -i index=0
	local qpkg_name=${PACKAGE_NAME:-}
	[[ -n ${1:-} ]] && qpkg_name=$1

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "$qpkg_name" ]]; then
			if ${QPKG_CAN_CLEAN[$index]}; then
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.IsCanLog()
	{

	# Does this QPKG service-script support logging of operations? When an action fails, this means user can be directed to check the service script log.

	# input:
	#   $PACKAGE_NAME (global) = QPKG name (default)
	#   $1 = if specified, use this as QPKG name instead

	# output:
	#   $? = 0 if true, 1 if false (first package found)

	local -i index=0
	local qpkg_name=${PACKAGE_NAME:-}
	[[ -n ${1:-} ]] && qpkg_name=$1

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "$qpkg_name" ]]; then
			if ${QPKG_CAN_LOG_SERVICE_OPERATIONS[$index]}; then
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.IsDependent()
	{

	# Does this QPKG depend on any other QPKGs?

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 if true, 1 if false (first package found)

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			if [[ -n ${QPKG_DEPENDS_ON[$index]} ]]; then
				return 0
			else
				break
			fi
		fi
	done

	return 1

	}

QPKG.OriginalPath()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = the original installation path of this QPKG (even if it was migrated to another volume)
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	if [[ ${#QPKGs_were_installed_name[@]} -gt 0 ]]; then
		for index in "${!QPKGs_were_installed_name[@]}"; do
			if [[ ${QPKGs_were_installed_name[$index]} = "${1:?package name null}" ]]; then
				echo "${QPKGs_were_installed_path[$index]}"
				return 0
			fi
		done
	fi

	return 1

	}

QPKG.Abbrvs()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = list of abbreviations that may be used to specify this package (first package found)
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			echo "${QPKG_ABBRVS[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.MatchAbbrv()
	{

	# input:
	#   $1 = a potential package abbreviation supplied by user

	# output:
	#   stdout = matched installable package name (empty if unmatched)
	#   $? = 0 (matched) or 1 (unmatched)

	local -a abbs=()
	local -i package_index=0
	local -i abb_index=0
	local -i result_code=1

	for package_index in "${!QPKG_NAME[@]}"; do
		abbs=(${QPKG_ABBRVS[$package_index]})

		for abb_index in "${!abbs[@]}"; do
			if [[ ${abbs[$abb_index]} = "$1" ]]; then
				Display "${QPKG_NAME[$package_index]}"
				result_code=0
				break 2
			fi
		done
	done

	return $result_code

	}

QPKG.PathFilename()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = QPKG local filename
	#   $? = 0 if successful, 1 if failed

	local url=$(QPKG.URL "${1:?package name null}")

	[[ -n ${url:-} ]] || return
	[[ $(Lowercase "${url##*.}") != qpkg ]] && url=${url%.*}.qpkg		# swap `zip` for `qpkg` here (only used for `QDK.zip`)

	echo "$QPKG_DL_PATH/$($BASENAME_CMD "$url")"
	return 0

	}

QPKG.URL()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = QPKG remote URL, specific to this NAS arch
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]] && [[ ${QPKG_ARCH[$index]} = all || ${QPKG_ARCH[$index]} = "$NAS_QPKG_ARCH" ]]; then
			echo "${QPKG_URL[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.Desc()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = QPKG description (first package found)
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			echo "${QPKG_DESC[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.Note()
	{

	# return any additional notes to be prominently displayed

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = package note (first package found)
	#   $? = 0 if found, !0 if not

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]]; then
			echo "${QPKG_NOTE[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.MD5()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = QPKG MD5, specific to this NAS arch
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]] && [[ ${QPKG_ARCH[$index]} = all || ${QPKG_ARCH[$index]} = "$NAS_QPKG_ARCH" ]]; then
			echo "${QPKG_MD5[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG.MinRAM()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = minimum kB of installed RAM required by this QPKG (first package found)
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]] && [[ ${QPKG_MIN_RAM_KB[$index]} = none || $NAS_RAM_KB -ge ${QPKG_MIN_RAM_KB[$index]} ]]; then
			echo "${QPKG_MIN_RAM_KB[$index]}"
			return 0
		fi
	done

	return 1

	}

QPKG:GetStandalones()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = list of QPKGs this QPKG depends-upon (first package found)
	#   $? = 0 if successful, 1 if failed

	local -i index=0

	for index in "${!QPKG_NAME[@]}"; do
		if [[ ${QPKG_NAME[$index]} = "${1:?package name null}" ]] && [[ ${QPKG_ARCH[$index]} = all || ${QPKG_ARCH[$index]} = "$NAS_QPKG_ARCH" ]]; then
			if [[ ${QPKG_DEPENDS_ON[$index]} != none ]]; then
				echo "${QPKG_DEPENDS_ON[$index]}"
				return 0
			fi
		fi
	done

	return 1

	}

QPKG:GetDependents()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   stdout = list of QPKGs that depend-upon this QPKG (first package found)
	#   $? = 0 if successful, 1 if failed

	local -i index=0
	local -a acc=()
	local re=\\b${1:-}\\b

	if QPKGs-SCstandalone:Exist "$1"; then
		for index in "${!QPKG_NAME[@]}"; do
			if [[ ${QPKG_DEPENDS_ON[$index]} =~ $re ]]; then
				[[ ${acc[*]:-} != "${QPKG_NAME[$index]}" ]] && acc+=(${QPKG_NAME[$index]})
			fi
		done
	fi

	if [[ ${#acc[@]} -gt 0 ]]; then
		echo "${acc[@]}"
		return 0
	fi

	return 1

	}

QPKG.IsInstalled()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 (true) or 1 (false)

	$GREP_CMD -q "^\[${1:?package name null}\]" /etc/config/qpkg.conf

	}

QPKG.IsNtInstalled()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 (true) or 1 (false)

	! QPKG.IsInstalled "${1:?package name null}"

	}

QPKG.IsEnabled()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   $? = 0 (true) or 1 (false)

	[[ $(/sbin/getcfg "${1:?package name null}" Enable -u -f /etc/config/qpkg.conf) = TRUE ]]

	}

QPKG.GetServiceStatus()
	{

	# input:
	#   $1 = QPKG name

	# output:
	#   $stdout = last known package service status
	#   $? = 0 if found, 1 if not found

	local -r PACKAGE_NAME=${1:?package name null}

	[[ -e /var/run/$PACKAGE_NAME.last.operation ]] && echo "$(</var/run/"$PACKAGE_NAME".last.operation)"

	}

MakePath()
	{

	# input:
	#   $1 = path to create
	#   $2 = reason for this path

	if ! mkdir -p "${1:?path null}"; then
		ShowAsError "unable to create ${2:?null} path $(FormatAsFileName "$1") $(FormatAsExitcode "$?")"
		show_suggest_raise_issue=true
		return 1
	fi

	return 0

	}

RunAndLog()
	{

	# Run a commandstring, log the results, and show onscreen if required

	# input:
	#   $1 = commandstring to execute
	#   $2 = pathfile to record stdout and stderr for commandstring
	#   $3 = `log:failure-only` (optional) - if specified, stdout & stderr are only recorded in the specified log if the command failed. default is to always record stdout & stderr.
	#   $4 = e.g. `10` (optional) - an additional acceptable result code. Any other result from command (other than zero) will be considered a failure

	# output:
	#   stdout = commandstring stdout and stderr if script is in `debug` mode
	#   pathfile (specified as $2) = stdout and stderr from commandstring (specified as $1)
	#   $? = result_code of commandstring

	Func:Entry
	local -r LOG_PATHFILE=$($MKTEMP_CMD /var/log/"${FUNCNAME[0]}"_XXXXXX)
	local -i result_code=0

	FormatAsCommand "${1:?null}" > "${2:?null}"
	DebugAsProc "exec: '$1'"

	if [[ $opts_verbose = true ]]; then
		eval "$1 > >($TEE_CMD $LOG_PATHFILE) 2>&1"	# NOTE: `tee` buffers stdout here
		result_code=$?
	else
		eval "$1" > "$LOG_PATHFILE" 2>&1
		result_code=$?
	fi

	if [[ -e $LOG_PATHFILE ]]; then
		FormatAsResultAndStdout "$result_code" "$(<"$LOG_PATHFILE")" >> "$2"
		rm -f "$LOG_PATHFILE"
	else
		FormatAsResultAndStdout "$result_code" '<null>' >> "$2"
	fi

	case $result_code in
		0|"${4:-}")
			[[ ${3:-} != log:failure-only ]] && AddExtLogToSessLog "$2"
			DebugAsDone 'exec: complete'
			[[ $opts_debug = false ]] && rm -f "$2"
			;;
		*)
			AddExtLogToSessLog "$2"
			DebugAsError 'exec: complete, but with errors'
	esac

	Func:Exit $result_code

	}

DeDupeWords()
	{

	tr ' ' '\n' <<< "${1:-}" | $SORT_CMD | $UNIQ_CMD | tr '\n' ' ' | $SED_CMD 's|^[[:blank:]]*||;s|[[:blank:]]*$||'

	}

FileMatchesMD5()
	{

	# input:
	#   $1 = pathfile to generate an MD5 checksum for
	#   $2 = MD5 checksum to compare against

	[[ $($MD5SUM_CMD "${1:?pathfile null}" | cut -f1 -d' ') = "${2:?comparison checksum null}" ]]

	}

Pluralise()
	{

	[[ ${1:-0} -ne 1 ]] && echo s

	}

Capitalise()
	{

	# capitalise first character of $1

	echo "$(Uppercase ${1:0:1})${1:1}"

	}

Uppercase()
	{

	tr 'a-z' 'A-Z' <<< "$1"

	}

Lowercase()
	{

	tr 'A-Z' 'a-z' <<< "$1"

	}

FormatAsThous()
	{

	# Format as thousands

	# A string-based thousands-group formatter totally unreliant on locale
	# Why? Because builtin `printf` in 32b ARM QTS versions doesn't follow locale ¯\_(ツ)_/¯

	# $1 = integer value

	local rightside_group=''
	local foutput=''
	local remainder=$($SED_CMD 's/[^0-9]*//g' <<< "${1:-}")	# strip everything not a numeral

	while [[ ${#remainder} -gt 0 ]]; do
		rightside_group=${remainder:${#remainder}<3?0:-3}	# a nifty trick found here: https://stackoverflow.com/a/19858692

		if [[ -z $foutput ]]; then
			foutput=$rightside_group
		else
			foutput=$rightside_group,$foutput
		fi

		if [[ ${#rightside_group} -eq 3 ]]; then
			remainder=${remainder%???}						# trim rightside 3 characters
		else
			break
		fi
	done

	echo "$foutput"
	return 0

	}

FormatAsIsoBytes()
	{

	$AWK_CMD 'BEGIN{ u[0]="B"; u[1]="kB"; u[2]="MB"; u[3]="GB"} { n = $1; i = 0; while(n > 1000) { i+=1; n= int((n/1000)+0.5) } print n u[i] } ' <<< "$1"

	}

FormatAsTitle()
	{

	# format as script title

	ColourTextBrightWhite sherpa

	}

FormatAsVersion()
	{

	echo "$THIS_SCRIPT_VER"

	}

FormatAsDescription()
	{

	echo "${CHARS_SPECIAL}a mini-package-manager for QNAP NAS"

	}

FormatAsAction()
	{

	ColourTextBrightYellow '[action]'

	}

FormatAsPackages()
	{

	ColourTextBrightOrange '[packages]'

	}

FormatAsGroup()
	{

	ColourTextBrightOrange '[package group]'

	}

FormatAsOptions()
	{

	ColourTextBrightRed '[options]'

	}

FormatAsPackName()
	{

	# format as package name

	echo "'${1:?package name null}'"

	}

FormatAsFileName()
	{

	echo "(${1:?filename null})"

	}

FormatAsURL()
	{

	ColourTextUnderlinedCyan "${1:-}"

	}

FormatAsExitcode()
	{

	echo "[${1:?exitcode null}]"

	}

FormatAsLogFilename()
	{

	echo "${CHARS_RESULTS}log file: '${1:?filename null}'"

	}

FormatAsCommand()
	{

	echo "${CHARS_RESULTS}command: '${1:?command null}'"

	}

FormatAsResult()
	{

	local prefix="$CHARS_RESULTS"
	[[ ${1:-0} -ne 0 ]] && prefix="$CHARS_ALERT"
	echo "${prefix}result_code: $(FormatAsExitcode "${1:-}")"

	}

FormatAsResultAndStdout()
	{

	local prefix="$CHARS_RESULTS"
	[[ ${1:-0} -ne 0 ]] && prefix="$CHARS_ALERT"
	echo "${prefix}result_code: $(FormatAsExitcode "${1:-}") ***** stdout/stderr begins below *****"
	echo "${2:-}"
	echo "${prefix}***** stdout/stderr is complete *****"

	}

DisplayLineSpaceIfNoneAlready()
	{

	if [[ $linespace_visible = false && $hide_title = false ]]; then
		echo
		linespace_visible=true
	else
		linespace_visible=false
	fi

	}

DebugInfoMajSepr()
	{

	# debug info major separator

	DebugInfo "$(eval printf '%0.s=' "{1..$DEBUG_LOG_DATAWIDTH}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead

	}

DebugInfoMinSepr()
	{

	# debug info minor separator

	DebugInfo "$(eval printf '%0.s-' "{1..$DEBUG_LOG_DATAWIDTH}")"  # `seq` is unavailable in QTS, so must resort to `eval` trickery instead

	}

DebugExtLogMinSepr()
	{

	# debug external log minor separator

	DebugAsLog "$(eval printf '%0.s-' "{1..$DEBUG_LOG_DATAWIDTH}")" # `seq` is unavailable in QTS, so must resort to `eval` trickery instead

	}

DebugScript()
	{

	DebugDetectTabld SCRIPT "${1:-}" "${2:-}"

	}

DebugHardware()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld HARDWARE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld HARDWARE "${2:-}" "${3:-}"
	esac

	}

DebugFirmware()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld FIRMWARE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld FIRMWARE "${2:-}" "${3:-}"
	esac

	}

DebugUserspace()
	{

	case ${1:-} in
		warning)
			DebugWarningTabld USERSPACE "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld USERSPACE "${2:-}" "${3:-}"
	esac

	}

DebugIpk()
	{

	case ${1:-} in
		error)
			DebugErrorTabld IPK "${2:-}" "${3:-}"
			;;
		*)
			DebugInfoTabld IPK "${2:-}" "${3:-}"
	esac

	}

DebugQpkg()
	{

	case ${1:-} in
		error)
			DebugErrorTabld QPKG "${2:-}" "${3:-}"
			;;
		warning)
			DebugWarningTabld QPKG "${2:-}" "${3:-}"
			;;
		info)
			DebugInfoTabld QPKG "${2:-}" "${3:-}"
			;;
		*)
			DebugDetectTabld QPKG "${2:-}" "${3:-}"
	esac

	}

DebugDetectTabld()
	{

	# debug detected tabulated

	if [[ -z ${3:-} ]]; then			# if $3 is nothing, then assume only 2 fields are required
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# if $3 is only a whitespace then print $2 with trailing colon and `none` as third field
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# if $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsDetect "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugInfoTabld()
	{

	# debug info tabulated

	if [[ -z ${3:-} ]]; then			# if $3 is nothing, then assume only 2 fields are required
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# if $3 is only a whitespace then print $2 with trailing colon and `none` as third field
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# if $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsInfo "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugWarningTabld()
	{

	# debug warning tabulated

	if [[ -z ${3:-} ]]; then			# if $3 is nothing, then assume only 2 fields are required
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# if $3 is only a whitespace then print $2 with trailing colon and `none` as third field
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# if $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsWarn "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugErrorTabld()
	{

	# debug error tabulated

	if [[ -z ${3:-} ]]; then			# if $3 is nothing, then assume only 2 fields are required
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s\n" "${1:-}" "${2:-}")"
	elif [[ ${3:-} = ' ' ]]; then		# if $3 is only a whitespace then print $2 with trailing colon and `none` as third field
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: none\n" "${1:-}" "${2:-}")"
	elif [[ ${3: -1} = ' ' ]]; then		# if $3 has a trailing whitespace then print $3 without the trailing whitespace
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "$($SED_CMD 's| *$||' <<< "${3:-}")")"
	else
		DebugAsError "$(printf "%${DEBUG_LOG_FIRST_COL_WIDTH}s: %${DEBUG_LOG_SECOND_COL_WIDTH}s: %-s\n" "${1:-}" "${2:-}" "${3:-}")"
	fi

	}

DebugVar()
	{

	# had to split this onto its own line so Kate editor won't choke when highlighting syntax
	local temp=${!1}

	DebugAsVar "\$$1 : '$temp'"

	}

DebugInfo()
	{

	if [[ ${2:-} = ' ' || ${2:-} = "'' " ]]; then	# if $2 has no usable content then print $1 with trailing colon and `none` as second field
		DebugAsInfo "${1:-}: none"
	elif [[ -n ${2:-} ]]; then
		DebugAsInfo "${1:-}: ${2:-}"
	else
		DebugAsInfo "${1:-}"
	fi

	}

Func:Entry()
	{

	# debug function entry

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	eval "$var_safe_name=$(/bin/date +%s%N)"
	DebugAsFuncEn

	}

Func:Exit()
	{

	# debug function exit

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	DebugAsFuncEx "${1:-0}" "$(FormatAsDuration "$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")")"
	return ${1:-0}

	}

FuncFork:Entry()
	{

	# debug forked function entry

	# redirect debug output to a temporary log, then add it to session log before exiting. This will keep action log progress in-order
	original_session_log_pathfile="$sess_active_pathfile"
	sess_active_pathfile=$($MKTEMP_CMD /var/log/"${FUNCNAME[1]}"_XXXXXX)

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}
	eval "$var_safe_name=$(/bin/date +%s%N)"

	DebugAsFuncEn

	}

FuncFork:Exit()
	{

	# debug forked function exit

	local -r VAR_NAME=${FUNCNAME[1]}_STARTSECONDS
	local var_safe_name=${VAR_NAME//[.-]/_}
	var_safe_name=${var_safe_name//:/_}

	SendActionStatus ex
	DebugAsFuncEx "${1:-0}" "$(FormatAsDuration "$(CalcMilliDifference "${!var_safe_name}" "$(/bin/date +%s%N)")")"

	if [[ -n $sess_active_pathfile && -e $sess_active_pathfile && -s $sess_active_pathfile ]]; then
		$CAT_CMD "$sess_active_pathfile" >> "$original_session_log_pathfile"
		rm "$sess_active_pathfile"
		sess_active_pathfile="$original_session_log_pathfile"
	fi

	exit ${1:-0}

	}

CalcMilliDifference()
	{

	# input:
	#	$1 = starttime in epoch nanoseconds
	#	$2 = endtime in epoch nanoseconds

	# output:
	#	stdout = difference in milliseconds

	echo "$((($2-$1)/1000000))"

	}

FormatAsDuration()
	{

	# input:
	#	$1 = duration in milliseconds

	if [[ ${1:-0} -lt 30000 ]]; then
		echo "$(FormatAsThous "${1:-0}")ms"
	else
		FormatSecsToHoursMinutesSecs "$(($1/1000))"
	fi

	}

DebugAsFuncEn()
	{

	DebugThis "(>>) ${FUNCNAME[2]}()"

	}

DebugAsFuncEx()
	{

	DebugThis "(<<) ${FUNCNAME[2]}|${1:-0}|${2:-}"

	}

DebugAsProc()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(--) ${1:-}"

	}

DebugAsDone()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(==) ${1:-}"

	}

DebugAsDetect()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(**) ${1:-}"

	}

DebugAsInfo()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(II) ${1:-}"

	}

DebugAsWarn()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(WW) ${1:-}"

	}

DebugAsError()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(EE) ${1:-}"

	}

DebugAsLog()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(LL) ${1:-}"

	}

DebugAsVar()
	{

	[[ -z ${1:-} ]] && return
	DebugThis "(vv) ${1:-}"

	}

DebugThis()
	{

	[[ -z ${1:-} ]] && return
	[[ ${opts_verbose:-false} = true ]] && ShowAsDebug "${1:-}"
	WriteToLog dbug "${1:-}"

	}

AddExtLogToSessLog()
	{

	# Add the contents of pathfile $1 to the session debug log, with each line formatted as an external log entry

	local linebuff=''
	local original_verbose=false

	if [[ $opts_verbose = true ]]; then   # prevent external log contents appearing onscreen again, because they've already been seen "live"
		original_verbose=true
		opts_verbose=false
	fi

	DebugAsLog 'adding external log to main log'
	DebugExtLogMinSepr
	DebugAsLog "$(FormatAsLogFilename "${1:?filename null}")"

	while read -r linebuff; do
		DebugAsLog "$linebuff"
	done < "${1:?filename null}"

	DebugExtLogMinSepr
	opts_verbose=$original_verbose

	}

ShowAsProcLong()
	{

	ShowAsProc "${1:-} (might take a while)" "${2:-}"

	}

ShowAsProc()
	{

	local suffix=''
	[[ -n ${2:-} ]] && suffix=": $2"

	EraseThisLine
	WriteToDisplayWait "$(ColourTextBrightYellow proc)" "${1:-}${suffix}"
	WriteToLog proc "${1:-}${suffix}"
	[[ ${opts_verbose:=false} = true ]] && Display

	} >&2

ShowAsDebug()
	{

	WriteToDisplayNew "$(ColourTextBlackOnCyan dbug)" "${1:-}"

	}

ShowAsInfo()
	{

	# note to user

	EraseThisLine
	WriteToDisplayNew "$(ColourTextBrightYellow note)" "${1:-}"
	WriteToLog note "${1:-}"

	} >&2

ShowAsQuiz()
	{

	WriteToDisplayWait "$(ColourTextBrightOrangeBlink quiz)" "${1:-}:"
	WriteToLog quiz "${1:-}:"

	}

ShowAsQuizDone()
	{

	WriteToDisplayNew "$(ColourTextBrightOrange quiz)" "${1:-}"

	}

ShowAsDone()
	{

	# process completed OK

	EraseThisLine
	WriteToDisplayNew "$(ColourTextBrightGreen 'done')" "${1:-}"
	WriteToLog 'done' "$1"

	} >&2

ShowAsWarn()
	{

	# warning only

	EraseThisLine
	WriteToDisplayNew "$(ColourTextBrightOrange warn)" "${1:-}"
	WriteToLog warn "$1"

	} >&2

ShowAsAbort()
	{

	# fatal abort

	WriteToDisplayNew "$(ColourTextBrightRed bort)" "${1:-}"
	WriteToLog bort "$1"
	Self.Error:Set

	} >&2

ShowAsFail()
	{

	# non-fatal error

	EraseThisLine
	local capitalised="$(Capitalise "${1:-}")"
	WriteToDisplayNew "$(ColourTextBrightRed fail)" "$capitalised"
	WriteToLog fail "$capitalised"

	} >&2

ShowAsError()
	{

	# fatal error

	EraseThisLine
	local capitalised="$(Capitalise "${1:-}")"
	WriteToDisplayNew "$(ColourTextBrightRed derp)" "$capitalised"
	WriteToLog derp "$capitalised"
	Self.Error:Set

	} >&2

ShowAsActionProgress()
	{

	# Show single action package progress as percent-complete and a fraction of the total

	# input:
	#	$1 = tier (optional)
	#	$2 = package type: `qpkg`, `ipk`, `pip`
	#	$3 = ok count
	#	$4 = skip count
	#	$5 = fail count
	#	$6 = total count
	#	$7 = verb (present)
	#	$8 = expected action duration: `long` (optional)

	if [[ -n $1 && $1 != all ]]; then
		local tier=" $(Lowercase "$1")"
	else
		local tier=''
	fi

	local -r PACKAGE_TYPE=${2:?null}
	declare -i -r OK_COUNT=${3:-0}
	declare -i -r SKIP_COUNT=${4:-0}
	declare -i -r FAIL_COUNT=${5:-0}
	declare -i -r TOTAL_COUNT=${6:-0}
	local -r ACTION_PRESENT_MSG=${7:?null}
	local -r DURATION=${8:-}
	local progress_msg=''

	progress_msg="$(PercFrac "$OK_COUNT" "$SKIP_COUNT" "$FAIL_COUNT" "$TOTAL_COUNT")"

	if [[ $DURATION != long ]]; then
		ShowAsProc "$ACTION_PRESENT_MSG ${TOTAL_COUNT}${tier} ${PACKAGE_TYPE}$(Pluralise "$TOTAL_COUNT")" "$progress_msg"
	else
		ShowAsProcLong "$ACTION_PRESENT_MSG ${TOTAL_COUNT}${tier} ${PACKAGE_TYPE}$(Pluralise "$TOTAL_COUNT")" "$progress_msg"
	fi

	[[ $((OK_COUNT+SKIP_COUNT+FAIL_COUNT)) -ge $TOTAL_COUNT ]] && sleep 1

	return 0

	}

PercFrac()
	{

	# calculate percent-complete and a fraction of the total

	# input:
	#	$1 = ok count
	#	$2 = skip count
	#	$3 = fail count
	#	$4 = total count

	declare -i -r OK_COUNT=${1:-0}
	declare -i -r SKIP_COUNT=${2:-0}
	declare -i -r FAIL_COUNT=${3:-0}
	declare -i -r TOTAL_COUNT=${4:-0}
	local -i progress_count="$((OK_COUNT+SKIP_COUNT+FAIL_COUNT))"
	local perc_msg=''

	[[ $TOTAL_COUNT -gt 0 ]] || return		# no-point calculating a fraction of zero

	if [[ $progress_count -gt $TOTAL_COUNT ]]; then
		progress_count=$TOTAL_COUNT
		perc_msg='100%'
	else
		perc_msg="$((200*(progress_count+1)/(TOTAL_COUNT+1)%2+100*(progress_count+1)/(TOTAL_COUNT+1)))%"
	fi

	echo "$perc_msg ($(ColourTextBrightWhite "$progress_count")/$(ColourTextBrightWhite "$TOTAL_COUNT"))"

	return 0

	} 2>/dev/null

ShowAsActionResult()
	{

	# input:
	#	$1 = tier (optional) e.g. `standalone`, `dependent`, `addon`, `all`
	#	$2 = package type: `qpkg`, `ipk`, `pip`
	#	$3 = ok count
	#	$4 = total count
	#	$5 = verb (past)

	if [[ -n $1 && $1 != all ]]; then
		local -r TIER=" $1"
	else
		local -r TIER=''
	fi

	local -r PACKAGE_TYPE=$(Uppercase "${2:?null}")
	declare -i -r OK_COUNT=${3:-0}
	declare -i -r TOTAL_COUNT=${4:-0}
	local msg="${5:?null} "

	if [[ $OK_COUNT -gt 0 ]]; then
		msg+="${OK_COUNT}${TIER} ${PACKAGE_TYPE}$(Pluralise "$OK_COUNT")"
	else
		msg+="no${TIER} ${PACKAGE_TYPE}s"
	fi

	case $TOTAL_COUNT in
		0)
			DebugAsDone "no${TIER} ${PACKAGE_TYPE}s processed"
			;;
		*)
			ShowAsDone "$msg"
	esac

	return 0

	} >&2

ShowAsActionResultDetail()
	{

	# input:
	#	$1 = tier
	#	$2 = action
	#	$3 = package type

	local sk_msg=''
	local er_msg=''
	local -i skip_acc=0
	local -i fail_acc=0

	case $3 in
		QPKG)
			if [[ $(QPKGs-AC${2}-sk:Count) -gt 0 || $(QPKGs-AC${2}-se:Count) -gt 0 ]]; then
				case $1 in
					dependent)
						for package in $(QPKGs-AC${2}-sk:Array) $(QPKGs-AC${2}-se:Array); do
							QPKG.IsDependent "$package" && ((skip_acc++))
						done
						;;
					standalone)
						for package in $(QPKGs-AC${2}-sk:Array) $(QPKGs-AC${2}-se:Array); do
							! QPKG.IsDependent "$package" && ((skip_acc++))
						done
						;;
					*)
						skip_acc=$(($(QPKGs-AC${2}-sk:Count)+$(QPKGs-AC${2}-se:Count)))
				esac

				if [[ $skip_acc -gt 0 ]]; then
					sk_msg="$(ColourTextBrightOrange 'skipped') $skip_acc QPKG$(Pluralise "$skip_acc")"
				fi
			fi

			if [[ $(QPKGs-AC${2}-er:Count) -gt 0 ]]; then
				case $1 in
					dependent)
						for package in $(QPKGs-AC${2}-er:Array); do
							QPKG.IsDependent "$package" && ((fail_acc++))
						done
						;;
					standalone)
						for package in $(QPKGs-AC${2}-er:Array); do
							! QPKG.IsDependent "$package" && ((fail_acc++))
						done
						;;
					*)
						fail_acc=$(QPKGs-AC${2}-er:Count)
				esac

				if [[ $fail_acc -gt 0 ]]; then
					er_msg="$(ColourTextBrightRed 'failed') $fail_acc QPKG$(Pluralise "$fail_acc")"
				fi
			fi
			;;
		IPK)
			;;
		PIP)
			:
	esac

	if [[ -z $sk_msg && -z $er_msg ]]; then
		return
	elif [[ -n $sk_msg && -z $er_msg ]]; then
		DisplayAsActionResultLastLine "$sk_msg"
	elif [[ -z $sk_msg && -n $er_msg ]]; then
		DisplayAsActionResultLastLine "$er_msg"
	else
		DisplayAsActionResultNtLastLine "$sk_msg"
		DisplayAsActionResultLastLine "$er_msg"
	fi

	} >&2

ShowAsActionLogDetail()
	{

	# input:								example:
	#   $1 = datetime in seconds (unused)
	#   $2 = package or group name			`SABnzbd`, `essential`
	#   $3 = action							`download`, 'downloaded'
	#   $4 = result							`ok`, `skipped-ok`, `skipped`, `failed`
	#   $5 = duration in milliseconds
	#   $6 = reason (optional)				"file already exists in local cache"

	case ${4:-} in
		skipped|skipped-failed)
			if [[ -n "${6:-}" ]]; then
				DisplayAsIndentPrefixActionResultDurationReason '' "$3" "$2" '' "reason: $6"
			else
				DisplayAsIndentPrefixActionResultDurationReason '' "$3" "$2" '' "no reason was provided by $(FormatAsTitle)"
			fi
			;;
		failed)
			if [[ -n "${6:-}" ]]; then
				if QPKG.IsCanLog "$2"; then
					DisplayAsIndentPrefixActionResultDurationReason 'Unable to ' "$3" "$2" "$5" "For more information, please check the service log: /etc/init.d/$($BASENAME_CMD "$(QPKG.ServicePathFile "$2")") log"
				else
					DisplayAsIndentPrefixActionResultDurationReason 'Unable to ' "$3" "$2" "$5" "reason: $6"
				fi
			else
				DisplayAsIndentPrefixActionResultDurationReason 'Unable to ' "$3" "$2" "$5" 'no reason was provided by the service script'
			fi
			;;
		*)
			DisplayAsIndentPrefixActionResultDurationReason '' "$3" "$2" "$5"
	esac

	}

WriteToDisplayWait()
	{

	# Writes a new message without newline

	# input:
	#	$1 = pass/fail
	#	$2 = message

	# output:
	#	$prev_msg = (global) will be used again later

	local -i width=4

	[[ $colourful = true ]] && width=10  # allow extra length for ANSI codes
	prev_msg=$(printf "%-${width}s: %s" "${1:-}" "${2:-}")

	DisplayWait "$prev_msg"

	return 0

	}

WriteToDisplayNew()
	{

	# Updates the previous message

	# input:
	#	$1 = pass/fail
	#	$2 = message

	# output:
	#	stdout = overwrites previous message with updated message
	#	$prev_length

	local -i width=4
	local -i length=0
	local -i blanking_length=0
	local msg=''
	local strbuffer=''

	[[ $colourful = true ]] && width=10  # allow extra length for ANSI codes
	msg=$(printf "%-${width}s: %s" "${1:-}" "${2:-}")

	if [[ $msg != "${prev_msg:=''}" ]]; then
		prev_length=$((${#prev_msg}+1))
		length=$((${#msg}+1))

		# jump to start of line, print new msg
		strbuffer=$(echo -en "\r$msg ")

		# if new msg is shorter then add spaces to end to cover previous msg

		if [[ $length -lt $prev_length ]]; then
			blanking_length=$((length-prev_length))
			strbuffer+=$(printf "%${blanking_length}s")
		fi

		Display "$strbuffer"
	fi

	return 0

	}

WriteToLog()
	{

	# input:
	#	$1 = pass/fail
	#	$2 = message

	[[ ${opts_debug:=false} = false ]] && return
	[[ -n ${sess_active_pathfile:-} ]] && printf '%-4s: %s\n' "$(StripANSI "${1:-}")" "$(StripANSI "${2:-}")" >> "$sess_active_pathfile"

	}

ColourTextBrightGreen()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;32m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightYellow()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;33m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightOrange()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;38;5;214m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightOrangeBlink()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;5;38;5;214m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightRed()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;31m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightRedBlink()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;5;31m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextCyan()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;36m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextDarkGrey()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;90m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextUnderlinedCyan()
	{

	if [[ $colourful = true ]]; then
		printf '\033[4;36m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBlackOnCyan()
	{

	if [[ $colourful = true ]]; then
		printf '\033[30;46m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

ColourTextBrightWhite()
	{

	if [[ $colourful = true ]]; then
		printf '\033[1;97m%s\033[0m' "${1:-}"
	else
		printf '%s' "${1:-}"
	fi

	} 2>/dev/null

StripANSI()
	{

	# QTS 4.2.6 BusyBox `sed` doesn't fully support extended regexes, so code-stripping only works with a real `sed`

	if [[ -e $GNU_SED_CMD && -L /opt/etc/passwd ]]; then   # try to ensure Entware is active before using this utility
		$GNU_SED_CMD -r 's/\x1b\[[0-9;]*m//g' <<< "${1:-}"
	else
		echo "${1:-}"		# can't strip, so pass thru original message unaltered
	fi

	} 2>/dev/null

UpdateColourisation()
	{

	if [[ -e /opt/bin/sed && -L /opt/etc/passwd ]]; then	# try to ensure Entware is active before using this utility
		colourful=true
		SendParentChangeEnv 'colourful=true'
	else
		colourful=false
		SendParentChangeEnv 'colourful=false'
	fi

	} 2>/dev/null

Cursor:Hide()
	{

	[[ $opts_verbose = false ]] && printf '\033[?25l'

	}

Cursor:Show()
	{

	printf '\033[?25h'

	}

Keystrokes:Hide()
	{

	[[ $opts_verbose = false && -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD '-echo'

	}

Keystrokes:Show()
	{

	[[ -e $GNU_STTY_CMD && -t 0 ]] && $GNU_STTY_CMD 'echo'

	}

FormatMillisecsToMinutesSecs()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# input:
	#	$1 = a time in milliseconds to convert to `S seconds` or `Mm:SSs`

	local seconds=$((${1:-0}/1000))
	((m=(seconds%3600)/60))
	((s=seconds%60))

	[[ $s -eq 0 ]] && s=1

	if [[ $m -eq 0 ]]; then
		if [[ $s -eq 1 ]]; then
			printf '%d second' "$s"
		else
			printf '%d seconds' "$s"
		fi
	else
		printf '%dm:%02ds' "$m" "$s"
	fi

	} 2>/dev/null

FormatSecsToHoursMinutesSecs()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# input:
	#	$1 = a time in seconds to convert to `HHh:MMm:SSs`

	((h=${1:-0}/3600))
	((m=(${1:-0}%3600)/60))
	((s=${1:-0}%60))

	printf '%01dh:%02dm:%02ds\n' "$h" "$m" "$s"

	} 2>/dev/null

FormatLongMinutesSecs()
	{

	# input:
	#	$1 = a time in long minutes and seconds to convert to `MMMm:SSs`

	# separate minutes from seconds
	local m=${1%%:*}
	local s=${1#*:}

	# remove leading whitespace
	m=${m##* }
	s=${s##* }

	printf '%01dm:%02ds\n' "$((10#$m))" "$((10#$s))"

	} 2>/dev/null

sleep()
	{

	# input:
	#	$1 = seconds to sleep (decimal or integer) (optional), default is 1 second

	local wait=${1:-}

	[[ ${wait//.} -eq 0 ]] && wait=1

	if [[ -e $GNU_SLEEP_CMD && -L /opt/etc/passwd ]]; then  # try to ensure Entware is active before using this utility
		$GNU_SLEEP_CMD "$wait"
	elif [[ $DECIMAL_SLEEP_SECONDS_SUPPORTED = false ]]; then
		$QTS_SLEEP_CMD "$((${wait%.*}+1))"				# ensure decimal seconds are rounded-up to next integer
	else
		$QTS_SLEEP_CMD "$wait"
	fi

	return 0

	} 2>/dev/null

Objects:Load()
	{

	# Ensure `objects` in the local cache path is up-to-date, then source it

	[[ ${objects_loaded:=false} = true ]] && return

	Func:Entry

	if [[ ! -e $PWD/dont.refresh.objects ]]; then
		if [[ ! -e $OBJECTS_PATHFILE ]] || ! IsThisFileRecent "$OBJECTS_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES"; then
			ShowAsProc 'downloading objects'

			if $CURL_CMD --insecure --silent --fail "$OBJECTS_ARCHIVE_URL" > "$OBJECTS_ARCHIVE_PATHFILE"; then
				$TAR_CMD --extract --gzip --file="$OBJECTS_ARCHIVE_PATHFILE" --directory="$CACHE_PATH"
			fi
		fi
	fi

	if [[ ! -e $OBJECTS_PATHFILE ]]; then
		ShowAsAbort 'objects missing'
		Func:Exit 1; exit
	fi

	ShowAsProc 'loading objects'
	. "$OBJECTS_PATHFILE"
	objects_loaded=true

	readonly OBJECTS_VER
	Func:Exit

	}

Packages:Load()
	{

	# Ensure `packages` in the local cache path is up-to-date, then source it

	[[ ${packages_loaded:=false} = true ]] && return

	Func:Entry

	if [[ ! -e $PWD/dont.refresh.packages ]]; then
		if [[ ! -e $PACKAGES_PATHFILE ]] || ! IsThisFileRecent "$PACKAGES_PATHFILE" "$FILE_CHANGE_THRESHOLD_MINUTES"; then
			ShowAsProc 'downloading package list'

			if $CURL_CMD --insecure --silent --fail "$PACKAGES_ARCHIVE_URL" > "$PACKAGES_ARCHIVE_PATHFILE"; then
				$TAR_CMD --extract --gzip --file="$PACKAGES_ARCHIVE_PATHFILE" --directory="$CACHE_PATH"
			fi
		fi
	fi

	if [[ ! -e $PACKAGES_PATHFILE ]]; then
		ShowAsAbort 'package list missing'
		Func:Exit 1; exit
	fi

	ShowAsProc 'loading package list'
	. "$PACKAGES_PATHFILE"
	packages_loaded=true

	readonly PACKAGES_VER
	readonly BASE_QPKG_CONFLICTS_WITH
	readonly BASE_QPKG_WARNINGS
	readonly ESSENTIAL_IPKS
	readonly ESSENTIAL_PIPS
	readonly MIN_PYTHON_VER
	readonly MIN_PERL_VER

	# package list arrays are now full, so lock them
	readonly QPKG_NAME
		readonly QPKG_ARCH
		readonly QPKG_VERSION
		readonly QPKG_MD5
		readonly QPKG_URL
		readonly QPKG_MIN_RAM_KB
		readonly QPKG_AUTHOR
		readonly QPKG_APP_AUTHOR
		readonly QPKG_DESC
		readonly QPKG_NOTE
		readonly QPKG_ABBRVS
		readonly QPKG_CONFLICTS_WITH
		readonly QPKG_DEPENDS_ON
		readonly QPKG_REQUIRES_IPKS
		readonly QPKG_CAN_BACKUP
		readonly QPKG_CAN_RESTART_TO_UPDATE
		readonly QPKG_CAN_CLEAN
		readonly QPKG_CAN_LOG_SERVICE_OPERATIONS
		readonly QPKG_TEST_FOR_ACTIVE

	DebugScript version "packages: ${PACKAGES_VER:-unknown}"
	QPKGs-SCall:Add "${QPKG_NAME[*]}"
	QPKGs.StandaloneDependent:Build
	Func:Exit

	}

RunOnSIGINT()
	{

	$TOUCH_CMD "$DISPLAY_INHBIT_PATHFILE"
	EraseThisLine
	ShowAsAbort 'caught SIGINT'
	KillActiveFork
	CloseActionMsgPipe
	exit

	}

RunOnEXIT()
	{

	trap - INT
	Keystrokes:Show
	Cursor:Show
	Self.LockFile:Release

	}

Self:Init || exit
Actions:Proc
Self:Results
Self.Error:IsNt
